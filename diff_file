diff --git a/.classpath b/.classpath
deleted file mode 100644
index 470ddef..0000000
--- a/.classpath
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="tests"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derby.jar"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derby.war"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derbyclient.jar"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derbynet.jar"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derbyrun.jar"/>
-	<classpathentry kind="lib" path="db-derby-10.8.2.2-lib/lib/derbytools.jar"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index b2214ca..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-*.*~
-.*~
-*.*.swp
-*.swp
-bin
-docs
-javadoc
-javadocs
-doc
diff --git a/.project b/.project
deleted file mode 100644
index c58f4dc..0000000
--- a/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>MainProject</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/README.textile b/README.textile
deleted file mode 100644
index 2623867..0000000
--- a/README.textile
+++ /dev/null
@@ -1,13 +0,0 @@
-h1. CS 4432 Group 12 Project Files
-
-h2. Members
-
-* Jeff Namias
-* Solly Ross
-* Brian Silvia
-
-h2. Organization
-
-[*SimpleDB readme can be found in README.txt*]
-
-At the start of each project, a new branch will be split off, and master will remain the current project
diff --git a/README.txt b/README.txt
new file mode 100755
index 0000000..00ebd03
--- /dev/null
+++ b/README.txt
@@ -0,0 +1,318 @@
+                      THE SIMPLEDB DATABASE SYSTEM
+                  General Information and Instructions
+
+
+This document contains the following sections:
+    * Release Notes
+    * Server Installation
+    * Running the Server
+    * Running Client Programs
+    * SimpleDB Limitations
+    * The Organization of the Server Code
+
+
+I. Release Notes:
+
+  This release of the SimpleDB system is Version 2.9, which was
+  uploaded on August 1, 2011.  This release provides the following
+  bug fixes to Version 2.8:
+
+    * In SortScan.java, the method beforeFirst now sets the variable
+      currentscan to null.
+    * In SortScan.java, the methods savePosition and restorePosition
+      now handle the possibility that s2 is null.
+    * In SelectPlan.java, the method distinctValues now works for
+      predicates of the form A=B as well as A=c.
+    * In IndexInfo.java, the method blocksAccessed now uses the size
+      of the index record instead of the size of the data record.
+
+  SimpleDB is distributed in a WinZip-formatted file. This file contains
+  four items:
+
+    * The folder simpledb, which contains the server-side Java code.
+    * The folder javadoc, which contains the JavaDoc documentation 
+      of the above code.
+    * The folder studentClient, which contains some client-side code 
+      for an example database.
+    * This document.
+
+  The author welcomes all comments, including bug reports, suggestions
+  for improvement, and anectodal experiences.  His email address is: 
+  sciore@bc.edu
+  
+
+II. Installation Instructions:
+
+  1)  Install the Java 1.6 or 1.5 SDK. Java 1.6 is obviously preferable.
+
+  2)  If you do install Java 1.5, you need to make some minor changes 
+      to the package simpledb.remote:
+    
+      * The classes named xxxAdapter provide default implementations of 
+        the interfaces in java.sql. Java 1.6 added several extra methods 
+        to these interfaces. If you are using Java 1.5, just comment out 
+        those methods. (You can tell which ones they are because you'll 
+        get an error when you try to compile them.)
+      
+      * The classes named SimpleXXX call the SQLException constructor 
+        with a Throwable argument.  This constructor is new to version
+        1.6. To use in 1.5, rewrite the code "throw new SQLException(e)"
+        to be "throw new SQLException(e.getMessage())".
+
+  3)  Decide where you want the server-side software to go. Let’s assume 
+      that the code will go in the folder C:\javalib in Windows, or the 
+      folder ~/javalib in UNIX or MacOS.
+
+  4)  Add that folder to your classpath. In other words, the javalib 
+      folder must be mentioned in your CLASSPATH environment variable.
+    
+      * In UNIX, your home directory has an initialization file, 
+        typically called .bashrc.  If the file does not set CLASSPATH,
+        add the following line to the file:  
+               CLASSPATH =.:~/javalib     
+               
+        Here, the ‘:’ character separates folder names.  The command 
+        therefore says that the folder "." (i.e., your current diretory) 
+        and "~/javalib" are to be searched whenever Java needs to find a 
+        class.  If the file already contains a CLASSPATH setting, modify 
+        it to include the javalib directory.
+ 
+      * In Windows, you must set the CLASSPATH variable via the System 
+        control panel.  From that control panel, choose the advanced tab 
+        and click on the environment variables button.  You want to have 
+        a user variable named CLASSPATH that looks like this:
+               .;C:\javalib
+               
+        Here, the ‘;’ character separates the two folder names.
+
+  5)  Copy the simpledb folder from the distribution file to that
+      folder. Within the simpledb folder should be subfolders 
+      containing all of the code for SimpleDB.
+
+
+III. Running the Server:
+
+  SimpleDB has a client-server architecture. You run the server code on 
+  a host machine, where it will sit and wait for connections from clients.
+  It is able to handle multiple simultaneous requests from clients, 
+  each on possibly different machines. You can then run a client program
+  from any machine that is able to connect to the host machine.
+
+  To run the SimpleDB server, you need to execute two programs:
+
+  1)  Run the rmiregistry program (which is part of your Java SDK 
+      distribution) as a separate process.  In UNIX, this means executing
+      the command:
+             > rmiregistry & 
+             
+      In Windows, this means executing the command:
+             > start rmiregistry
+
+  2)  Run Java on the simpledb.server.Startup class.  You must pass in
+      the name of a folder that SimpleDB will use to hold the database.
+      For example in Windows, if you execute the command:
+      
+             > start java simpledb.server.Startup studentdb
+             
+      then the server will run in a new window, using studentdb as the
+      database folder.  You can execute this command from any directory;
+      the server will always use the studentdb folder that exists in your
+      home directory.  If a folder with that name does not exist, then
+      one will be created automatically.
+ 
+  If everything is working correctly, when you run the server with a
+  new database folder the following will be printed in the server’s 
+  window:
+
+      creating new database
+      new transaction: 1
+      transaction 1 committed
+      database server ready
+
+  If you run the server with an existing database folder, the following
+  will be printed instead:
+
+      recovering existing database
+      database server ready
+
+  In either case, the server will then sit awaiting connections from
+  clients.  As connections arrive, the server will print additional
+  messages in its window.
+
+
+IV. Running Client Programs 
+
+  The SimpleDB server accepts connections from any JDBC client. The client
+  program makes its connection via the following code:
+            Driver d = new SimpleDriver();
+            String host = "mymachine.com"; //any DNS name or IP address
+            String url = "jdbc:simpledb://" + host;
+            Connection conn = d.connect(url, null);
+
+  Note that SimpleDB does not require a username and password, although
+  it is easy enough to modify the server code to do so.
+
+  The driver class SimpleDriver is contained in the package 
+  simpledb.remote, along with the other classes that it needs. A client
+  program will not run unless this package in its classpath. Note that
+  you could install the entire SimpleDB server code on a client machine,
+  but that is overkill.  All you need is simpledb.remote.
+
+  The studentClient folder contains client code for a simple university
+  student-course database.  The folder contains two subfolders, named 
+  simpledb and derby.  The simpledb subfolder contains programs that 
+  run with the SimpleDB database server. The derby subfolder is not
+  relevant here. (It contains programs for the Derby database server,
+  which can be downloaded from db.apache.org. That code is used to
+  illustrate some examples from my text "Database Design and
+  Implementation", published by John WIley.) 
+
+  The following list briefly describes the SimpleDB clients.
+
+    * CreateStudentDB creates and populates the student database used
+      by the other clients.  It therefore must be the first client run 
+      on a new database. 
+    * StudentMajors prints a table listing the names of students and 
+      their majors.
+    * FindMajors requires a command-line argument denoting the name of 
+      a department.  The program then prints the name and graduation
+      year of all students having that major.
+    * SQLInterpreter repeatedly prints a prompt asking you to enter a 
+      single line of text containing an SQL statement.  The program then 
+      executes that statement.  If the statement is a query, the output 
+      table is displayed.  If the statement is an update command, then
+      the number of affected records is printed.  If the statement is ill
+      formed, and error message will be printed.  SimpleDB understands 
+      only a limited subset of SQL, which is described below.
+    * ChangeMajor changes the student named Amy to be a drama major.  
+      It is the only client that updates the database (although you can 
+      use SQLInterpreter to run update commands).
+
+  These clients connect to the server at "localhost".  If the client is  
+  to be run from a different machine than the server, then its source code 
+  must be modified so that localhost is replaced by the domain name (or IP 
+  address) of the server machine. 
+  
+  Unlike the server classes, the client classes are not part of an 
+  explicit package, and thus they need to be run from the directory that
+  they are stored in. For example, suppose we copy the studentClient 
+  folder from the distribution file to our home directory.  In Windows
+  we could execute the client programs as follows:
+
+             > cd C:\studentClient\simpledb
+             > java CreateStudentDB
+
+
+
+V. SimpleDB Limitations
+
+  SimpleDB is a teaching tool. It deliberately implements a tiny subset
+  of SQL and JDBC, and (for simplicity) imposes restrictions not present
+  in the SQL standard.  Here we briefly indicate these restrictions.
+
+
+  SimpleDB SQL
+  
+  A query in SimpleDB consists only of select-from-where clauses in which
+  the select clause contains a list of fieldnames (without the AS 
+  keyword), and the from clause contains a list of tablenames (without
+  range variables).
+ 
+  The where clause is optional.  The only Boolean operator is and.  The
+  only comparison operator is equality.  Unlike standard SQL, there are
+  no other comparison operators, no other Boolean operators, no arithmetic
+  operators or built-in functions, and no parentheses.  Consequently,
+  nested queries, aggregation, and computed values are not supported.
+
+  Views can be created, but a view definition can be at most 100 
+  characters.
+ 
+  Because there are no range variables and no renaming, all field names in
+  a query must be disjoint.  And because there are no group by or order by
+  clauses, grouping and sorting are not supported.  Other restrictions:
+
+    * The "*" abbreviation in the select clause is not supported.
+    * There are no null values.
+    * There are no explicit joins or outer joins in the from clause.
+    * The union and except keywords are not supported.
+    * Insert statements take explicit values only, not queries.
+    * Update statements can have only one assignment in the set clause.
+
+
+  SimpleDB JDBC
+  
+  SimpleDB implements only the following JDBC methods:
+
+   Driver
+
+      public Connection connect(String url, Properties prop);
+      // The method ignores the contents of variable prop.
+
+   Connection
+
+      public Statement createStatement();
+      public void      close();
+
+   Statement
+
+      public ResultSet executeQuery(String qry);
+      public int       executeUpdate(String cmd);
+
+   ResultSet
+
+      public boolean   next();
+      public int       getInt();
+      public String    getString();
+      public void      close();
+      public ResultSetMetaData getMetaData();
+
+   ResultSetMetaData
+
+      public int        getColumnCount();
+      public String     getColumnName(int column);
+      public int        getColumnType(int column);
+      public int getColumnDisplaySize(int column);
+
+
+
+VI. The Organization of the Server Code
+
+  SimpleDB is usable without knowing anything about what the code looks
+  like. However, the entire point of the system is to make the code
+  easy to read and modify.  The basic packages in SimpleDB are structured
+  hierarchically, in the following order:
+
+    * file (Manages OS files as a virtual disk.)
+    * log (Manages the log.)
+    * buffer (Manages a buffer pool of pages in memory that acts as a
+              cache of disk blocks.)
+    * tx (Implements transactions at the page level.  Does locking
+          and logging.)
+    * record (Implements fixed-length records inside of pages.)
+    * metadata (Maintains metadata in the system catalog.)
+    * query (Implements relational algebra operations.  Each operation 
+             has a plan class, used by the planner, and a scan class,
+             used at runtime.)
+    * parse (Implements the parser.)
+    * planner (Implements a naive planner for SQL statements.)
+    * remote (Implements the server using RMI.)
+    * server (The place where the startup and initialization code live. 
+              The class Startup contains the main method.)
+
+  The basic server is exceptionally inefficient.  The following packages
+  enable more efficient query processing:
+
+    * index (Implements static hash and btree indexes, as well as 
+             extensions to the parser and planner to take advantage
+             of them.)
+    * materialize (Implements implementations of the relational 
+                   operators materialize, sort, groupby, and mergejoin.)
+    * multibuffer (Implements modifications to the sort and product 
+                   operators, in order to make optimum use of available
+                   buffers.)
+    * opt (Implements a heuristic query optimizer)
+ 
+   The textbook "Database Design and Implementation" describes these
+   packages in considerably more detail. For further information, go
+   to the URL www.wiley.com/college/sciore
+   
\ No newline at end of file
diff --git a/README.txt.old b/README.txt.old
deleted file mode 100755
index 00ebd03..0000000
--- a/README.txt.old
+++ /dev/null
@@ -1,318 +0,0 @@
-                      THE SIMPLEDB DATABASE SYSTEM
-                  General Information and Instructions
-
-
-This document contains the following sections:
-    * Release Notes
-    * Server Installation
-    * Running the Server
-    * Running Client Programs
-    * SimpleDB Limitations
-    * The Organization of the Server Code
-
-
-I. Release Notes:
-
-  This release of the SimpleDB system is Version 2.9, which was
-  uploaded on August 1, 2011.  This release provides the following
-  bug fixes to Version 2.8:
-
-    * In SortScan.java, the method beforeFirst now sets the variable
-      currentscan to null.
-    * In SortScan.java, the methods savePosition and restorePosition
-      now handle the possibility that s2 is null.
-    * In SelectPlan.java, the method distinctValues now works for
-      predicates of the form A=B as well as A=c.
-    * In IndexInfo.java, the method blocksAccessed now uses the size
-      of the index record instead of the size of the data record.
-
-  SimpleDB is distributed in a WinZip-formatted file. This file contains
-  four items:
-
-    * The folder simpledb, which contains the server-side Java code.
-    * The folder javadoc, which contains the JavaDoc documentation 
-      of the above code.
-    * The folder studentClient, which contains some client-side code 
-      for an example database.
-    * This document.
-
-  The author welcomes all comments, including bug reports, suggestions
-  for improvement, and anectodal experiences.  His email address is: 
-  sciore@bc.edu
-  
-
-II. Installation Instructions:
-
-  1)  Install the Java 1.6 or 1.5 SDK. Java 1.6 is obviously preferable.
-
-  2)  If you do install Java 1.5, you need to make some minor changes 
-      to the package simpledb.remote:
-    
-      * The classes named xxxAdapter provide default implementations of 
-        the interfaces in java.sql. Java 1.6 added several extra methods 
-        to these interfaces. If you are using Java 1.5, just comment out 
-        those methods. (You can tell which ones they are because you'll 
-        get an error when you try to compile them.)
-      
-      * The classes named SimpleXXX call the SQLException constructor 
-        with a Throwable argument.  This constructor is new to version
-        1.6. To use in 1.5, rewrite the code "throw new SQLException(e)"
-        to be "throw new SQLException(e.getMessage())".
-
-  3)  Decide where you want the server-side software to go. Let’s assume 
-      that the code will go in the folder C:\javalib in Windows, or the 
-      folder ~/javalib in UNIX or MacOS.
-
-  4)  Add that folder to your classpath. In other words, the javalib 
-      folder must be mentioned in your CLASSPATH environment variable.
-    
-      * In UNIX, your home directory has an initialization file, 
-        typically called .bashrc.  If the file does not set CLASSPATH,
-        add the following line to the file:  
-               CLASSPATH =.:~/javalib     
-               
-        Here, the ‘:’ character separates folder names.  The command 
-        therefore says that the folder "." (i.e., your current diretory) 
-        and "~/javalib" are to be searched whenever Java needs to find a 
-        class.  If the file already contains a CLASSPATH setting, modify 
-        it to include the javalib directory.
- 
-      * In Windows, you must set the CLASSPATH variable via the System 
-        control panel.  From that control panel, choose the advanced tab 
-        and click on the environment variables button.  You want to have 
-        a user variable named CLASSPATH that looks like this:
-               .;C:\javalib
-               
-        Here, the ‘;’ character separates the two folder names.
-
-  5)  Copy the simpledb folder from the distribution file to that
-      folder. Within the simpledb folder should be subfolders 
-      containing all of the code for SimpleDB.
-
-
-III. Running the Server:
-
-  SimpleDB has a client-server architecture. You run the server code on 
-  a host machine, where it will sit and wait for connections from clients.
-  It is able to handle multiple simultaneous requests from clients, 
-  each on possibly different machines. You can then run a client program
-  from any machine that is able to connect to the host machine.
-
-  To run the SimpleDB server, you need to execute two programs:
-
-  1)  Run the rmiregistry program (which is part of your Java SDK 
-      distribution) as a separate process.  In UNIX, this means executing
-      the command:
-             > rmiregistry & 
-             
-      In Windows, this means executing the command:
-             > start rmiregistry
-
-  2)  Run Java on the simpledb.server.Startup class.  You must pass in
-      the name of a folder that SimpleDB will use to hold the database.
-      For example in Windows, if you execute the command:
-      
-             > start java simpledb.server.Startup studentdb
-             
-      then the server will run in a new window, using studentdb as the
-      database folder.  You can execute this command from any directory;
-      the server will always use the studentdb folder that exists in your
-      home directory.  If a folder with that name does not exist, then
-      one will be created automatically.
- 
-  If everything is working correctly, when you run the server with a
-  new database folder the following will be printed in the server’s 
-  window:
-
-      creating new database
-      new transaction: 1
-      transaction 1 committed
-      database server ready
-
-  If you run the server with an existing database folder, the following
-  will be printed instead:
-
-      recovering existing database
-      database server ready
-
-  In either case, the server will then sit awaiting connections from
-  clients.  As connections arrive, the server will print additional
-  messages in its window.
-
-
-IV. Running Client Programs 
-
-  The SimpleDB server accepts connections from any JDBC client. The client
-  program makes its connection via the following code:
-            Driver d = new SimpleDriver();
-            String host = "mymachine.com"; //any DNS name or IP address
-            String url = "jdbc:simpledb://" + host;
-            Connection conn = d.connect(url, null);
-
-  Note that SimpleDB does not require a username and password, although
-  it is easy enough to modify the server code to do so.
-
-  The driver class SimpleDriver is contained in the package 
-  simpledb.remote, along with the other classes that it needs. A client
-  program will not run unless this package in its classpath. Note that
-  you could install the entire SimpleDB server code on a client machine,
-  but that is overkill.  All you need is simpledb.remote.
-
-  The studentClient folder contains client code for a simple university
-  student-course database.  The folder contains two subfolders, named 
-  simpledb and derby.  The simpledb subfolder contains programs that 
-  run with the SimpleDB database server. The derby subfolder is not
-  relevant here. (It contains programs for the Derby database server,
-  which can be downloaded from db.apache.org. That code is used to
-  illustrate some examples from my text "Database Design and
-  Implementation", published by John WIley.) 
-
-  The following list briefly describes the SimpleDB clients.
-
-    * CreateStudentDB creates and populates the student database used
-      by the other clients.  It therefore must be the first client run 
-      on a new database. 
-    * StudentMajors prints a table listing the names of students and 
-      their majors.
-    * FindMajors requires a command-line argument denoting the name of 
-      a department.  The program then prints the name and graduation
-      year of all students having that major.
-    * SQLInterpreter repeatedly prints a prompt asking you to enter a 
-      single line of text containing an SQL statement.  The program then 
-      executes that statement.  If the statement is a query, the output 
-      table is displayed.  If the statement is an update command, then
-      the number of affected records is printed.  If the statement is ill
-      formed, and error message will be printed.  SimpleDB understands 
-      only a limited subset of SQL, which is described below.
-    * ChangeMajor changes the student named Amy to be a drama major.  
-      It is the only client that updates the database (although you can 
-      use SQLInterpreter to run update commands).
-
-  These clients connect to the server at "localhost".  If the client is  
-  to be run from a different machine than the server, then its source code 
-  must be modified so that localhost is replaced by the domain name (or IP 
-  address) of the server machine. 
-  
-  Unlike the server classes, the client classes are not part of an 
-  explicit package, and thus they need to be run from the directory that
-  they are stored in. For example, suppose we copy the studentClient 
-  folder from the distribution file to our home directory.  In Windows
-  we could execute the client programs as follows:
-
-             > cd C:\studentClient\simpledb
-             > java CreateStudentDB
-
-
-
-V. SimpleDB Limitations
-
-  SimpleDB is a teaching tool. It deliberately implements a tiny subset
-  of SQL and JDBC, and (for simplicity) imposes restrictions not present
-  in the SQL standard.  Here we briefly indicate these restrictions.
-
-
-  SimpleDB SQL
-  
-  A query in SimpleDB consists only of select-from-where clauses in which
-  the select clause contains a list of fieldnames (without the AS 
-  keyword), and the from clause contains a list of tablenames (without
-  range variables).
- 
-  The where clause is optional.  The only Boolean operator is and.  The
-  only comparison operator is equality.  Unlike standard SQL, there are
-  no other comparison operators, no other Boolean operators, no arithmetic
-  operators or built-in functions, and no parentheses.  Consequently,
-  nested queries, aggregation, and computed values are not supported.
-
-  Views can be created, but a view definition can be at most 100 
-  characters.
- 
-  Because there are no range variables and no renaming, all field names in
-  a query must be disjoint.  And because there are no group by or order by
-  clauses, grouping and sorting are not supported.  Other restrictions:
-
-    * The "*" abbreviation in the select clause is not supported.
-    * There are no null values.
-    * There are no explicit joins or outer joins in the from clause.
-    * The union and except keywords are not supported.
-    * Insert statements take explicit values only, not queries.
-    * Update statements can have only one assignment in the set clause.
-
-
-  SimpleDB JDBC
-  
-  SimpleDB implements only the following JDBC methods:
-
-   Driver
-
-      public Connection connect(String url, Properties prop);
-      // The method ignores the contents of variable prop.
-
-   Connection
-
-      public Statement createStatement();
-      public void      close();
-
-   Statement
-
-      public ResultSet executeQuery(String qry);
-      public int       executeUpdate(String cmd);
-
-   ResultSet
-
-      public boolean   next();
-      public int       getInt();
-      public String    getString();
-      public void      close();
-      public ResultSetMetaData getMetaData();
-
-   ResultSetMetaData
-
-      public int        getColumnCount();
-      public String     getColumnName(int column);
-      public int        getColumnType(int column);
-      public int getColumnDisplaySize(int column);
-
-
-
-VI. The Organization of the Server Code
-
-  SimpleDB is usable without knowing anything about what the code looks
-  like. However, the entire point of the system is to make the code
-  easy to read and modify.  The basic packages in SimpleDB are structured
-  hierarchically, in the following order:
-
-    * file (Manages OS files as a virtual disk.)
-    * log (Manages the log.)
-    * buffer (Manages a buffer pool of pages in memory that acts as a
-              cache of disk blocks.)
-    * tx (Implements transactions at the page level.  Does locking
-          and logging.)
-    * record (Implements fixed-length records inside of pages.)
-    * metadata (Maintains metadata in the system catalog.)
-    * query (Implements relational algebra operations.  Each operation 
-             has a plan class, used by the planner, and a scan class,
-             used at runtime.)
-    * parse (Implements the parser.)
-    * planner (Implements a naive planner for SQL statements.)
-    * remote (Implements the server using RMI.)
-    * server (The place where the startup and initialization code live. 
-              The class Startup contains the main method.)
-
-  The basic server is exceptionally inefficient.  The following packages
-  enable more efficient query processing:
-
-    * index (Implements static hash and btree indexes, as well as 
-             extensions to the parser and planner to take advantage
-             of them.)
-    * materialize (Implements implementations of the relational 
-                   operators materialize, sort, groupby, and mergejoin.)
-    * multibuffer (Implements modifications to the sort and product 
-                   operators, in order to make optimum use of available
-                   buffers.)
-    * opt (Implements a heuristic query optimizer)
- 
-   The textbook "Database Design and Implementation" describes these
-   packages in considerably more detail. For further information, go
-   to the URL www.wiley.com/college/sciore
-   
\ No newline at end of file
diff --git a/SimpleDBApplication/.classpath b/SimpleDBApplication/.classpath
deleted file mode 100644
index 4f96fd8..0000000
--- a/SimpleDBApplication/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/SimpleDB"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/SimpleDBApplication/.project b/SimpleDBApplication/.project
deleted file mode 100644
index eeb2c1c..0000000
--- a/SimpleDBApplication/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SimpleDBApplication</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/SimpleDBApplication/.settings/org.eclipse.jdt.core.prefs b/SimpleDBApplication/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 045e8bb..0000000
--- a/SimpleDBApplication/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Mon Jan 30 12:07:53 EST 2012
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.7
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.7
diff --git a/db-derby-10.8.2.2-lib/lib/derby.jar b/db-derby-10.8.2.2-lib/lib/derby.jar
deleted file mode 100644
index b595559..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derby.jar and /dev/null differ
diff --git a/db-derby-10.8.2.2-lib/lib/derby.war b/db-derby-10.8.2.2-lib/lib/derby.war
deleted file mode 100644
index 7910a04..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derby.war and /dev/null differ
diff --git a/db-derby-10.8.2.2-lib/lib/derbyclient.jar b/db-derby-10.8.2.2-lib/lib/derbyclient.jar
deleted file mode 100644
index 8a7cecf..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derbyclient.jar and /dev/null differ
diff --git a/db-derby-10.8.2.2-lib/lib/derbynet.jar b/db-derby-10.8.2.2-lib/lib/derbynet.jar
deleted file mode 100644
index c5ae4bc..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derbynet.jar and /dev/null differ
diff --git a/db-derby-10.8.2.2-lib/lib/derbyrun.jar b/db-derby-10.8.2.2-lib/lib/derbyrun.jar
deleted file mode 100644
index 5c7b474..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derbyrun.jar and /dev/null differ
diff --git a/db-derby-10.8.2.2-lib/lib/derbytools.jar b/db-derby-10.8.2.2-lib/lib/derbytools.jar
deleted file mode 100644
index f6f3f70..0000000
Binary files a/db-derby-10.8.2.2-lib/lib/derbytools.jar and /dev/null differ
diff --git a/simpledb/buffer/BasicBufferMgr.class b/simpledb/buffer/BasicBufferMgr.class
new file mode 100755
index 0000000..2cef7b7
Binary files /dev/null and b/simpledb/buffer/BasicBufferMgr.class differ
diff --git a/simpledb/buffer/BasicBufferMgr.java b/simpledb/buffer/BasicBufferMgr.java
new file mode 100755
index 0000000..131cc97
--- /dev/null
+++ b/simpledb/buffer/BasicBufferMgr.java
@@ -0,0 +1,119 @@
+package simpledb.buffer;
+
+import simpledb.file.*;
+
+/**
+ * Manages the pinning and unpinning of buffers to blocks.
+ * @author Edward Sciore
+ *
+ */
+class BasicBufferMgr {
+   private Buffer[] bufferpool;
+   private int numAvailable;
+   
+   /**
+    * Creates a buffer manager having the specified number 
+    * of buffer slots.
+    * This constructor depends on both the {@link FileMgr} and
+    * {@link simpledb.log.LogMgr LogMgr} objects 
+    * that it gets from the class
+    * {@link simpledb.server.SimpleDB}.
+    * Those objects are created during system initialization.
+    * Thus this constructor cannot be called until 
+    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
+    * is called first.
+    * @param numbuffs the number of buffer slots to allocate
+    */
+   BasicBufferMgr(int numbuffs) {
+      bufferpool = new Buffer[numbuffs];
+      numAvailable = numbuffs;
+      for (int i=0; i<numbuffs; i++)
+         bufferpool[i] = new Buffer();
+   }
+   
+   /**
+    * Flushes the dirty buffers modified by the specified transaction.
+    * @param txnum the transaction's id number
+    */
+   synchronized void flushAll(int txnum) {
+      for (Buffer buff : bufferpool)
+         if (buff.isModifiedBy(txnum))
+         buff.flush();
+   }
+   
+   /**
+    * Pins a buffer to the specified block. 
+    * If there is already a buffer assigned to that block
+    * then that buffer is used;  
+    * otherwise, an unpinned buffer from the pool is chosen.
+    * Returns a null value if there are no available buffers.
+    * @param blk a reference to a disk block
+    * @return the pinned buffer
+    */
+   synchronized Buffer pin(Block blk) {
+      Buffer buff = findExistingBuffer(blk);
+      if (buff == null) {
+         buff = chooseUnpinnedBuffer();
+         if (buff == null)
+            return null;
+         buff.assignToBlock(blk);
+      }
+      if (!buff.isPinned())
+         numAvailable--;
+      buff.pin();
+      return buff;
+   }
+   
+   /**
+    * Allocates a new block in the specified file, and
+    * pins a buffer to it. 
+    * Returns null (without allocating the block) if 
+    * there are no available buffers.
+    * @param filename the name of the file
+    * @param fmtr a pageformatter object, used to format the new block
+    * @return the pinned buffer
+    */
+   synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
+      Buffer buff = chooseUnpinnedBuffer();
+      if (buff == null)
+         return null;
+      buff.assignToNew(filename, fmtr);
+      numAvailable--;
+      buff.pin();
+      return buff;
+   }
+   
+   /**
+    * Unpins the specified buffer.
+    * @param buff the buffer to be unpinned
+    */
+   synchronized void unpin(Buffer buff) {
+      buff.unpin();
+      if (!buff.isPinned())
+         numAvailable++;
+   }
+   
+   /**
+    * Returns the number of available (i.e. unpinned) buffers.
+    * @return the number of available buffers
+    */
+   int available() {
+      return numAvailable;
+   }
+   
+   private Buffer findExistingBuffer(Block blk) {
+      for (Buffer buff : bufferpool) {
+         Block b = buff.block();
+         if (b != null && b.equals(blk))
+            return buff;
+      }
+      return null;
+   }
+   
+   private Buffer chooseUnpinnedBuffer() {
+      for (Buffer buff : bufferpool)
+         if (!buff.isPinned())
+         return buff;
+      return null;
+   }
+}
diff --git a/simpledb/buffer/Buffer.class b/simpledb/buffer/Buffer.class
new file mode 100755
index 0000000..3597254
Binary files /dev/null and b/simpledb/buffer/Buffer.class differ
diff --git a/simpledb/buffer/Buffer.java b/simpledb/buffer/Buffer.java
new file mode 100755
index 0000000..49b086f
--- /dev/null
+++ b/simpledb/buffer/Buffer.java
@@ -0,0 +1,190 @@
+package simpledb.buffer;
+
+import simpledb.server.SimpleDB;
+import simpledb.file.*;
+
+/**
+ * An individual buffer.
+ * A buffer wraps a page and stores information about its status,
+ * such as the disk block associated with the page,
+ * the number of times the block has been pinned,
+ * whether the contents of the page have been modified,
+ * and if so, the id of the modifying transaction and
+ * the LSN of the corresponding log record.
+ * @author Edward Sciore
+ */
+public class Buffer {
+   private Page contents = new Page();
+   private Block blk = null;
+   private int pins = 0;
+   private int modifiedBy = -1;  // negative means not modified
+   private int logSequenceNumber = -1; // negative means no corresponding log record
+
+   /**
+    * Creates a new buffer, wrapping a new 
+    * {@link simpledb.file.Page page}.  
+    * This constructor is called exclusively by the 
+    * class {@link BasicBufferMgr}.   
+    * It depends on  the 
+    * {@link simpledb.log.LogMgr LogMgr} object 
+    * that it gets from the class
+    * {@link simpledb.server.SimpleDB}.
+    * That object is created during system initialization.
+    * Thus this constructor cannot be called until 
+    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
+    * is called first.
+    */
+   public Buffer() {}
+   
+   /**
+    * Returns the integer value at the specified offset of the
+    * buffer's page.
+    * If an integer was not stored at that location,
+    * the behavior of the method is unpredictable.
+    * @param offset the byte offset of the page
+    * @return the integer value at that offset
+    */
+   public int getInt(int offset) {
+      return contents.getInt(offset);
+   }
+
+   /**
+    * Returns the string value at the specified offset of the
+    * buffer's page.
+    * If a string was not stored at that location,
+    * the behavior of the method is unpredictable.
+    * @param offset the byte offset of the page
+    * @return the string value at that offset
+    */
+   public String getString(int offset) {
+      return contents.getString(offset);
+   }
+
+   /**
+    * Writes an integer to the specified offset of the
+    * buffer's page.
+    * This method assumes that the transaction has already
+    * written an appropriate log record.
+    * The buffer saves the id of the transaction
+    * and the LSN of the log record.
+    * A negative lsn value indicates that a log record
+    * was not necessary.
+    * @param offset the byte offset within the page
+    * @param val the new integer value to be written
+    * @param txnum the id of the transaction performing the modification
+    * @param lsn the LSN of the corresponding log record
+    */
+   public void setInt(int offset, int val, int txnum, int lsn) {
+      modifiedBy = txnum;
+      if (lsn >= 0)
+	      logSequenceNumber = lsn;
+      contents.setInt(offset, val);
+   }
+
+   /**
+    * Writes a string to the specified offset of the
+    * buffer's page.
+    * This method assumes that the transaction has already
+    * written an appropriate log record.
+    * A negative lsn value indicates that a log record
+    * was not necessary.
+    * The buffer saves the id of the transaction
+    * and the LSN of the log record.
+    * @param offset the byte offset within the page
+    * @param val the new string value to be written
+    * @param txnum the id of the transaction performing the modification
+    * @param lsn the LSN of the corresponding log record
+    */
+   public void setString(int offset, String val, int txnum, int lsn) {
+      modifiedBy = txnum;
+      if (lsn >= 0)
+	      logSequenceNumber = lsn;
+      contents.setString(offset, val);
+   }
+
+   /**
+    * Returns a reference to the disk block
+    * that the buffer is pinned to.
+    * @return a reference to a disk block
+    */
+   public Block block() {
+      return blk;
+   }
+
+   /**
+    * Writes the page to its disk block if the
+    * page is dirty.
+    * The method ensures that the corresponding log
+    * record has been written to disk prior to writing
+    * the page to disk.
+    */
+   void flush() {
+      if (modifiedBy >= 0) {
+         SimpleDB.logMgr().flush(logSequenceNumber);
+         contents.write(blk);
+         modifiedBy = -1;
+      }
+   }
+
+   /**
+    * Increases the buffer's pin count.
+    */
+   void pin() {
+      pins++;
+   }
+
+   /**
+    * Decreases the buffer's pin count.
+    */
+   void unpin() {
+      pins--;
+   }
+
+   /**
+    * Returns true if the buffer is currently pinned
+    * (that is, if it has a nonzero pin count).
+    * @return true if the buffer is pinned
+    */
+   boolean isPinned() {
+      return pins > 0;
+   }
+
+   /**
+    * Returns true if the buffer is dirty
+    * due to a modification by the specified transaction.
+    * @param txnum the id of the transaction
+    * @return true if the transaction modified the buffer
+    */
+   boolean isModifiedBy(int txnum) {
+      return txnum == modifiedBy;
+   }
+
+   /**
+    * Reads the contents of the specified block into
+    * the buffer's page.
+    * If the buffer was dirty, then the contents
+    * of the previous page are first written to disk.
+    * @param b a reference to the data block
+    */
+   void assignToBlock(Block b) {
+      flush();
+      blk = b;
+      contents.read(blk);
+      pins = 0;
+   }
+
+   /**
+    * Initializes the buffer's page according to the specified formatter,
+    * and appends the page to the specified file.
+    * If the buffer was dirty, then the contents
+    * of the previous page are first written to disk.
+    * @param filename the name of the file
+    * @param fmtr a page formatter, used to initialize the page
+    */
+   void assignToNew(String filename, PageFormatter fmtr) {
+      flush();
+      fmtr.format(contents);
+      blk = contents.append(filename);
+      pins = 0;
+   }
+}
\ No newline at end of file
diff --git a/simpledb/buffer/BufferAbortException.class b/simpledb/buffer/BufferAbortException.class
new file mode 100755
index 0000000..c559dd0
Binary files /dev/null and b/simpledb/buffer/BufferAbortException.class differ
diff --git a/simpledb/buffer/BufferAbortException.java b/simpledb/buffer/BufferAbortException.java
new file mode 100755
index 0000000..e983522
--- /dev/null
+++ b/simpledb/buffer/BufferAbortException.java
@@ -0,0 +1,9 @@
+package simpledb.buffer;
+
+/**
+ * A runtime exception indicating that the transaction
+ * needs to abort because a buffer request could not be satisfied.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+public class BufferAbortException extends RuntimeException {}
diff --git a/simpledb/buffer/BufferMgr.class b/simpledb/buffer/BufferMgr.class
new file mode 100755
index 0000000..d49c69f
Binary files /dev/null and b/simpledb/buffer/BufferMgr.class differ
diff --git a/simpledb/buffer/BufferMgr.java b/simpledb/buffer/BufferMgr.java
new file mode 100755
index 0000000..8140884
--- /dev/null
+++ b/simpledb/buffer/BufferMgr.java
@@ -0,0 +1,124 @@
+package simpledb.buffer;
+
+import simpledb.file.*;
+
+/**
+ * The publicly-accessible buffer manager.
+ * A buffer manager wraps a basic buffer manager, and
+ * provides the same methods. The difference is that
+ * the methods {@link #pin(Block) pin} and 
+ * {@link #pinNew(String, PageFormatter) pinNew}
+ * will never return null.
+ * If no buffers are currently available, then the
+ * calling thread will be placed on a waiting list.
+ * The waiting threads are removed from the list when 
+ * a buffer becomes available.
+ * If a thread has been waiting for a buffer for an
+ * excessive amount of time (currently, 10 seconds)
+ * then a {@link BufferAbortException} is thrown.
+ * @author Edward Sciore
+ */
+public class BufferMgr {
+   private static final long MAX_TIME = 10000; // 10 seconds
+   private BasicBufferMgr bufferMgr;
+   
+   /**
+    * Creates a new buffer manager having the specified 
+    * number of buffers.
+    * This constructor depends on both the {@link FileMgr} and
+    * {@link simpledb.log.LogMgr LogMgr} objects 
+    * that it gets from the class
+    * {@link simpledb.server.SimpleDB}.
+    * Those objects are created during system initialization.
+    * Thus this constructor cannot be called until 
+    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
+    * is called first.
+    * @param numbuffers the number of buffer slots to allocate
+    */
+   public BufferMgr(int numbuffers) {
+      bufferMgr = new BasicBufferMgr(numbuffers);
+   }
+   
+   /**
+    * Pins a buffer to the specified block, potentially
+    * waiting until a buffer becomes available.
+    * If no buffer becomes available within a fixed 
+    * time period, then a {@link BufferAbortException} is thrown.
+    * @param blk a reference to a disk block
+    * @return the buffer pinned to that block
+    */
+   public synchronized Buffer pin(Block blk) {
+      try {
+         long timestamp = System.currentTimeMillis();
+         Buffer buff = bufferMgr.pin(blk);
+         while (buff == null && !waitingTooLong(timestamp)) {
+            wait(MAX_TIME);
+            buff = bufferMgr.pin(blk);
+         }
+         if (buff == null)
+            throw new BufferAbortException();
+         return buff;
+      }
+      catch(InterruptedException e) {
+         throw new BufferAbortException();
+      }
+   }
+   
+   /**
+    * Pins a buffer to a new block in the specified file, 
+    * potentially waiting until a buffer becomes available.
+    * If no buffer becomes available within a fixed 
+    * time period, then a {@link BufferAbortException} is thrown.
+    * @param filename the name of the file
+    * @param fmtr the formatter used to initialize the page
+    * @return the buffer pinned to that block
+    */
+   public synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
+      try {
+         long timestamp = System.currentTimeMillis();
+         Buffer buff = bufferMgr.pinNew(filename, fmtr);
+         while (buff == null && !waitingTooLong(timestamp)) {
+            wait(MAX_TIME);
+            buff = bufferMgr.pinNew(filename, fmtr);
+         }
+         if (buff == null)
+            throw new BufferAbortException();
+         return buff;
+      }
+      catch(InterruptedException e) {
+         throw new BufferAbortException();
+      }
+   }
+   
+   /**
+    * Unpins the specified buffer. 
+    * If the buffer's pin count becomes 0,
+    * then the threads on the wait list are notified.
+    * @param buff the buffer to be unpinned
+    */
+   public synchronized void unpin(Buffer buff) {
+      bufferMgr.unpin(buff);
+      if (!buff.isPinned())
+         notifyAll();
+   }
+   
+   /**
+    * Flushes the dirty buffers modified by the specified transaction.
+    * @param txnum the transaction's id number
+    */
+   public void flushAll(int txnum) {
+      bufferMgr.flushAll(txnum);
+   }
+   
+   /**
+    * Returns the number of available (ie unpinned) buffers.
+    * @return the number of available buffers
+    */
+   public int available() {
+      return bufferMgr.available();
+   }
+   
+   private boolean waitingTooLong(long starttime) {
+      return System.currentTimeMillis() - starttime > MAX_TIME;
+   }
+}
diff --git a/simpledb/buffer/PageFormatter.class b/simpledb/buffer/PageFormatter.class
new file mode 100755
index 0000000..44d94e9
Binary files /dev/null and b/simpledb/buffer/PageFormatter.class differ
diff --git a/simpledb/buffer/PageFormatter.java b/simpledb/buffer/PageFormatter.java
new file mode 100755
index 0000000..2041d17
--- /dev/null
+++ b/simpledb/buffer/PageFormatter.java
@@ -0,0 +1,20 @@
+package simpledb.buffer;
+
+import simpledb.file.Page;
+
+/**
+ * An interface used to initialize a new block on disk.
+ * There will be an implementing class for each "type" of
+ * disk block.
+ * @author Edward Sciore
+ */
+public interface PageFormatter {
+   /**
+    * Initializes a page, whose contents will be
+    * written to a new disk block.
+    * This method is called only during the method
+    * {@link Buffer#assignToNew}.
+    * @param p a buffer page
+    */
+   public void format(Page p);
+}
diff --git a/simpledb/file/Block.class b/simpledb/file/Block.class
new file mode 100755
index 0000000..33babac
Binary files /dev/null and b/simpledb/file/Block.class differ
diff --git a/simpledb/file/Block.java b/simpledb/file/Block.java
new file mode 100755
index 0000000..9aa71e0
--- /dev/null
+++ b/simpledb/file/Block.java
@@ -0,0 +1,53 @@
+package simpledb.file;
+
+/**
+ * A reference to a disk block.
+ * A Block object consists of a filename and a block number.
+ * It does not hold the contents of the block;
+ * instead, that is the job of a {@link Page} object.
+ * @author Edward Sciore
+ */
+public class Block {
+   private String filename;
+   private int blknum;
+   
+   /**
+    * Constructs a block reference 
+    * for the specified filename and block number.
+    * @param filename the name of the file
+    * @param blknum the block number
+    */
+   public Block(String filename, int blknum) {
+      this.filename = filename;
+      this.blknum   = blknum;
+   }
+   
+   /**
+    * Returns the name of the file where the block lives.
+    * @return the filename
+    */
+   public String fileName() {
+      return filename;
+   }
+   
+   /**
+    * Returns the location of the block within the file.
+    * @return the block number
+    */
+   public int number() {
+      return blknum;
+   }
+   
+   public boolean equals(Object obj) {
+      Block blk = (Block) obj;
+      return filename.equals(blk.filename) && blknum == blk.blknum;
+   }
+   
+   public String toString() {
+      return "[file " + filename + ", block " + blknum + "]";
+   }
+   
+   public int hashCode() {
+      return toString().hashCode();
+   }
+}
diff --git a/simpledb/file/FileMgr.class b/simpledb/file/FileMgr.class
new file mode 100755
index 0000000..01e5103
Binary files /dev/null and b/simpledb/file/FileMgr.class differ
diff --git a/simpledb/file/FileMgr.java b/simpledb/file/FileMgr.java
new file mode 100755
index 0000000..0ba7b70
--- /dev/null
+++ b/simpledb/file/FileMgr.java
@@ -0,0 +1,142 @@
+package simpledb.file;
+
+import static simpledb.file.Page.BLOCK_SIZE;
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.*;
+
+/**
+ * The SimpleDB file manager.
+ * The database system stores its data as files within a specified directory.
+ * The file manager provides methods for reading the contents of
+ * a file block to a Java byte buffer,
+ * writing the contents of a byte buffer to a file block,
+ * and appending the contents of a byte buffer to the end of a file.
+ * These methods are called exclusively by the class {@link simpledb.file.Page Page},
+ * and are thus package-private.
+ * The class also contains two public methods:
+ * Method {@link #isNew() isNew} is called during system initialization by {@link simpledb.server.SimpleDB#init}.
+ * Method {@link #size(String) size} is called by the log manager and transaction manager to
+ * determine the end of the file.
+ * @author Edward Sciore
+ */
+public class FileMgr {
+   private File dbDirectory;
+   private boolean isNew;
+   private Map<String,FileChannel> openFiles = new HashMap<String,FileChannel>();
+
+   /**
+    * Creates a file manager for the specified database.
+    * The database will be stored in a folder of that name
+    * in the user's home directory.
+    * If the folder does not exist, then a folder containing
+    * an empty database is created automatically.
+    * Files for all temporary tables (i.e. tables beginning with "temp") are deleted.
+    * @param dbname the name of the directory that holds the database
+    */
+   public FileMgr(String dbname) {
+      String homedir = System.getProperty("user.home");
+      dbDirectory = new File(homedir, dbname);
+      isNew = !dbDirectory.exists();
+
+      // create the directory if the database is new
+      if (isNew && !dbDirectory.mkdir())
+         throw new RuntimeException("cannot create " + dbname);
+
+      // remove any leftover temporary tables
+      for (String filename : dbDirectory.list())
+         if (filename.startsWith("temp"))
+         new File(dbDirectory, filename).delete();
+   }
+
+   /**
+    * Reads the contents of a disk block into a bytebuffer.
+    * @param blk a reference to a disk block
+    * @param bb  the bytebuffer
+    */
+   synchronized void read(Block blk, ByteBuffer bb) {
+      try {
+         bb.clear();
+         FileChannel fc = getFile(blk.fileName());
+         fc.read(bb, blk.number() * BLOCK_SIZE);
+      }
+      catch (IOException e) {
+         throw new RuntimeException("cannot read block " + blk);
+      }
+   }
+
+   /**
+    * Writes the contents of a bytebuffer into a disk block.
+    * @param blk a reference to a disk block
+    * @param bb  the bytebuffer
+    */
+   synchronized void write(Block blk, ByteBuffer bb) {
+      try {
+         bb.rewind();
+         FileChannel fc = getFile(blk.fileName());
+         fc.write(bb, blk.number() * BLOCK_SIZE);
+      }
+      catch (IOException e) {
+         throw new RuntimeException("cannot write block" + blk);
+      }
+   }
+
+   /**
+    * Appends the contents of a bytebuffer to the end
+    * of the specified file.
+    * @param filename the name of the file
+    * @param bb  the bytebuffer
+    * @return a reference to the newly-created block.
+    */
+   synchronized Block append(String filename, ByteBuffer bb) {
+      int newblknum = size(filename);
+      Block blk = new Block(filename, newblknum);
+      write(blk, bb);
+      return blk;
+   }
+
+   /**
+    * Returns the number of blocks in the specified file.
+    * @param filename the name of the file
+    * @return the number of blocks in the file
+    */
+   public synchronized int size(String filename) {
+      try {
+         FileChannel fc = getFile(filename);
+         return (int)(fc.size() / BLOCK_SIZE);
+      }
+      catch (IOException e) {
+         throw new RuntimeException("cannot access " + filename);
+      }
+   }
+
+   /**
+    * Returns a boolean indicating whether the file manager
+    * had to create a new database directory.
+    * @return true if the database is new
+    */
+   public boolean isNew() {
+      return isNew;
+   }
+
+   /**
+    * Returns the file channel for the specified filename.
+    * The file channel is stored in a map keyed on the filename.
+    * If the file is not open, then it is opened and the file channel
+    * is added to the map.
+    * @param filename the specified filename
+    * @return the file channel associated with the open file.
+    * @throws IOException
+    */
+   private FileChannel getFile(String filename) throws IOException {
+      FileChannel fc = openFiles.get(filename);
+      if (fc == null) {
+         File dbTable = new File(dbDirectory, filename);
+         RandomAccessFile f = new RandomAccessFile(dbTable, "rws");
+         fc = f.getChannel();
+         openFiles.put(filename, fc);
+      }
+      return fc;
+   }
+}
diff --git a/simpledb/file/Page.class b/simpledb/file/Page.class
new file mode 100755
index 0000000..472e9b4
Binary files /dev/null and b/simpledb/file/Page.class differ
diff --git a/simpledb/file/Page.java b/simpledb/file/Page.java
new file mode 100755
index 0000000..f8eb525
--- /dev/null
+++ b/simpledb/file/Page.java
@@ -0,0 +1,159 @@
+package simpledb.file;
+
+import simpledb.server.SimpleDB;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+
+/**
+ * The contents of a disk block in memory.
+ * A page is treated as an array of BLOCK_SIZE bytes.
+ * There are methods to get/set values into this array,
+ * and to read/write the contents of this array to a disk block.
+ * 
+ * For an example of how to use Page and 
+ * {@link Block} objects, 
+ * consider the following code fragment.  
+ * The first portion increments the integer at offset 792 of block 6 of file junk.  
+ * The second portion stores the string "hello" at offset 20 of a page, 
+ * and then appends it to a new block of the file.  
+ * It then reads that block into another page 
+ * and extracts the value "hello" into variable s.
+ * <pre>
+ * Page p1 = new Page();
+ * Block blk = new Block("junk", 6);
+ * p1.read(blk);
+ * int n = p1.getInt(792);
+ * p1.setInt(792, n+1);
+ * p1.write(blk);
+ *
+ * Page p2 = new Page();
+ * p2.setString(20, "hello");
+ * blk = p2.append("junk");
+ * Page p3 = new Page();
+ * p3.read(blk);
+ * String s = p3.getString(20);
+ * </pre>
+ * @author Edward Sciore
+ */
+public class Page {
+   /**
+    * The number of bytes in a block.
+    * This value is set unreasonably low, so that it is easier
+    * to create and test databases having a lot of blocks.
+    * A more realistic value would be 4K.
+    */
+   public static final int BLOCK_SIZE = 400;
+   
+   /**
+    * The size of an integer in bytes.
+    * This value is almost certainly 4, but it is
+    * a good idea to encode this value as a constant. 
+    */
+   public static final int INT_SIZE = Integer.SIZE / Byte.SIZE;
+   
+   /**
+    * The maximum size, in bytes, of a string of length n.
+    * A string is represented as the encoding of its characters,
+    * preceded by an integer denoting the number of bytes in this encoding.
+    * If the JVM uses the US-ASCII encoding, then each char
+    * is stored in one byte, so a string of n characters
+    * has a size of 4+n bytes.
+    * @param n the size of the string
+    * @return the maximum number of bytes required to store a string of size n
+    */
+   public static final int STR_SIZE(int n) {
+      float bytesPerChar = Charset.defaultCharset().newEncoder().maxBytesPerChar();
+      return INT_SIZE + (n * (int)bytesPerChar);
+   }
+   
+   private ByteBuffer contents = ByteBuffer.allocateDirect(BLOCK_SIZE);
+   private FileMgr filemgr = SimpleDB.fileMgr();
+   
+   /**
+    * Creates a new page.  Although the constructor takes no arguments,
+    * it depends on a {@link FileMgr} object that it gets from the
+    * method {@link simpledb.server.SimpleDB#fileMgr()}.
+    * That object is created during system initialization.
+    * Thus this constructor cannot be called until either
+    * {@link simpledb.server.SimpleDB#init(String)} or
+    * {@link simpledb.server.SimpleDB#initFileMgr(String)} or
+    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
+    * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)}
+    * is called first.
+    */
+   public Page() {}
+   
+   /**
+    * Populates the page with the contents of the specified disk block. 
+    * @param blk a reference to a disk block
+    */
+   public synchronized void read(Block blk) {
+      filemgr.read(blk, contents);
+   }
+   
+   /**
+    * Writes the contents of the page to the specified disk block.
+    * @param blk a reference to a disk block
+    */
+   public synchronized void write(Block blk) {
+      filemgr.write(blk, contents);
+   }
+   
+   /**
+    * Appends the contents of the page to the specified file.
+    * @param filename the name of the file
+    * @return the reference to the newly-created disk block
+    */
+   public synchronized Block append(String filename) {
+      return filemgr.append(filename, contents);
+   }
+   
+   /**
+    * Returns the integer value at a specified offset of the page.
+    * If an integer was not stored at that location, 
+    * the behavior of the method is unpredictable.
+    * @param offset the byte offset within the page
+    * @return the integer value at that offset
+    */
+   public synchronized int getInt(int offset) {
+      contents.position(offset);
+      return contents.getInt();
+   }
+   
+   /**
+    * Writes an integer to the specified offset on the page.
+    * @param offset the byte offset within the page
+    * @param val the integer to be written to the page
+    */
+   public synchronized void setInt(int offset, int val) {
+      contents.position(offset);
+      contents.putInt(val);
+   }
+   
+   /**
+    * Returns the string value at the specified offset of the page.
+    * If a string was not stored at that location,
+    * the behavior of the method is unpredictable.
+    * @param offset the byte offset within the page
+    * @return the string value at that offset
+    */
+   public synchronized String getString(int offset) {
+      contents.position(offset);
+      int len = contents.getInt();
+      byte[] byteval = new byte[len];
+      contents.get(byteval);
+      return new String(byteval);
+   }
+   
+   /**
+    * Writes a string to the specified offset on the page.
+    * @param offset the byte offset within the page
+    * @param val the string to be written to the page
+    */
+   public synchronized void setString(int offset, String val) {
+      contents.position(offset);
+      byte[] byteval = val.getBytes();
+      contents.putInt(byteval.length);
+      contents.put(byteval);
+   }
+}
diff --git a/simpledb/index/Index.class b/simpledb/index/Index.class
new file mode 100755
index 0000000..c6f6b63
Binary files /dev/null and b/simpledb/index/Index.class differ
diff --git a/simpledb/index/Index.java b/simpledb/index/Index.java
new file mode 100755
index 0000000..07d27c1
--- /dev/null
+++ b/simpledb/index/Index.java
@@ -0,0 +1,54 @@
+package simpledb.index;
+
+import simpledb.record.RID;
+import simpledb.query.Constant;
+
+/**
+ * This interface contains methods to traverse an index.
+ * @author Edward Sciore
+ *
+ */
+public interface Index {
+   
+   /**
+    * Positions the index before the first record
+    * having the specified search key.
+    * @param searchkey the search key value.
+    */
+   public void    beforeFirst(Constant searchkey);
+   
+   /**
+    * Moves the index to the next record having the
+    * search key specified in the beforeFirst method. 
+    * Returns false if there are no more such index records.
+    * @return false if no other index records have the search key.
+    */
+   public boolean next();
+   
+   /**
+    * Returns the dataRID value stored in the current index record. 
+    * @return the dataRID stored in the current index record.
+    */
+   public RID     getDataRid();
+   
+   /**
+    * Inserts an index record having the specified
+    * dataval and dataRID values.
+    * @param dataval the dataval in the new index record.
+    * @param datarid the dataRID in the new index record.
+    */
+   public void    insert(Constant dataval, RID datarid);
+   
+   /**
+    * Deletes the index record having the specified
+    * dataval and dataRID values.
+    * @param dataval the dataval of the deleted index record
+    * @param datarid the dataRID of the deleted index record
+    */
+   public void    delete(Constant dataval, RID datarid);
+   
+   /**
+    * Closes the index.
+    */
+   public void    close();
+}
diff --git a/simpledb/index/btree/BTPageFormatter.class b/simpledb/index/btree/BTPageFormatter.class
new file mode 100755
index 0000000..c3b2e77
Binary files /dev/null and b/simpledb/index/btree/BTPageFormatter.class differ
diff --git a/simpledb/index/btree/BTPageFormatter.java b/simpledb/index/btree/BTPageFormatter.java
new file mode 100755
index 0000000..bf4fb2f
--- /dev/null
+++ b/simpledb/index/btree/BTPageFormatter.java
@@ -0,0 +1,55 @@
+package simpledb.index.btree;
+
+import static simpledb.file.Page.*;
+import static java.sql.Types.INTEGER;
+import simpledb.file.Page;
+import simpledb.buffer.PageFormatter;
+import simpledb.record.TableInfo;
+
+/**
+ * An object that can format a page to look like an
+ * empty B-tree block.
+ * @author Edward Sciore
+ */
+public class BTPageFormatter implements PageFormatter {
+   private TableInfo ti;
+   private int flag;
+   
+   /**
+    * Creates a formatter for a new page of the
+    * specified B-tree index.
+    * @param ti the index's metadata
+    * @param flag the page's initial flag value
+    */
+   public BTPageFormatter(TableInfo ti, int flag) {
+      this.ti = ti;
+      this.flag = flag;
+   }
+   
+   /** 
+    * Formats the page by initializing as many index-record slots
+    * as possible to have default values.
+    * Each integer field is given a value of 0, and
+    * each string field is given a value of "".
+    * The location that indicates the number of records
+    * in the page is also set to 0.
+    * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
+    */
+   public void format(Page page) {
+      page.setInt(0, flag);
+      page.setInt(INT_SIZE, 0);  // #records = 0
+      int recsize = ti.recordLength();
+      for (int pos=2*INT_SIZE; pos+recsize<=BLOCK_SIZE; pos += recsize)
+         makeDefaultRecord(page, pos);
+   }
+   
+   private void makeDefaultRecord(Page page, int pos) {
+      for (String fldname : ti.schema().fields()) {
+         int offset = ti.offset(fldname);
+         if (ti.schema().type(fldname) == INTEGER)
+            page.setInt(pos + offset, 0);
+         else
+            page.setString(pos + offset, "");
+      }
+   }
+}
diff --git a/simpledb/index/btree/BTreeDir.class b/simpledb/index/btree/BTreeDir.class
new file mode 100755
index 0000000..71a16e8
Binary files /dev/null and b/simpledb/index/btree/BTreeDir.class differ
diff --git a/simpledb/index/btree/BTreeDir.java b/simpledb/index/btree/BTreeDir.java
new file mode 100755
index 0000000..3e15606
--- /dev/null
+++ b/simpledb/index/btree/BTreeDir.java
@@ -0,0 +1,117 @@
+package simpledb.index.btree;
+
+import simpledb.file.Block;
+import simpledb.tx.Transaction;
+import simpledb.record.TableInfo;
+import simpledb.query.Constant;
+
+/**
+ * A B-tree directory block.
+ * @author Edward Sciore
+ */
+public class BTreeDir {
+   private TableInfo ti;
+   private Transaction tx;
+   private String filename;
+   private BTreePage contents;
+
+   /**
+    * Creates an object to hold the contents of the specified
+    * B-tree block.
+    * @param blk a reference to the specified B-tree block
+    * @param ti the metadata of the B-tree directory file
+    * @param tx the calling transaction
+    */
+   BTreeDir(Block blk, TableInfo ti, Transaction tx) {
+      this.ti = ti;
+      this.tx = tx;
+      filename = blk.fileName();
+      contents = new BTreePage(blk, ti, tx);
+   }
+
+   /**
+    * Closes the directory page.
+    */
+   public void close() {
+      contents.close();
+   }
+
+   /**
+    * Returns the block number of the B-tree leaf block
+    * that contains the specified search key.
+    * @param searchkey the search key value
+    * @return the block number of the leaf block containing that search key
+    */
+   public int search(Constant searchkey) {
+      Block childblk = findChildBlock(searchkey);
+      while (contents.getFlag() > 0) {
+         contents.close();
+         contents = new BTreePage(childblk, ti, tx);
+         childblk = findChildBlock(searchkey);
+      }
+      return childblk.number();
+   }
+
+   /**
+    * Creates a new root block for the B-tree.
+    * The new root will have two children:
+    * the old root, and the specified block.
+    * Since the root must always be in block 0 of the file,
+    * the contents of the old root will get transferred to a new block.
+    * @param e the directory entry to be added as a child of the new root
+    */
+   public void makeNewRoot(DirEntry e) {
+      Constant firstval = contents.getDataVal(0);
+      int level = contents.getFlag();
+      Block newblk = contents.split(0, level); //ie, transfer all the records
+      DirEntry oldroot = new DirEntry(firstval, newblk.number());
+      insertEntry(oldroot);
+      insertEntry(e);
+      contents.setFlag(level+1);
+   }
+
+   /**
+    * Inserts a new directory entry into the B-tree block.
+    * If the block is at level 0, then the entry is inserted there.
+    * Otherwise, the entry is inserted into the appropriate
+    * child node, and the return value is examined.
+    * A non-null return value indicates that the child node
+    * split, and so the returned entry is inserted into
+    * this block.
+    * If this block splits, then the method similarly returns
+    * the entry information of the new block to its caller;
+    * otherwise, the method returns null.
+    * @param e the directory entry to be inserted
+    * @return the directory entry of the newly-split block, if one exists; otherwise, null
+    */
+   public DirEntry insert(DirEntry e) {
+      if (contents.getFlag() == 0)
+         return insertEntry(e);
+      Block childblk = findChildBlock(e.dataVal());
+      BTreeDir child = new BTreeDir(childblk, ti, tx);
+      DirEntry myentry = child.insert(e);
+      child.close();
+      return (myentry != null) ? insertEntry(myentry) : null;
+   }
+
+   private DirEntry insertEntry(DirEntry e) {
+      int newslot = 1 + contents.findSlotBefore(e.dataVal());
+      contents.insertDir(newslot, e.dataVal(), e.blockNumber());
+      if (!contents.isFull())
+         return null;
+      // else page is full, so split it
+      int level = contents.getFlag();
+      int splitpos = contents.getNumRecs() / 2;
+      Constant splitval = contents.getDataVal(splitpos);
+      Block newblk = contents.split(splitpos, level);
+      return new DirEntry(splitval, newblk.number());
+   }
+
+   private Block findChildBlock(Constant searchkey) {
+      int slot = contents.findSlotBefore(searchkey);
+      if (contents.getDataVal(slot+1).equals(searchkey))
+         slot++;
+      int blknum = contents.getChildNum(slot);
+      return new Block(filename, blknum);
+   }
+}
diff --git a/simpledb/index/btree/BTreeIndex.class b/simpledb/index/btree/BTreeIndex.class
new file mode 100755
index 0000000..850c890
Binary files /dev/null and b/simpledb/index/btree/BTreeIndex.class differ
diff --git a/simpledb/index/btree/BTreeIndex.java b/simpledb/index/btree/BTreeIndex.java
new file mode 100755
index 0000000..f11112f
--- /dev/null
+++ b/simpledb/index/btree/BTreeIndex.java
@@ -0,0 +1,154 @@
+package simpledb.index.btree;
+
+import static java.sql.Types.INTEGER;
+import simpledb.file.Block;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/**
+ * A B-tree implementation of the Index interface.
+ * @author Edward Sciore
+ */
+public class BTreeIndex implements Index {
+   private Transaction tx;
+   private TableInfo dirTi, leafTi;
+   private BTreeLeaf leaf = null;
+   private Block rootblk;
+
+   /**
+    * Opens a B-tree index for the specified index.
+    * The method determines the appropriate files
+    * for the leaf and directory records,
+    * creating them if they did not exist.
+    * @param idxname the name of the index
+    * @param leafsch the schema of the leaf index records
+    * @param tx the calling transaction
+    */
+   public BTreeIndex(String idxname, Schema leafsch, Transaction tx) {
+      this.tx = tx;
+      // deal with the leaves
+      String leaftbl = idxname + "leaf";
+      leafTi = new TableInfo(leaftbl, leafsch);
+      if (tx.size(leafTi.fileName()) == 0)
+         tx.append(leafTi.fileName(), new BTPageFormatter(leafTi, -1));
+
+      // deal with the directory
+      Schema dirsch = new Schema();
+      dirsch.add("block",   leafsch);
+      dirsch.add("dataval", leafsch);
+      String dirtbl = idxname + "dir";
+      dirTi = new TableInfo(dirtbl, dirsch);
+      rootblk = new Block(dirTi.fileName(), 0);
+      if (tx.size(dirTi.fileName()) == 0)
+         // create new root block
+         tx.append(dirTi.fileName(), new BTPageFormatter(dirTi, 0));
+      BTreePage page = new BTreePage(rootblk, dirTi, tx);
+      if (page.getNumRecs() == 0) {
+			// insert initial directory entry
+         int fldtype = dirsch.type("dataval");
+         Constant minval = (fldtype == INTEGER) ?
+            new IntConstant(Integer.MIN_VALUE) :
+            new StringConstant("");
+         page.insertDir(0, minval, 0);
+		}
+      page.close();
+   }
+
+   /**
+    * Traverses the directory to find the leaf block corresponding
+    * to the specified search key.
+    * The method then opens a page for that leaf block, and
+    * positions the page before the first record (if any)
+    * having that search key.
+    * The leaf page is kept open, for use by the methods next
+    * and getDataRid.
+    * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
+    */
+   public void beforeFirst(Constant searchkey) {
+      close();
+      BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
+      int blknum = root.search(searchkey);
+      root.close();
+      Block leafblk = new Block(leafTi.fileName(), blknum);
+      leaf = new BTreeLeaf(leafblk, leafTi, searchkey, tx);
+   }
+
+   /**
+    * Moves to the next leaf record having the
+    * previously-specified search key.
+    * Returns false if there are no more such leaf records.
+    * @see simpledb.index.Index#next()
+    */
+   public boolean next() {
+      return leaf.next();
+   }
+
+   /**
+    * Returns the dataRID value from the current leaf record.
+    * @see simpledb.index.Index#getDataRid()
+    */
+   public RID getDataRid() {
+      return leaf.getDataRid();
+   }
+
+   /**
+    * Inserts the specified record into the index.
+    * The method first traverses the directory to find
+    * the appropriate leaf page; then it inserts
+    * the record into the leaf.
+    * If the insertion causes the leaf to split, then
+    * the method calls insert on the root,
+    * passing it the directory entry of the new leaf page.
+    * If the root node splits, then makeNewRoot is called.
+    * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
+    */
+   public void insert(Constant dataval, RID datarid) {
+      beforeFirst(dataval);
+      DirEntry e = leaf.insert(datarid);
+      leaf.close();
+      if (e == null)
+         return;
+      BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
+      DirEntry e2 = root.insert(e);
+      if (e2 != null)
+         root.makeNewRoot(e2);
+      root.close();
+   }
+
+   /**
+    * Deletes the specified index record.
+    * The method first traverses the directory to find
+    * the leaf page containing that record; then it
+    * deletes the record from the page.
+    * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
+    */
+   public void delete(Constant dataval, RID datarid) {
+      beforeFirst(dataval);
+      leaf.delete(datarid);
+      leaf.close();
+   }
+
+   /**
+    * Closes the index by closing its open leaf page,
+    * if necessary.
+    * @see simpledb.index.Index#close()
+    */
+   public void close() {
+      if (leaf != null)
+         leaf.close();
+   }
+
+   /**
+    * Estimates the number of block accesses
+    * required to find all index records having
+    * a particular search key.
+    * @param numblocks the number of blocks in the B-tree directory
+    * @param rpb the number of index entries per block
+    * @return the estimated traversal cost
+    */
+   public static int searchCost(int numblocks, int rpb) {
+      return 1 + (int)(Math.log(numblocks) / Math.log(rpb));
+   }
+}
diff --git a/simpledb/index/btree/BTreeLeaf.class b/simpledb/index/btree/BTreeLeaf.class
new file mode 100755
index 0000000..aeee0c2
Binary files /dev/null and b/simpledb/index/btree/BTreeLeaf.class differ
diff --git a/simpledb/index/btree/BTreeLeaf.java b/simpledb/index/btree/BTreeLeaf.java
new file mode 100755
index 0000000..5647bfc
--- /dev/null
+++ b/simpledb/index/btree/BTreeLeaf.java
@@ -0,0 +1,136 @@
+package simpledb.index.btree;
+
+import simpledb.file.Block;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.Constant;
+
+/**
+ * An object that holds the contents of a B-tree leaf block.
+ * @author Edward Sciore
+ */
+public class BTreeLeaf {
+   private TableInfo ti;
+   private Transaction tx;
+   private Constant searchkey;
+   private BTreePage contents;
+   private int currentslot;
+   
+   /**
+    * Opens a page to hold the specified leaf block.
+    * The page is positioned immediately before the first record
+    * having the specified search key (if any).
+    * @param blk a reference to the disk block
+    * @param ti the metadata of the B-tree leaf file
+    * @param searchkey the search key value
+    * @param tx the calling transaction
+    */
+   public BTreeLeaf(Block blk, TableInfo ti, Constant searchkey, Transaction tx) {
+      this.ti = ti;
+      this.tx = tx;
+      this.searchkey = searchkey;
+      contents = new BTreePage(blk, ti, tx);
+      currentslot = contents.findSlotBefore(searchkey);
+   }
+   
+   /**
+    * Closes the leaf page.
+    */
+   public void close() {
+      contents.close();
+   }
+   
+   /**
+    * Moves to the next leaf record having the 
+    * previously-specified search key.
+    * Returns false if there is no more such records.
+    * @return false if there are no more leaf records for the search key
+    */
+   public boolean next() {
+      currentslot++;
+      if (currentslot >= contents.getNumRecs()) 
+         return tryOverflow();
+      else if (contents.getDataVal(currentslot).equals(searchkey))
+         return true;
+      else 
+         return tryOverflow();
+   }
+   
+   /**
+    * Returns the dataRID value of the current leaf record.
+    * @return the dataRID of the current record
+    */
+   public RID getDataRid() {
+      return contents.getDataRid(currentslot);
+   }
+   
+   /**
+    * Deletes the leaf record having the specified dataRID
+    * @param datarid the dataRId whose record is to be deleted
+    */
+   public void delete(RID datarid) {
+      while(next())
+         if(getDataRid().equals(datarid)) {
+         contents.delete(currentslot);
+         return;
+      }
+   }
+   
+   /**
+    * Inserts a new leaf record having the specified dataRID
+    * and the previously-specified search key.
+    * If the record does not fit in the page, then 
+    * the page splits and the method returns the
+    * directory entry for the new page;
+    * otherwise, the method returns null.  
+    * If all of the records in the page have the same dataval,
+    * then the block does not split; instead, all but one of the
+    * records are placed into an overflow block.
+    * @param datarid the dataRID value of the new record
+    * @return the directory entry of the newly-split page, if one exists.
+    */
+   public DirEntry insert(RID datarid) {
+      currentslot++;
+      contents.insertLeaf(currentslot, searchkey, datarid);
+      if (!contents.isFull())
+         return null;
+      // else page is full, so split it
+      Constant firstkey = contents.getDataVal(0);
+      Constant lastkey  = contents.getDataVal(contents.getNumRecs()-1);
+      if (lastkey.equals(firstkey)) {
+         // create an overflow block to hold all but the first record
+         Block newblk = contents.split(1, contents.getFlag());
+         contents.setFlag(newblk.number());
+         return null;
+      }
+      else {
+         int splitpos = contents.getNumRecs() / 2;
+         Constant splitkey = contents.getDataVal(splitpos);
+         if (splitkey.equals(firstkey)) {
+            // move right, looking for the next key
+            while (contents.getDataVal(splitpos).equals(splitkey))
+               splitpos++;
+            splitkey = contents.getDataVal(splitpos);
+         }
+         else {
+            // move left, looking for first entry having that key
+            while (contents.getDataVal(splitpos-1).equals(splitkey))
+               splitpos--;
+         }
+         Block newblk = contents.split(splitpos, -1);
+         return new DirEntry(splitkey, newblk.number());
+      }
+   }
+   
+   private boolean tryOverflow() {
+      Constant firstkey = contents.getDataVal(0);
+      int flag = contents.getFlag();
+      if (!searchkey.equals(firstkey) || flag < 0)
+         return false;
+      contents.close();
+      Block nextblk = new Block(ti.fileName(), flag);
+      contents = new BTreePage(nextblk, ti, tx);
+      currentslot = 0;
+      return true;
+   }
+}
diff --git a/simpledb/index/btree/BTreePage.class b/simpledb/index/btree/BTreePage.class
new file mode 100755
index 0000000..6c1956c
Binary files /dev/null and b/simpledb/index/btree/BTreePage.class differ
diff --git a/simpledb/index/btree/BTreePage.java b/simpledb/index/btree/BTreePage.java
new file mode 100755
index 0000000..be7c4e0
--- /dev/null
+++ b/simpledb/index/btree/BTreePage.java
@@ -0,0 +1,261 @@
+package simpledb.index.btree;
+
+import static java.sql.Types.INTEGER;
+import static simpledb.file.Page.*;
+import simpledb.file.Block;
+import simpledb.record.*;
+import simpledb.query.*;
+import simpledb.tx.Transaction;
+
+/**
+ * B-tree directory and leaf pages have many commonalities:
+ * in particular, their records are stored in sorted order, 
+ * and pages split when full.
+ * A BTreePage object contains this common functionality.
+ * @author Edward Sciore
+ */
+public class BTreePage {
+   private Block currentblk;
+   private TableInfo ti;
+   private Transaction tx;
+   private int slotsize;
+   
+   /**
+    * Opens a page for the specified B-tree block.
+    * @param currentblk a reference to the B-tree block
+    * @param ti the metadata for the particular B-tree file
+    * @param tx the calling transaction
+    */
+   public BTreePage(Block currentblk, TableInfo ti, Transaction tx) {
+      this.currentblk = currentblk;
+      this.ti = ti;
+      this.tx = tx;
+      slotsize = ti.recordLength();
+      tx.pin(currentblk);
+   }
+   
+   /**
+    * Calculates the position where the first record having
+    * the specified search key should be, then returns
+    * the position before it.
+    * @param searchkey the search key
+    * @return the position before where the search key goes
+    */
+   public int findSlotBefore(Constant searchkey) {
+      int slot = 0;
+      while (slot < getNumRecs() && getDataVal(slot).compareTo(searchkey) < 0)
+         slot++;
+      return slot-1;
+   }
+   
+   /**
+    * Closes the page by unpinning its buffer.
+    */
+   public void close() {
+      if (currentblk != null)
+         tx.unpin(currentblk);
+      currentblk = null;
+   }
+   
+   /**
+    * Returns true if the block is full.
+    * @return true if the block is full
+    */
+   public boolean isFull() {
+      return slotpos(getNumRecs()+1) >= BLOCK_SIZE;
+   }
+   
+   /**
+    * Splits the page at the specified position.
+    * A new page is created, and the records of the page
+    * starting at the split position are transferred to the new page.
+    * @param splitpos the split position
+    * @param flag the initial value of the flag field
+    * @return the reference to the new block
+    */
+   public Block split(int splitpos, int flag) {
+      Block newblk = appendNew(flag);
+      BTreePage newpage = new BTreePage(newblk, ti, tx);
+      transferRecs(splitpos, newpage);
+      newpage.setFlag(flag);
+      newpage.close();
+      return newblk;
+   }
+   
+   /**
+    * Returns the dataval of the record at the specified slot.
+    * @param slot the integer slot of an index record
+    * @return the dataval of the record at that slot
+    */
+   public Constant getDataVal(int slot) {
+      return getVal(slot, "dataval");
+   }
+   
+   /**
+    * Returns the value of the page's flag field
+    * @return the value of the page's flag field
+    */
+   public int getFlag() {
+      return tx.getInt(currentblk, 0);
+   }
+   
+   /**
+    * Sets the page's flag field to the specified value
+    * @param val the new value of the page flag
+    */
+   public void setFlag(int val) {
+      tx.setInt(currentblk, 0, val);
+   }
+   
+   /**
+    * Appends a new block to the end of the specified B-tree file,
+    * having the specified flag value.
+    * @param flag the initial value of the flag
+    * @return a reference to the newly-created block
+    */
+   public Block appendNew(int flag) {
+      return tx.append(ti.fileName(), new BTPageFormatter(ti, flag));
+   }
+   
+   // Methods called only by BTreeDir
+   
+   /**
+    * Returns the block number stored in the index record 
+    * at the specified slot.
+    * @param slot the slot of an index record
+    * @return the block number stored in that record
+    */
+   public int getChildNum(int slot) {
+      return getInt(slot, "block");
+   }
+   
+   /**
+    * Inserts a directory entry at the specified slot.
+    * @param slot the slot of an index record
+    * @param val the dataval to be stored
+    * @param blknum the block number to be stored
+    */
+   public void insertDir(int slot, Constant val, int blknum) {
+      insert(slot);
+      setVal(slot, "dataval", val);
+      setInt(slot, "block", blknum);
+   }
+   
+   // Methods called only by BTreeLeaf
+   
+   /**
+    * Returns the dataRID value stored in the specified leaf index record.
+    * @param slot the slot of the desired index record
+    * @return the dataRID value store at that slot
+    */
+   public RID getDataRid(int slot) {
+      return new RID(getInt(slot, "block"), getInt(slot, "id"));
+   }
+   
+   /**
+    * Inserts a leaf index record at the specified slot.
+    * @param slot the slot of the desired index record
+    * @param val the new dataval
+    * @param rid the new dataRID
+    */
+   public void insertLeaf(int slot, Constant val, RID rid) {
+      insert(slot);
+      setVal(slot, "dataval", val);
+      setInt(slot, "block", rid.blockNumber());
+      setInt(slot, "id", rid.id());
+   }
+   
+   /**
+    * Deletes the index record at the specified slot.
+    * @param slot the slot of the deleted index record
+    */
+   public void delete(int slot) {
+      for (int i=slot+1; i<getNumRecs(); i++)
+         copyRecord(i, i-1);
+      setNumRecs(getNumRecs()-1);
+      return;
+   }
+   
+   /**
+    * Returns the number of index records in this page.
+    * @return the number of index records in this page
+    */
+   public int getNumRecs() {
+      return tx.getInt(currentblk, INT_SIZE);
+   }
+   
+   // Private methods
+   
+   private int getInt(int slot, String fldname) {
+      int pos = fldpos(slot, fldname);
+      return tx.getInt(currentblk, pos);
+   }
+   
+   private String getString(int slot, String fldname) {
+      int pos = fldpos(slot, fldname);
+      return tx.getString(currentblk, pos);
+   }
+   
+   private Constant getVal(int slot, String fldname) {
+      int type = ti.schema().type(fldname);
+      if (type == INTEGER)
+         return new IntConstant(getInt(slot, fldname));
+      else
+         return new StringConstant(getString(slot, fldname));
+   }
+   
+   private void setInt(int slot, String fldname, int val) {
+      int pos = fldpos(slot, fldname);
+      tx.setInt(currentblk, pos, val);
+   }
+   
+   private void setString(int slot, String fldname, String val) {
+      int pos = fldpos(slot, fldname);
+      tx.setString(currentblk, pos, val);
+   }
+   
+   private void setVal(int slot, String fldname, Constant val) {
+      int type = ti.schema().type(fldname);
+      if (type == INTEGER)
+         setInt(slot, fldname, (Integer)val.asJavaVal());
+      else
+         setString(slot, fldname, (String)val.asJavaVal());
+   }
+   
+   private void setNumRecs(int n) {
+      tx.setInt(currentblk, INT_SIZE, n);
+   }
+   
+   private void insert(int slot) {
+      for (int i=getNumRecs(); i>slot; i--)
+         copyRecord(i-1, i);
+      setNumRecs(getNumRecs()+1);
+   }
+   
+   private void copyRecord(int from, int to) {
+      Schema sch = ti.schema();
+      for (String fldname : sch.fields())
+         setVal(to, fldname, getVal(from, fldname));
+   }
+   
+   private void transferRecs(int slot, BTreePage dest) {
+      int destslot = 0;
+      while (slot < getNumRecs()) {
+         dest.insert(destslot);
+         Schema sch = ti.schema();
+         for (String fldname : sch.fields())
+            dest.setVal(destslot, fldname, getVal(slot, fldname));
+         delete(slot);
+         destslot++;
+      }
+   }
+   
+   private int fldpos(int slot, String fldname) {
+      int offset = ti.offset(fldname);
+      return slotpos(slot) + offset;
+   }
+   
+   private int slotpos(int slot) {
+      return INT_SIZE + INT_SIZE + (slot * slotsize);
+   }
+}
diff --git a/simpledb/index/btree/DirEntry.class b/simpledb/index/btree/DirEntry.class
new file mode 100755
index 0000000..e65f2ce
Binary files /dev/null and b/simpledb/index/btree/DirEntry.class differ
diff --git a/simpledb/index/btree/DirEntry.java b/simpledb/index/btree/DirEntry.java
new file mode 100755
index 0000000..006fcfe
--- /dev/null
+++ b/simpledb/index/btree/DirEntry.java
@@ -0,0 +1,40 @@
+package simpledb.index.btree;
+
+import simpledb.query.Constant;
+
+/**
+ * A directory entry has two components: the number of the child block,
+ * and the dataval of the first record in that block.
+ * @author Edward Sciore
+ */
+public class DirEntry {
+   private Constant dataval;
+   private int blocknum;
+   
+   /**
+    * Creates a new entry for the specified dataval and block number.
+    * @param dataval the dataval
+    * @param blocknum the block number
+    */
+   public DirEntry(Constant dataval, int blocknum) {
+      this.dataval  = dataval;
+      this.blocknum = blocknum;
+   }
+   
+   /**
+    * Returns the dataval component of the entry
+    * @return the dataval component of the entry
+    */
+   public Constant dataVal() {
+      return dataval;
+   }
+   
+   /**
+    * Returns the block number component of the entry
+    * @return the block number component of the entry
+    */
+   public int blockNumber() {
+      return blocknum;
+   }
+}
+
diff --git a/simpledb/index/hash/HashIndex.class b/simpledb/index/hash/HashIndex.class
new file mode 100755
index 0000000..937acf6
Binary files /dev/null and b/simpledb/index/hash/HashIndex.class differ
diff --git a/simpledb/index/hash/HashIndex.java b/simpledb/index/hash/HashIndex.java
new file mode 100755
index 0000000..7804a3e
--- /dev/null
+++ b/simpledb/index/hash/HashIndex.java
@@ -0,0 +1,127 @@
+package simpledb.index.hash;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/**
+ * A static hash implementation of the Index interface.
+ * A fixed number of buckets is allocated (currently, 100),
+ * and each bucket is implemented as a file of index records.
+ * @author Edward Sciore
+ */
+public class HashIndex implements Index {
+	public static int NUM_BUCKETS = 100;
+	private String idxname;
+	private Schema sch;
+	private Transaction tx;
+	private Constant searchkey = null;
+	private TableScan ts = null;
+
+	/**
+	 * Opens a hash index for the specified index.
+	 * @param idxname the name of the index
+	 * @param sch the schema of the index records
+	 * @param tx the calling transaction
+	 */
+	public HashIndex(String idxname, Schema sch, Transaction tx) {
+		this.idxname = idxname;
+		this.sch = sch;
+		this.tx = tx;
+	}
+
+	/**
+	 * Positions the index before the first index record
+	 * having the specified search key.
+	 * The method hashes the search key to determine the bucket,
+	 * and then opens a table scan on the file
+	 * corresponding to the bucket.
+	 * The table scan for the previous bucket (if any) is closed.
+	 * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
+	 */
+	public void beforeFirst(Constant searchkey) {
+		close();
+		this.searchkey = searchkey;
+		int bucket = searchkey.hashCode() % NUM_BUCKETS;
+		String tblname = idxname + bucket;
+		TableInfo ti = new TableInfo(tblname, sch);
+		ts = new TableScan(ti, tx);
+	}
+
+	/**
+	 * Moves to the next record having the search key.
+	 * The method loops through the table scan for the bucket,
+	 * looking for a matching record, and returning false
+	 * if there are no more such records.
+	 * @see simpledb.index.Index#next()
+	 */
+	public boolean next() {
+		while (ts.next())
+			if (ts.getVal("dataval").equals(searchkey))
+				return true;
+		return false;
+	}
+
+	/**
+	 * Retrieves the dataRID from the current record
+	 * in the table scan for the bucket.
+	 * @see simpledb.index.Index#getDataRid()
+	 */
+	public RID getDataRid() {
+		int blknum = ts.getInt("block");
+		int id = ts.getInt("id");
+		return new RID(blknum, id);
+	}
+
+	/**
+	 * Inserts a new record into the table scan for the bucket.
+	 * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
+	 */
+	public void insert(Constant val, RID rid) {
+		beforeFirst(val);
+		ts.insert();
+		ts.setInt("block", rid.blockNumber());
+		ts.setInt("id", rid.id());
+		ts.setVal("dataval", val);
+	}
+
+	/**
+	 * Deletes the specified record from the table scan for
+	 * the bucket.  The method starts at the beginning of the
+	 * scan, and loops through the records until the
+	 * specified record is found.
+	 * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
+	 */
+	public void delete(Constant val, RID rid) {
+		beforeFirst(val);
+		while(next())
+			if (getDataRid().equals(rid)) {
+				ts.delete();
+				return;
+			}
+	}
+
+	/**
+	 * Closes the index by closing the current table scan.
+	 * @see simpledb.index.Index#close()
+	 */
+	public void close() {
+		if (ts != null)
+			ts.close();
+	}
+
+	/**
+	 * Returns the cost of searching an index file having the
+	 * specified number of blocks.
+	 * The method assumes that all buckets are about the
+	 * same size, and so the cost is simply the size of
+	 * the bucket.
+	 * @param numblocks the number of blocks of index records
+	 * @param rpb the number of records per block (not used here)
+	 * @return the cost of traversing the index
+	 */
+	public static int searchCost(int numblocks, int rpb){
+		return numblocks / HashIndex.NUM_BUCKETS;
+	}
+}
diff --git a/simpledb/index/planner/IndexUpdatePlanner.class b/simpledb/index/planner/IndexUpdatePlanner.class
new file mode 100755
index 0000000..cb04e05
Binary files /dev/null and b/simpledb/index/planner/IndexUpdatePlanner.class differ
diff --git a/simpledb/index/planner/IndexUpdatePlanner.java b/simpledb/index/planner/IndexUpdatePlanner.java
new file mode 100755
index 0000000..bf7e146
--- /dev/null
+++ b/simpledb/index/planner/IndexUpdatePlanner.java
@@ -0,0 +1,119 @@
+package simpledb.index.planner;
+
+import java.util.Iterator;
+import java.util.Map;
+
+import simpledb.record.RID;
+import simpledb.server.SimpleDB;
+import simpledb.tx.Transaction;
+import simpledb.index.Index;
+import simpledb.metadata.IndexInfo;
+import simpledb.parse.*;
+import simpledb.planner.*;
+import simpledb.query.*;
+
+/**
+ * A modification of the basic update planner.
+ * It dispatches each update statement to the corresponding
+ * index planner.
+ * @author Edward Sciore
+ */
+public class IndexUpdatePlanner implements UpdatePlanner {
+   
+   public int executeInsert(InsertData data, Transaction tx) {
+      String tblname = data.tableName();
+      Plan p = new TablePlan(tblname, tx);
+      
+      // first, insert the record
+      UpdateScan s = (UpdateScan) p.open();
+      s.insert();
+      RID rid = s.getRid();
+      
+      // then modify each field, inserting an index record if appropriate
+      Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
+      Iterator<Constant> valIter = data.vals().iterator();
+      for (String fldname : data.fields()) {
+         Constant val = valIter.next();
+         s.setVal(fldname, val);
+         
+         IndexInfo ii = indexes.get(fldname);
+         if (ii != null) {
+            Index idx = ii.open();
+            idx.insert(val, rid);
+            idx.close();
+         }
+      }
+      s.close();
+      return 1;
+   }
+   
+   public int executeDelete(DeleteData data, Transaction tx) {
+      String tblname = data.tableName();
+      Plan p = new TablePlan(tblname, tx);
+      p = new SelectPlan(p, data.pred());
+      Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
+      
+      UpdateScan s = (UpdateScan) p.open();
+      int count = 0;
+      while(s.next()) {
+         // first, delete the record's RID from every index
+         RID rid = s.getRid();
+         for (String fldname : indexes.keySet()) {
+            Constant val = s.getVal(fldname);
+            Index idx = indexes.get(fldname).open();
+            idx.delete(val, rid);
+            idx.close();
+         }
+         // then delete the record
+         s.delete();
+         count++;
+      }
+      s.close();
+      return count;
+   }
+   
+   public int executeModify(ModifyData data, Transaction tx) {
+      String tblname = data.tableName();
+      String fldname = data.targetField();
+      Plan p = new TablePlan(tblname, tx);
+      p = new SelectPlan(p, data.pred());
+      
+      IndexInfo ii = SimpleDB.mdMgr().getIndexInfo(tblname, tx).get(fldname);
+      Index idx = (ii == null) ? null : ii.open();
+      
+      UpdateScan s = (UpdateScan) p.open();
+      int count = 0;
+      while(s.next()) {
+         // first, update the record
+         Constant newval = data.newValue().evaluate(s);
+         Constant oldval = s.getVal(fldname);
+         s.setVal(data.targetField(), newval);
+         
+         // then update the appropriate index, if it exists
+         if (idx != null) {
+            RID rid = s.getRid();
+            idx.delete(oldval, rid);
+            idx.insert(newval, rid);
+         }
+         count++;
+      }
+      if (idx != null) idx.close();
+      s.close();
+      return count;
+   }
+   
+   public int executeCreateTable(CreateTableData data, Transaction tx) {
+      SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
+      return 0;
+   }
+   
+   public int executeCreateView(CreateViewData data, Transaction tx) {
+      SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
+      return 0;
+   }
+   
+   public int executeCreateIndex(CreateIndexData data, Transaction tx) {
+      SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
+      return 0;
+   }
+}
diff --git a/simpledb/index/query/IndexJoinPlan.class b/simpledb/index/query/IndexJoinPlan.class
new file mode 100755
index 0000000..9e4e515
Binary files /dev/null and b/simpledb/index/query/IndexJoinPlan.class differ
diff --git a/simpledb/index/query/IndexJoinPlan.java b/simpledb/index/query/IndexJoinPlan.java
new file mode 100755
index 0000000..50d76ce
--- /dev/null
+++ b/simpledb/index/query/IndexJoinPlan.java
@@ -0,0 +1,91 @@
+package simpledb.index.query;
+
+import simpledb.tx.Transaction;
+import simpledb.record.Schema;
+import simpledb.metadata.IndexInfo;
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/** The Plan class corresponding to the <i>indexjoin</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class IndexJoinPlan implements Plan {
+   private Plan p1, p2;
+   private IndexInfo ii;
+   private String joinfield;
+   private Schema sch = new Schema();
+   
+   /**
+    * Implements the join operator,
+    * using the specified LHS and RHS plans.
+    * @param p1 the left-hand plan
+    * @param p2 the right-hand plan
+    * @param ii information about the right-hand index
+    * @param joinfield the left-hand field used for joining
+    * @param tx the calling transaction
+    */
+   public IndexJoinPlan(Plan p1, Plan p2, IndexInfo ii, String joinfield, Transaction tx) {
+      this.p1 = p1;
+      this.p2 = p2;
+      this.ii = ii;
+      this.joinfield = joinfield;
+      sch.addAll(p1.schema());
+      sch.addAll(p2.schema());
+   }
+   
+   /**
+    * Opens an indexjoin scan for this query
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s = p1.open();
+      // throws an exception if p2 is not a tableplan
+      TableScan ts = (TableScan) p2.open();
+      Index idx = ii.open();
+      return new IndexJoinScan(s, idx, joinfield, ts);
+   }
+   
+   /**
+    * Estimates the number of block accesses to compute the join.
+    * The formula is:
+    * <pre> B(indexjoin(p1,p2,idx)) = B(p1) + R(p1)*B(idx)
+    *       + R(indexjoin(p1,p2,idx) </pre>
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p1.blocksAccessed() 
+         + (p1.recordsOutput() * ii.blocksAccessed())
+         + recordsOutput();
+   }
+   
+   /**
+    * Estimates the number of output records in the join.
+    * The formula is:
+    * <pre> R(indexjoin(p1,p2,idx)) = R(p1)*R(idx) </pre>
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p1.recordsOutput() * ii.recordsOutput();
+   }
+   
+   /**
+    * Estimates the number of distinct values for the 
+    * specified field.  
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (p1.schema().hasField(fldname))
+         return p1.distinctValues(fldname);
+      else
+         return p2.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the index join.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return sch;
+   }
+}
diff --git a/simpledb/index/query/IndexJoinScan.class b/simpledb/index/query/IndexJoinScan.class
new file mode 100755
index 0000000..ec13642
Binary files /dev/null and b/simpledb/index/query/IndexJoinScan.class differ
diff --git a/simpledb/index/query/IndexJoinScan.java b/simpledb/index/query/IndexJoinScan.java
new file mode 100755
index 0000000..7d04a66
--- /dev/null
+++ b/simpledb/index/query/IndexJoinScan.java
@@ -0,0 +1,122 @@
+package simpledb.index.query;
+
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/**
+ * The scan class corresponding to the indexjoin relational
+ * algebra operator.
+ * The code is very similar to that of ProductScan, 
+ * which makes sense because an index join is essentially
+ * the product of each LHS record with the matching RHS index records.
+ * @author Edward Sciore
+ */
+public class IndexJoinScan implements Scan {
+   private Scan s;
+   private TableScan ts;  // the data table
+   private Index idx;
+   private String joinfield;
+   
+   /**
+    * Creates an index join scan for the specified LHS scan and 
+    * RHS index.
+    * @param s the LHS scan
+    * @param idx the RHS index
+    * @param joinfield the LHS field used for joining
+    */
+   public IndexJoinScan(Scan s, Index idx, String joinfield, TableScan ts) {
+      this.s = s;
+      this.idx  = idx;
+      this.joinfield = joinfield;
+      this.ts = ts;
+      beforeFirst();
+   }
+   
+   /**
+    * Positions the scan before the first record.
+    * That is, the LHS scan will be positioned at its
+    * first record, and the index will be positioned
+    * before the first record for the join value.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      s.beforeFirst();
+      s.next();
+      resetIndex();
+   }
+   
+   /**
+    * Moves the scan to the next record.
+    * The method moves to the next index record, if possible.
+    * Otherwise, it moves to the next LHS record and the
+    * first index record.
+    * If there are no more LHS records, the method returns false.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      while (true) {
+         if (idx.next()) {
+            ts.moveToRid(idx.getDataRid());
+            return true;
+         }
+         if (!s.next())
+            return false;
+         resetIndex();
+      }
+   }
+   
+   /**
+    * Closes the scan by closing its LHS scan and its RHS index.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s.close();
+      idx.close();
+      ts.close();
+   }
+   
+   /**
+    * Returns the Constant value of the specified field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (ts.hasField(fldname))
+         return ts.getVal(fldname);
+      else
+         return s.getVal(fldname);
+   }
+   
+   /**
+    * Returns the integer value of the specified field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      if (ts.hasField(fldname))
+         return ts.getInt(fldname);
+      else  
+         return s.getInt(fldname);
+   }
+   
+   /**
+    * Returns the string value of the specified field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public String getString(String fldname) {
+      if (ts.hasField(fldname))
+         return ts.getString(fldname);
+      else
+         return s.getString(fldname);
+   }
+   
+   /** Returns true if the field is in the schema.
+     * @see simpledb.query.Scan#hasField(java.lang.String)
+     */
+   public boolean hasField(String fldname) {
+      return ts.hasField(fldname) || s.hasField(fldname);
+   }
+   
+   private void resetIndex() {
+      Constant searchkey = s.getVal(joinfield);
+      idx.beforeFirst(searchkey);
+   }
+}
diff --git a/simpledb/index/query/IndexSelectPlan.class b/simpledb/index/query/IndexSelectPlan.class
new file mode 100755
index 0000000..8ee81e8
Binary files /dev/null and b/simpledb/index/query/IndexSelectPlan.class differ
diff --git a/simpledb/index/query/IndexSelectPlan.java b/simpledb/index/query/IndexSelectPlan.java
new file mode 100755
index 0000000..505c184
--- /dev/null
+++ b/simpledb/index/query/IndexSelectPlan.java
@@ -0,0 +1,78 @@
+package simpledb.index.query;
+
+import simpledb.tx.Transaction;
+import simpledb.record.Schema;
+import simpledb.metadata.IndexInfo;
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/** The Plan class corresponding to the <i>indexselect</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class IndexSelectPlan implements Plan {
+   private Plan p;
+   private IndexInfo ii;
+   private Constant val;
+   
+   /**
+    * Creates a new indexselect node in the query tree
+    * for the specified index and selection constant.
+    * @param p the input table
+    * @param ii information about the index
+    * @param val the selection constant
+    * @param tx the calling transaction 
+    */
+   public IndexSelectPlan(Plan p, IndexInfo ii, Constant val, Transaction tx) {
+      this.p = p;
+      this.ii = ii;
+      this.val = val;
+   }
+   
+   /** 
+    * Creates a new indexselect scan for this query
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      // throws an exception if p is not a tableplan.
+      TableScan ts = (TableScan) p.open();
+      Index idx = ii.open();
+      return new IndexSelectScan(idx, val, ts);
+   }
+   
+   /**
+    * Estimates the number of block accesses to compute the 
+    * index selection, which is the same as the 
+    * index traversal cost plus the number of matching data records.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return ii.blocksAccessed() + recordsOutput();
+   }
+   
+   /**
+    * Estimates the number of output records in the index selection,
+    * which is the same as the number of search key values
+    * for the index.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return ii.recordsOutput();
+   }
+   
+   /** 
+    * Returns the distinct values as defined by the index.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      return ii.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the data table.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return p.schema(); 
+   }
+}
diff --git a/simpledb/index/query/IndexSelectScan.class b/simpledb/index/query/IndexSelectScan.class
new file mode 100755
index 0000000..5aeb350
Binary files /dev/null and b/simpledb/index/query/IndexSelectScan.class differ
diff --git a/simpledb/index/query/IndexSelectScan.java b/simpledb/index/query/IndexSelectScan.java
new file mode 100755
index 0000000..9558546
--- /dev/null
+++ b/simpledb/index/query/IndexSelectScan.java
@@ -0,0 +1,98 @@
+package simpledb.index.query;
+
+import simpledb.record.RID;
+import simpledb.query.*;
+import simpledb.index.Index;
+
+/**
+ * The scan class corresponding to the select relational
+ * algebra operator.
+ * @author Edward Sciore
+ */
+public class IndexSelectScan implements Scan {
+   private Index idx;
+   private Constant val;
+   private TableScan ts;
+   
+   /**
+    * Creates an index select scan for the specified
+    * index and selection constant.
+    * @param idx the index
+    * @param val the selection constant
+    */
+   public IndexSelectScan(Index idx, Constant val, TableScan ts) {
+      this.idx = idx;
+      this.val = val;
+      this.ts  = ts;
+      beforeFirst();
+   }
+   
+   /**
+    * Positions the scan before the first record,
+    * which in this case means positioning the index
+    * before the first instance of the selection constant.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      idx.beforeFirst(val);
+   }
+   
+   /**
+    * Moves to the next record, which in this case means
+    * moving the index to the next record satisfying the
+    * selection constant, and returning false if there are
+    * no more such index records.
+    * If there is a next record, the method moves the 
+    * tablescan to the corresponding data record.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      boolean ok = idx.next();
+      if (ok) {
+         RID rid = idx.getDataRid();
+         ts.moveToRid(rid);
+      }
+      return ok;
+   }
+   
+   /**
+    * Closes the scan by closing the index and the tablescan.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      idx.close();
+      ts.close();
+   }
+   
+   /**
+    * Returns the value of the field of the current data record.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      return ts.getVal(fldname);
+   }
+   
+   /**
+    * Returns the value of the field of the current data record.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return ts.getInt(fldname);
+   }
+   
+   /**
+    * Returns the value of the field of the current data record.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return ts.getString(fldname);
+   }
+   
+   /**
+    * Returns whether the data record has the specified field.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return ts.hasField(fldname);
+   }
+}
diff --git a/simpledb/log/BasicLogRecord.class b/simpledb/log/BasicLogRecord.class
new file mode 100755
index 0000000..f3160fe
Binary files /dev/null and b/simpledb/log/BasicLogRecord.class differ
diff --git a/simpledb/log/BasicLogRecord.java b/simpledb/log/BasicLogRecord.java
new file mode 100755
index 0000000..ac28793
--- /dev/null
+++ b/simpledb/log/BasicLogRecord.java
@@ -0,0 +1,54 @@
+package simpledb.log;
+
+import static simpledb.file.Page.*;
+import simpledb.file.Page;
+
+/**
+ * A class that provides the ability to read the values of
+ * a log record.
+ * The class has no idea what values are there.
+ * Instead, the methods {@link #nextInt() nextInt}
+ * and {@link #nextString() nextString} read the values 
+ * sequentially.
+ * Thus the client is responsible for knowing how many values
+ * are in the log record, and what their types are.
+ * @author Edward Sciore
+ */
+public class BasicLogRecord {
+   private Page pg;
+   private int pos;
+   
+   /**
+    * A log record located at the specified position of the specified page.
+    * This constructor is called exclusively by
+    * {@link LogIterator#next()}.
+    * @param pg the page containing the log record
+    * @param pos the position of the log record 
+    */
+   public BasicLogRecord(Page pg, int pos) {
+      this.pg = pg;
+      this.pos = pos;
+   }
+   
+   /**
+    * Returns the next value of the current log record, 
+    * assuming it is an integer.
+    * @return the next value of the current log record
+    */
+   public int nextInt() {
+      int result = pg.getInt(pos);
+      pos += INT_SIZE;
+      return result;
+   }
+   
+   /**
+    * Returns the next value of the current log record, 
+    * assuming it is a string.
+    * @return the next value of the current log record
+    */
+   public String nextString() {
+      String result = pg.getString(pos);
+      pos += STR_SIZE(result.length());
+      return result;
+   }
+}
diff --git a/simpledb/log/LogIterator.class b/simpledb/log/LogIterator.class
new file mode 100755
index 0000000..f329283
Binary files /dev/null and b/simpledb/log/LogIterator.class differ
diff --git a/simpledb/log/LogIterator.java b/simpledb/log/LogIterator.java
new file mode 100755
index 0000000..5207ec2
--- /dev/null
+++ b/simpledb/log/LogIterator.java
@@ -0,0 +1,66 @@
+package simpledb.log;
+
+import static simpledb.file.Page.INT_SIZE;
+import simpledb.file.*;
+import java.util.Iterator;
+
+/**
+ * A class that provides the ability to move through the
+ * records of the log file in reverse order.
+ * 
+ * @author Edward Sciore
+ */
+class LogIterator implements Iterator<BasicLogRecord> {
+   private Block blk;
+   private Page pg = new Page();
+   private int currentrec;
+   
+   /**
+    * Creates an iterator for the records in the log file,
+    * positioned after the last log record.
+    * This constructor is called exclusively by
+    * {@link LogMgr#iterator()}.
+    */
+   LogIterator(Block blk) {
+      this.blk = blk;
+      pg.read(blk);
+      currentrec = pg.getInt(LogMgr.LAST_POS);
+   }
+   
+   /**
+    * Determines if the current log record
+    * is the earliest record in the log file.
+    * @return true if there is an earlier record
+    */
+   public boolean hasNext() {
+      return currentrec>0 || blk.number()>0;
+   }
+   
+   /**
+    * Moves to the next log record in reverse order.
+    * If the current log record is the earliest in its block,
+    * then the method moves to the next oldest block,
+    * and returns the log record from there.
+    * @return the next earliest log record
+    */
+   public BasicLogRecord next() {
+      if (currentrec == 0) 
+         moveToNextBlock();
+      currentrec = pg.getInt(currentrec);
+      return new BasicLogRecord(pg, currentrec+INT_SIZE);
+   }
+   
+   public void remove() {
+      throw new UnsupportedOperationException();
+   }
+   
+   /**
+    * Moves to the next log block in reverse order,
+    * and positions it after the last record in that block.
+    */
+   private void moveToNextBlock() {
+      blk = new Block(blk.fileName(), blk.number()-1);
+      pg.read(blk);
+      currentrec = pg.getInt(LogMgr.LAST_POS);
+   }
+}
diff --git a/simpledb/log/LogMgr.class b/simpledb/log/LogMgr.class
new file mode 100755
index 0000000..99e1abc
Binary files /dev/null and b/simpledb/log/LogMgr.class differ
diff --git a/simpledb/log/LogMgr.java b/simpledb/log/LogMgr.java
new file mode 100755
index 0000000..f4cf396
--- /dev/null
+++ b/simpledb/log/LogMgr.java
@@ -0,0 +1,172 @@
+package simpledb.log;
+
+import simpledb.server.SimpleDB;
+import simpledb.file.*;
+import static simpledb.file.Page.*;
+import java.util.*;
+
+/**
+ * The low-level log manager.
+ * This log manager is responsible for writing log records
+ * into a log file.
+ * A log record can be any sequence of integer and string values.
+ * The log manager does not understand the meaning of these
+ * values, which are written and read by the
+ * {@link simpledb.tx.recovery.RecoveryMgr recovery manager}.
+ * @author Edward Sciore
+ */
+public class LogMgr implements Iterable<BasicLogRecord> {
+   /**
+    * The location where the pointer to the last integer in the page is.
+    * A value of 0 means that the pointer is the first value in the page.
+    */
+   public static final int LAST_POS = 0;
+
+   private String logfile;
+   private Page mypage = new Page();
+   private Block currentblk;
+   private int currentpos;
+
+   /**
+    * Creates the manager for the specified log file.
+    * If the log file does not yet exist, it is created
+    * with an empty first block.
+    * This constructor depends on a {@link FileMgr} object
+    * that it gets from the method
+    * {@link simpledb.server.SimpleDB#fileMgr()}.
+    * That object is created during system initialization.
+    * Thus this constructor cannot be called until
+    * {@link simpledb.server.SimpleDB#initFileMgr(String)}
+    * is called first.
+    * @param logfile the name of the log file
+    */
+   public LogMgr(String logfile) {
+      this.logfile = logfile;
+      int logsize = SimpleDB.fileMgr().size(logfile);
+      if (logsize == 0)
+         appendNewBlock();
+      else {
+         currentblk = new Block(logfile, logsize-1);
+         mypage.read(currentblk);
+         currentpos = getLastRecordPosition() + INT_SIZE;
+      }
+   }
+
+   /**
+    * Ensures that the log records corresponding to the
+    * specified LSN has been written to disk.
+    * All earlier log records will also be written to disk.
+    * @param lsn the LSN of a log record
+    */
+   public void flush(int lsn) {
+      if (lsn >= currentLSN())
+         flush();
+   }
+
+   /**
+    * Returns an iterator for the log records,
+    * which will be returned in reverse order starting with the most recent.
+    * @see java.lang.Iterable#iterator()
+    */
+   public synchronized Iterator<BasicLogRecord> iterator() {
+      flush();
+      return new LogIterator(currentblk);
+   }
+
+   /**
+    * Appends a log record to the file.
+    * The record contains an arbitrary array of strings and integers.
+    * The method also writes an integer to the end of each log record whose value
+    * is the offset of the corresponding integer for the previous log record.
+    * These integers allow log records to be read in reverse order.
+    * @param rec the list of values
+    * @return the LSN of the final value
+    */
+   public synchronized int append(Object[] rec) {
+      int recsize = INT_SIZE;  // 4 bytes for the integer that points to the previous log record
+      for (Object obj : rec)
+         recsize += size(obj);
+      if (currentpos + recsize >= BLOCK_SIZE){ // the log record doesn't fit,
+         flush();        // so move to the next block.
+         appendNewBlock();
+      }
+      for (Object obj : rec)
+         appendVal(obj);
+      finalizeRecord();
+      return currentLSN();
+   }
+
+   /**
+    * Adds the specified value to the page at the position denoted by
+    * currentpos.  Then increments currentpos by the size of the value.
+    * @param val the integer or string to be added to the page
+    */
+   private void appendVal(Object val) {
+      if (val instanceof String)
+         mypage.setString(currentpos, (String)val);
+      else
+         mypage.setInt(currentpos, (Integer)val);
+      currentpos += size(val);
+   }
+
+   /**
+    * Calculates the size of the specified integer or string.
+    * @param val the value
+    * @return the size of the value, in bytes
+    */
+   private int size(Object val) {
+      if (val instanceof String) {
+         String sval = (String) val;
+         return STR_SIZE(sval.length());
+      }
+      else
+         return INT_SIZE;
+   }
+
+   /**
+    * Returns the LSN of the most recent log record.
+    * As implemented, the LSN is the block number where the record is stored.
+    * Thus every log record in a block has the same LSN.
+    * @return the LSN of the most recent log record
+    */
+   private int currentLSN() {
+      return currentblk.number();
+   }
+
+   /**
+    * Writes the current page to the log file.
+    */
+   private void flush() {
+      mypage.write(currentblk);
+   }
+
+   /**
+    * Clear the current page, and append it to the log file.
+    */
+   private void appendNewBlock() {
+      setLastRecordPosition(0);
+      currentpos = INT_SIZE;
+      currentblk = mypage.append(logfile);
+   }
+
+   /**
+    * Sets up a circular chain of pointers to the records in the page.
+    * There is an integer added to the end of each log record
+    * whose value is the offset of the previous log record.
+    * The first four bytes of the page contain an integer whose value
+    * is the offset of the integer for the last log record in the page.
+    */
+   private void finalizeRecord() {
+      mypage.setInt(currentpos, getLastRecordPosition());
+      setLastRecordPosition(currentpos);
+      currentpos += INT_SIZE;
+   }
+
+   private int getLastRecordPosition() {
+      return mypage.getInt(LAST_POS);
+   }
+
+   private void setLastRecordPosition(int pos) {
+      mypage.setInt(LAST_POS, pos);
+   }
+}
diff --git a/simpledb/materialize/AggregationFn.class b/simpledb/materialize/AggregationFn.class
new file mode 100755
index 0000000..5fb2ab8
Binary files /dev/null and b/simpledb/materialize/AggregationFn.class differ
diff --git a/simpledb/materialize/AggregationFn.java b/simpledb/materialize/AggregationFn.java
new file mode 100755
index 0000000..051f193
--- /dev/null
+++ b/simpledb/materialize/AggregationFn.java
@@ -0,0 +1,37 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+
+/**
+ * The interface implemented by aggregation functions.
+ * Aggregation functions are used by the <i>groupby</i> operator.
+ * @author Edward Sciore
+ */
+public interface AggregationFn {
+   
+   /**
+    * Uses the current record of the specified scan
+    * to be the first record in the group.
+    * @param s the scan to aggregate over.
+    */
+   void processFirst(Scan s);
+   
+   /**
+    * Uses the current record of the specified scan
+    * to be the next record in the group.
+    * @param s the scan to aggregate over.
+    */
+   void processNext(Scan s);
+   
+   /**
+    * Returns the name of the new aggregation field.
+    * @return the name of the new aggregation field
+    */
+   String fieldName();
+   
+   /**
+    * Returns the computed aggregation value.
+    * @return the computed aggregation value
+    */
+   Constant value();
+}
diff --git a/simpledb/materialize/CountFn.class b/simpledb/materialize/CountFn.class
new file mode 100755
index 0000000..5246ec5
Binary files /dev/null and b/simpledb/materialize/CountFn.class differ
diff --git a/simpledb/materialize/CountFn.java b/simpledb/materialize/CountFn.java
new file mode 100755
index 0000000..1dfd8ee
--- /dev/null
+++ b/simpledb/materialize/CountFn.java
@@ -0,0 +1,58 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+
+/**
+ * The <i>count</i> aggregation function.
+ * @author Edward Sciore
+ */
+public class CountFn implements AggregationFn {
+   private String fldname;
+   private int count;
+   
+   /**
+    * Creates a count aggregation function for the specified field.
+    * @param fldname the name of the aggregated field
+    */
+   public CountFn(String fldname) {
+      this.fldname = fldname;
+   }
+   
+   /**
+    * Starts a new count.
+    * Since SimpleDB does not support null values,
+    * every record will be counted,
+    * regardless of the field.
+    * The current count is thus set to 1.
+    * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
+    */
+   public void processFirst(Scan s) {
+      count = 1;
+   }
+   
+   /**
+    * Since SimpleDB does not support null values,
+    * this method always increments the count,
+    * regardless of the field.
+    * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
+    */
+   public void processNext(Scan s) {
+      count++;
+   }
+   
+   /**
+    * Returns the field's name, prepended by "countof".
+    * @see simpledb.materialize.AggregationFn#fieldName()
+    */
+   public String fieldName() {
+      return "countof" + fldname;
+   }
+   
+   /**
+    * Returns the current count.
+    * @see simpledb.materialize.AggregationFn#value()
+    */
+   public Constant value() {
+      return new IntConstant(count);
+   }
+}
diff --git a/simpledb/materialize/GroupByPlan.class b/simpledb/materialize/GroupByPlan.class
new file mode 100755
index 0000000..d5df929
Binary files /dev/null and b/simpledb/materialize/GroupByPlan.class differ
diff --git a/simpledb/materialize/GroupByPlan.java b/simpledb/materialize/GroupByPlan.java
new file mode 100755
index 0000000..d0ff3bf
--- /dev/null
+++ b/simpledb/materialize/GroupByPlan.java
@@ -0,0 +1,102 @@
+package simpledb.materialize;
+
+import simpledb.tx.Transaction;
+import simpledb.record.Schema;
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * The Plan class for the <i>groupby</i> operator.
+ * @author Edward Sciore
+ */
+public class GroupByPlan implements Plan {
+   private Plan p;
+   private Collection<String> groupfields;
+   private Collection<AggregationFn> aggfns;
+   private Schema sch = new Schema();
+   
+   /**
+    * Creates a groupby plan for the underlying query.
+    * The grouping is determined by the specified
+    * collection of group fields,
+    * and the aggregation is computed by the
+    * specified collection of aggregation functions.
+    * @param p a plan for the underlying query
+    * @param groupfields the group fields
+    * @param aggfns the aggregation functions
+    * @param tx the calling transaction
+    */
+   public GroupByPlan(Plan p, Collection<String> groupfields, Collection<AggregationFn> aggfns, Transaction tx) {
+      List<String> grouplist = new ArrayList<String>();
+      grouplist.addAll(groupfields);
+      this.p = new SortPlan(p, grouplist, tx);
+      this.groupfields = groupfields;
+      this.aggfns = aggfns;
+      for (String fldname : groupfields)
+         sch.add(fldname, p.schema());
+      for (AggregationFn fn : aggfns)
+         sch.addIntField(fn.fieldName());
+   }
+   
+   /**
+    * This method opens a sort plan for the specified plan.
+    * The sort plan ensures that the underlying records
+    * will be appropriately grouped.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s = p.open();
+      return new GroupByScan(s, groupfields, aggfns);
+   }
+   
+   /**
+    * Returns the number of blocks required to
+    * compute the aggregation,
+    * which is one pass through the sorted table.
+    * It does <i>not</i> include the one-time cost
+    * of materializing and sorting the records.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p.blocksAccessed();
+   }
+   
+   /**
+    * Returns the number of groups.  Assuming equal distribution,
+    * this is the product of the distinct values
+    * for each grouping field.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      int numgroups = 1;
+      for (String fldname : groupfields)
+         numgroups *= p.distinctValues(fldname);
+      return numgroups;
+   }
+   
+   /**
+    * Returns the number of distinct values for the
+    * specified field.  If the field is a grouping field,
+    * then the number of distinct values is the same
+    * as in the underlying query.
+    * If the field is an aggregate field, then we
+    * assume that all values are distinct.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (p.schema().hasField(fldname))
+         return p.distinctValues(fldname);
+      else
+         return recordsOutput();
+   }
+   
+   /**
+    * Returns the schema of the output table.
+    * The schema consists of the group fields,
+    * plus one field for each aggregation function.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return sch;
+   }
+}
diff --git a/simpledb/materialize/GroupByScan.class b/simpledb/materialize/GroupByScan.class
new file mode 100755
index 0000000..4930281
Binary files /dev/null and b/simpledb/materialize/GroupByScan.class differ
diff --git a/simpledb/materialize/GroupByScan.java b/simpledb/materialize/GroupByScan.java
new file mode 100755
index 0000000..1efd539
--- /dev/null
+++ b/simpledb/materialize/GroupByScan.java
@@ -0,0 +1,132 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * The Scan class for the <i>groupby</i> operator.
+ * @author Edward Sciore
+ */
+public class GroupByScan implements Scan {
+   private Scan s;
+   private Collection<String> groupfields;
+   private Collection<AggregationFn> aggfns;
+   private GroupValue groupval;
+   private boolean moregroups;
+   
+   /**
+    * Creates a groupby scan, given a grouped table scan.
+    * @param s the grouped scan
+    * @param groupfields the group fields
+    * @param aggfns the aggregation functions
+    */
+   public GroupByScan(Scan s, Collection<String> groupfields, Collection<AggregationFn> aggfns) {
+      this.s = s;
+      this.groupfields = groupfields;
+      this.aggfns = aggfns;
+      beforeFirst();
+   }
+   
+   /**
+    * Positions the scan before the first group.
+    * Internally, the underlying scan is always 
+    * positioned at the first record of a group, which 
+    * means that this method moves to the
+    * first underlying record.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      s.beforeFirst();
+      moregroups = s.next();
+   }
+   
+   /**
+    * Moves to the next group.
+    * The key of the group is determined by the 
+    * group values at the current record.
+    * The method repeatedly reads underlying records until
+    * it encounters a record having a different key.
+    * The aggregation functions are called for each record
+    * in the group. 
+    * The values of the grouping fields for the group are saved.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      if (!moregroups)
+         return false;
+      for (AggregationFn fn : aggfns)
+         fn.processFirst(s);
+      groupval = new GroupValue(s, groupfields);
+      while(moregroups = s.next()) {
+         GroupValue gv = new GroupValue(s, groupfields);
+         if (!groupval.equals(gv))
+            break;
+         for (AggregationFn fn : aggfns)
+            fn.processNext(s);
+      }
+      return true;
+   }
+   
+   /**
+    * Closes the scan by closing the underlying scan.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s.close();
+   }
+   
+   /**
+    * Gets the Constant value of the specified field.
+    * If the field is a group field, then its value can
+    * be obtained from the saved group value.
+    * Otherwise, the value is obtained from the
+    * appropriate aggregation function.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (groupfields.contains(fldname))
+         return groupval.getVal(fldname);
+      for (AggregationFn fn : aggfns)
+         if (fn.fieldName().equals(fldname))
+         return fn.value();
+      throw new RuntimeException("field " + fldname + " not found.");
+   }
+   
+   /**
+    * Gets the integer value of the specified field.
+    * If the field is a group field, then its value can
+    * be obtained from the saved group value.
+    * Otherwise, the value is obtained from the
+    * appropriate aggregation function.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return (Integer)getVal(fldname).asJavaVal();
+   }
+   
+   /**
+    * Gets the string value of the specified field.
+    * If the field is a group field, then its value can
+    * be obtained from the saved group value.
+    * Otherwise, the value is obtained from the
+    * appropriate aggregation function.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return (String)getVal(fldname).asJavaVal();
+   }
+   
+   /* Returns true if the specified field is either a 
+    * grouping field or created by an aggregation function.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      if (groupfields.contains(fldname))
+         return true;
+      for (AggregationFn fn : aggfns)
+         if (fn.fieldName().equals(fldname))
+         return true;
+      return false;
+   }
+}
+
diff --git a/simpledb/materialize/GroupValue.class b/simpledb/materialize/GroupValue.class
new file mode 100755
index 0000000..9711208
Binary files /dev/null and b/simpledb/materialize/GroupValue.class differ
diff --git a/simpledb/materialize/GroupValue.java b/simpledb/materialize/GroupValue.java
new file mode 100755
index 0000000..d3a9a98
--- /dev/null
+++ b/simpledb/materialize/GroupValue.java
@@ -0,0 +1,65 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+
+import java.util.*;
+
+/**
+ * An object that holds the values of the grouping fields
+ * for the current record of a scan.
+ * @author Edward Sciore
+ */
+public class GroupValue {
+   private Map<String,Constant> vals;
+   
+   /**
+    * Creates a new group value, given the specified scan
+    * and list of fields.
+    * The values in the current record of each field are 
+    * stored.
+    * @param s a scan
+    * @param fields the list of fields
+    */
+   public GroupValue(Scan s, Collection<String> fields) {
+      vals = new HashMap<String,Constant>();
+      for (String fldname : fields)
+         vals.put(fldname, s.getVal(fldname));
+   }
+   
+   /**
+    * Returns the Constant value of the specified field in the group.
+    * @param fldname the name of a field
+    * @return the value of the field in the group
+    */
+   public Constant getVal(String fldname) {
+      return vals.get(fldname);
+   }
+   
+   /** 
+    * Two GroupValue objects are equal if they have the same values
+    * for their grouping fields. 
+    * @see java.lang.Object#equals(java.lang.Object)
+    */
+   public boolean equals(Object obj) {
+      GroupValue gv = (GroupValue) obj;
+      for (String fldname : vals.keySet()) {
+         Constant v1 = vals.get(fldname);
+         Constant v2 = gv.getVal(fldname);
+         if (!v1.equals(v2))
+            return false;
+      }
+      return true;
+   }
+   
+   /**
+    * The hashcode of a GroupValue object is the sum of the
+    * hashcodes of its field values. 
+    * @see java.lang.Object#hashCode()
+    */
+   public int hashCode() {
+      int hashval = 0;
+      for (Constant c: vals.values())
+         hashval += c.hashCode();
+      return hashval;
+   }
+}
\ No newline at end of file
diff --git a/simpledb/materialize/MaterializePlan.class b/simpledb/materialize/MaterializePlan.class
new file mode 100755
index 0000000..003ab1c
Binary files /dev/null and b/simpledb/materialize/MaterializePlan.class differ
diff --git a/simpledb/materialize/MaterializePlan.java b/simpledb/materialize/MaterializePlan.java
new file mode 100755
index 0000000..5825af1
--- /dev/null
+++ b/simpledb/materialize/MaterializePlan.java
@@ -0,0 +1,87 @@
+package simpledb.materialize;
+
+import static simpledb.file.Page.BLOCK_SIZE;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+
+/**
+ * The Plan class for the <i>materialize</i> operator.
+ * @author Edward Sciore
+ */
+public class MaterializePlan implements Plan {
+   private Plan srcplan;
+   private Transaction tx;
+   
+   /**
+    * Creates a materialize plan for the specified query.
+    * @param srcplan the plan of the underlying query
+    * @param tx the calling transaction
+    */
+   public MaterializePlan(Plan srcplan, Transaction tx) {
+      this.srcplan = srcplan;
+      this.tx = tx;
+   }
+   
+   /**
+    * This method loops through the underlying query,
+    * copying its output records into a temporary table.
+    * It then returns a table scan for that table.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Schema sch = srcplan.schema();
+      TempTable temp = new TempTable(sch, tx);
+      Scan src = srcplan.open();
+      UpdateScan dest = temp.open();
+      while (src.next()) {
+         dest.insert();
+         for (String fldname : sch.fields())
+            dest.setVal(fldname, src.getVal(fldname));
+      }
+      src.close();
+      dest.beforeFirst();
+      return dest;
+   }
+   
+   /**
+    * Returns the estimated number of blocks in the 
+    * materialized table.
+    * It does <i>not</i> include the one-time cost
+    * of materializing the records.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      // create a dummy TableInfo object to calculate record length
+      TableInfo ti = new TableInfo("", srcplan.schema());
+      double rpb = (double) (BLOCK_SIZE / ti.recordLength());
+      return (int) Math.ceil(srcplan.recordsOutput() / rpb);
+   }
+   
+   /**
+    * Returns the number of records in the materialized table,
+    * which is the same as in the underlying plan.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return srcplan.recordsOutput();
+   }
+   
+   /**
+    * Returns the number of distinct field values,
+    * which is the same as in the underlying plan.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      return srcplan.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the materialized table,
+    * which is the same as in the underlying plan.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return srcplan.schema();
+   }
+}
diff --git a/simpledb/materialize/MaxFn.class b/simpledb/materialize/MaxFn.class
new file mode 100755
index 0000000..f52298d
Binary files /dev/null and b/simpledb/materialize/MaxFn.class differ
diff --git a/simpledb/materialize/MaxFn.java b/simpledb/materialize/MaxFn.java
new file mode 100755
index 0000000..f1e443c
--- /dev/null
+++ b/simpledb/materialize/MaxFn.java
@@ -0,0 +1,56 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+
+/**
+ * The <i>max</i> aggregation function.
+ * @author Edward Sciore
+ */
+public class MaxFn implements AggregationFn {
+   private String fldname;
+   private Constant val;
+   
+   /**
+    * Creates a max aggregation function for the specified field.
+    * @param fldname the name of the aggregated field
+    */
+   public MaxFn(String fldname) {
+      this.fldname = fldname;
+   }
+   
+   /**
+    * Starts a new maximum to be the 
+    * field value in the current record.
+    * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
+    */
+   public void processFirst(Scan s) {
+      val = s.getVal(fldname);
+   }
+   
+   /**
+    * Replaces the current maximum by the field value
+    * in the current record, if it is higher.
+    * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
+    */
+   public void processNext(Scan s) {
+      Constant newval = s.getVal(fldname);
+      if (newval.compareTo(val) > 0)
+         val = newval;
+   }
+   
+   /**
+    * Returns the field's name, prepended by "maxof".
+    * @see simpledb.materialize.AggregationFn#fieldName()
+    */
+   public String fieldName() {
+      return "maxof" + fldname;
+   }
+   
+   /**
+    * Returns the current maximum.
+    * @see simpledb.materialize.AggregationFn#value()
+    */
+   public Constant value() {
+      return val;
+   }
+}
diff --git a/simpledb/materialize/MergeJoinPlan.class b/simpledb/materialize/MergeJoinPlan.class
new file mode 100755
index 0000000..9800061
Binary files /dev/null and b/simpledb/materialize/MergeJoinPlan.class differ
diff --git a/simpledb/materialize/MergeJoinPlan.java b/simpledb/materialize/MergeJoinPlan.java
new file mode 100755
index 0000000..1ea69d4
--- /dev/null
+++ b/simpledb/materialize/MergeJoinPlan.java
@@ -0,0 +1,100 @@
+package simpledb.materialize;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * The Plan class for the <i>mergejoin</i> operator.
+ * @author Edward Sciore
+ */
+public class MergeJoinPlan implements Plan {
+   private Plan p1, p2;
+   private String fldname1, fldname2;
+   private Schema sch = new Schema();
+   
+   /**
+    * Creates a mergejoin plan for the two specified queries.
+    * The RHS must be materialized after it is sorted, 
+    * in order to deal with possible duplicates.
+    * @param p1 the LHS query plan
+    * @param p2 the RHS query plan
+    * @param fldname1 the LHS join field
+    * @param fldname2 the RHS join field
+    * @param tx the calling transaction
+    */
+   public MergeJoinPlan(Plan p1, Plan p2, String fldname1, String fldname2, Transaction tx) {
+      this.fldname1 = fldname1;
+      List<String> sortlist1 = Arrays.asList(fldname1);
+      this.p1 = new SortPlan(p1, sortlist1, tx);
+      
+      this.fldname2 = fldname2;
+      List<String> sortlist2 = Arrays.asList(fldname2);
+      this.p2 = new SortPlan(p2, sortlist2, tx);
+      
+      sch.addAll(p1.schema());
+      sch.addAll(p2.schema());
+   }
+   
+   /** The method first sorts its two underlying scans
+     * on their join field. It then returns a mergejoin scan
+     * of the two sorted table scans.
+     * @see simpledb.query.Plan#open()
+     */
+   public Scan open() {
+      Scan s1 = p1.open();
+      SortScan s2 = (SortScan) p2.open();
+      return new MergeJoinScan(s1, s2, fldname1, fldname2);
+   }
+   
+   /**
+    * Returns the number of block acceses required to
+    * mergejoin the sorted tables.
+    * Since a mergejoin can be preformed with a single
+    * pass through each table, the method returns
+    * the sum of the block accesses of the 
+    * materialized sorted tables.
+    * It does <i>not</i> include the one-time cost
+    * of materializing and sorting the records.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p1.blocksAccessed() + p2.blocksAccessed();
+   }
+   
+   /**
+    * Returns the number of records in the join.
+    * Assuming uniform distribution, the formula is:
+    * <pre> R(join(p1,p2)) = R(p1)*R(p2)/max{V(p1,F1),V(p2,F2)}</pre>
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      int maxvals = Math.max(p1.distinctValues(fldname1),
+                             p2.distinctValues(fldname2));
+      return (p1.recordsOutput() * p2.recordsOutput()) / maxvals;
+   }
+   
+   /**
+    * Estimates the distinct number of field values in the join.
+    * Since the join does not increase or decrease field values,
+    * the estimate is the same as in the appropriate underlying query.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (p1.schema().hasField(fldname))
+         return p1.distinctValues(fldname);
+      else
+         return p2.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the join,
+    * which is the union of the schemas of the underlying queries.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return sch;
+   }
+}
+
diff --git a/simpledb/materialize/MergeJoinScan.class b/simpledb/materialize/MergeJoinScan.class
new file mode 100755
index 0000000..e168641
Binary files /dev/null and b/simpledb/materialize/MergeJoinScan.class differ
diff --git a/simpledb/materialize/MergeJoinScan.java b/simpledb/materialize/MergeJoinScan.java
new file mode 100755
index 0000000..bc04e9b
--- /dev/null
+++ b/simpledb/materialize/MergeJoinScan.java
@@ -0,0 +1,138 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+
+/**
+ * The Scan class for the <i>mergejoin</i> operator.
+ * @author Edward Sciore
+ */
+public class MergeJoinScan implements Scan {
+   private Scan s1;
+   private SortScan s2;
+   private String fldname1, fldname2;
+   private Constant joinval = null;
+   
+   /**
+    * Creates a mergejoin scan for the two underlying sorted scans.
+    * @param s1 the LHS sorted scan
+    * @param s2 the RHS sorted scan
+    * @param fldname1 the LHS join field
+    * @param fldname2 the RHS join field
+    */
+   public MergeJoinScan(Scan s1, SortScan s2, String fldname1, String fldname2) {
+      this.s1 = s1;
+      this.s2 = s2;
+      this.fldname1 = fldname1;
+      this.fldname2 = fldname2;
+      beforeFirst();
+   }
+   
+   /**
+    * Positions the scan before the first record,
+    * by positioning each underlying scan before
+    * their first records.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      s1.beforeFirst();
+      s2.beforeFirst();
+   }
+   
+   /**
+    * Closes the scan by closing the two underlying scans.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s1.close();
+      s2.close();
+   }
+   
+   /**
+    * Moves to the next record.  This is where the action is.
+    * <P>
+    * If the next RHS record has the same join value,
+    * then move to it.
+    * Otherwise, if the next LHS record has the same join value,
+    * then reposition the RHS scan back to the first record
+    * having that join value.
+    * Otherwise, repeatedly move the scan having the smallest
+    * value until a common join value is found.
+    * When one of the scans runs out of records, return false.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      boolean hasmore2 = s2.next();
+      if (hasmore2 && s2.getVal(fldname2).equals(joinval))
+         return true;
+      
+      boolean hasmore1 = s1.next();
+      if (hasmore1 && s1.getVal(fldname1).equals(joinval)) {
+         s2.restorePosition();
+         return true;
+      }
+      
+      while (hasmore1 && hasmore2) {
+         Constant v1 = s1.getVal(fldname1);
+         Constant v2 = s2.getVal(fldname2);
+         if (v1.compareTo(v2) < 0)
+            hasmore1 = s1.next();
+         else if (v1.compareTo(v2) > 0)
+            hasmore2 = s2.next();
+         else {
+            s2.savePosition();
+            joinval  = s2.getVal(fldname2);
+            return true;
+         }
+      }
+      return false;
+   }
+   
+   /** 
+    * Returns the value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getVal(fldname);
+      else
+         return s2.getVal(fldname);
+   }
+   
+   /** 
+    * Returns the integer value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getInt(fldname);
+      else
+         return s2.getInt(fldname);
+   }
+   
+   /** 
+    * Returns the string value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getString(fldname);
+      else
+         return s2.getString(fldname);
+   }
+   
+   /**
+    * Returns true if the specified field is in
+    * either of the underlying scans.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return s1.hasField(fldname) || s2.hasField(fldname);
+   }
+}
+
diff --git a/simpledb/materialize/RecordComparator.class b/simpledb/materialize/RecordComparator.class
new file mode 100755
index 0000000..8188cb7
Binary files /dev/null and b/simpledb/materialize/RecordComparator.class differ
diff --git a/simpledb/materialize/RecordComparator.java b/simpledb/materialize/RecordComparator.java
new file mode 100755
index 0000000..f992440
--- /dev/null
+++ b/simpledb/materialize/RecordComparator.java
@@ -0,0 +1,44 @@
+package simpledb.materialize;
+
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * A comparator for scans.
+ * @author Edward Sciore
+ */
+public class RecordComparator implements Comparator<Scan> {
+   private List<String> fields;
+   
+   /**
+    * Creates a comparator using the specified fields,
+    * using the ordering implied by its iterator.
+    * @param fields a list of field names
+    */
+   public RecordComparator(List<String> fields) {
+      this.fields = fields;
+   }
+   
+   /**
+    * Compares the current records of the two specified scans.
+    * The sort fields are considered in turn.
+    * When a field is encountered for which the records have
+    * different values, those values are used as the result
+    * of the comparison.
+    * If the two records have the same values for all
+    * sort fields, then the method returns 0.
+    * @param s1 the first scan
+    * @param s2 the second scan
+    * @return the result of comparing each scan's current record according to the field list
+    */
+   public int compare(Scan s1, Scan s2) {
+      for (String fldname : fields) {
+         Constant val1 = s1.getVal(fldname);
+         Constant val2 = s2.getVal(fldname);
+         int result = val1.compareTo(val2);
+         if (result != 0)
+            return result;
+      }
+      return 0;
+   }
+}
diff --git a/simpledb/materialize/SortPlan.class b/simpledb/materialize/SortPlan.class
new file mode 100755
index 0000000..1af8009
Binary files /dev/null and b/simpledb/materialize/SortPlan.class differ
diff --git a/simpledb/materialize/SortPlan.java b/simpledb/materialize/SortPlan.java
new file mode 100755
index 0000000..6be8204
--- /dev/null
+++ b/simpledb/materialize/SortPlan.java
@@ -0,0 +1,153 @@
+package simpledb.materialize;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+
+import java.util.*;
+
+/**
+ * The Plan class for the <i>sort</i> operator.
+ * @author Edward Sciore
+ */
+public class SortPlan implements Plan {
+   private Plan p;
+   private Transaction tx;
+   private Schema sch;
+   private RecordComparator comp;
+   
+   /**
+    * Creates a sort plan for the specified query.
+    * @param p the plan for the underlying query
+    * @param sortfields the fields to sort by
+    * @param tx the calling transaction
+    */
+   public SortPlan(Plan p, List<String> sortfields, Transaction tx) {
+      this.p = p;
+      this.tx = tx;
+      sch = p.schema();
+      comp = new RecordComparator(sortfields);
+   }
+   
+   /**
+    * This method is where most of the action is.
+    * Up to 2 sorted temporary tables are created,
+    * and are passed into SortScan for final merging.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan src = p.open();
+      List<TempTable> runs = splitIntoRuns(src);
+      src.close();
+      while (runs.size() > 2)
+         runs = doAMergeIteration(runs);
+      return new SortScan(runs, comp);
+   }
+   
+   /**
+    * Returns the number of blocks in the sorted table,
+    * which is the same as it would be in a
+    * materialized table.
+    * It does <i>not</i> include the one-time cost
+    * of materializing and sorting the records.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      // does not include the one-time cost of sorting
+      Plan mp = new MaterializePlan(p, tx); // not opened; just for analysis
+      return mp.blocksAccessed();
+   }
+   
+   /**
+    * Returns the number of records in the sorted table,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p.recordsOutput();
+   }
+   
+   /**
+    * Returns the number of distinct field values in
+    * the sorted table, which is the same as in
+    * the underlying query.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      return p.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the sorted table, which
+    * is the same as in the underlying query.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return sch;
+   }
+   
+   private List<TempTable> splitIntoRuns(Scan src) {
+      List<TempTable> temps = new ArrayList<TempTable>();
+      src.beforeFirst();
+      if (!src.next())
+         return temps;
+      TempTable currenttemp = new TempTable(sch, tx);
+      temps.add(currenttemp);
+      UpdateScan currentscan = currenttemp.open();
+      while (copy(src, currentscan))
+         if (comp.compare(src, currentscan) < 0) {
+         // start a new run
+         currentscan.close();
+         currenttemp = new TempTable(sch, tx);
+         temps.add(currenttemp);
+         currentscan = (UpdateScan) currenttemp.open();
+      }
+      currentscan.close();
+      return temps;
+   }
+   
+   private List<TempTable> doAMergeIteration(List<TempTable> runs) {
+      List<TempTable> result = new ArrayList<TempTable>();
+      while (runs.size() > 1) {
+         TempTable p1 = runs.remove(0);
+         TempTable p2 = runs.remove(0);
+         result.add(mergeTwoRuns(p1, p2));
+      }
+      if (runs.size() == 1)
+         result.add(runs.get(0));
+      return result;
+   }
+   
+   private TempTable mergeTwoRuns(TempTable p1, TempTable p2) {
+      Scan src1 = p1.open();
+      Scan src2 = p2.open();
+      TempTable result = new TempTable(sch, tx);
+      UpdateScan dest = result.open();
+      
+      boolean hasmore1 = src1.next();
+      boolean hasmore2 = src2.next();
+      while (hasmore1 && hasmore2)
+         if (comp.compare(src1, src2) < 0)
+         hasmore1 = copy(src1, dest);
+      else
+         hasmore2 = copy(src2, dest);
+      
+      if (hasmore1)
+         while (hasmore1)
+         hasmore1 = copy(src1, dest);
+      else
+         while (hasmore2)
+         hasmore2 = copy(src2, dest);
+      src1.close();
+      src2.close();
+      dest.close();
+      return result;
+   }
+   
+   private boolean copy(Scan src, UpdateScan dest) {
+      dest.insert();
+      for (String fldname : sch.fields())
+         dest.setVal(fldname, src.getVal(fldname));
+      return src.next();
+   }
+}
diff --git a/simpledb/materialize/SortScan.class b/simpledb/materialize/SortScan.class
new file mode 100755
index 0000000..de54d78
Binary files /dev/null and b/simpledb/materialize/SortScan.class differ
diff --git a/simpledb/materialize/SortScan.java b/simpledb/materialize/SortScan.java
new file mode 100644
index 0000000..dcf8692
--- /dev/null
+++ b/simpledb/materialize/SortScan.java
@@ -0,0 +1,150 @@
+package simpledb.materialize;
+
+import simpledb.record.RID;
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * The Scan class for the <i>sort</i> operator.
+ * @author Edward Sciore
+ */
+/**
+ * @author sciore
+ *
+ */
+public class SortScan implements Scan {
+   private UpdateScan s1, s2=null, currentscan=null;
+   private RecordComparator comp;
+   private boolean hasmore1, hasmore2=false;
+   private List<RID> savedposition;
+   
+   /**
+    * Creates a sort scan, given a list of 1 or 2 runs.
+    * If there is only 1 run, then s2 will be null and
+    * hasmore2 will be false.
+    * @param runs the list of runs
+    * @param comp the record comparator
+    */
+   public SortScan(List<TempTable> runs, RecordComparator comp) {
+      this.comp = comp;
+      s1 = (UpdateScan) runs.get(0).open();
+      hasmore1 = s1.next();
+      if (runs.size() > 1) {
+         s2 = (UpdateScan) runs.get(1).open();
+         hasmore2 = s2.next();
+      }
+   }
+   
+   /**
+    * Positions the scan before the first record in sorted order.
+    * Internally, it moves to the first record of each underlying scan.
+    * The variable currentscan is set to null, indicating that there is
+    * no current scan.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      currentscan = null;
+      s1.beforeFirst();
+      hasmore1 = s1.next();
+      if (s2 != null) {
+         s2.beforeFirst();
+         hasmore2 = s2.next();
+      }
+   }
+   
+   /**
+    * Moves to the next record in sorted order.
+    * First, the current scan is moved to the next record.
+    * Then the lowest record of the two scans is found, and that
+    * scan is chosen to be the new current scan.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      if (currentscan != null) {
+         if (currentscan == s1)
+            hasmore1 = s1.next();
+         else if (currentscan == s2)
+            hasmore2 = s2.next();
+      }
+      
+      if (!hasmore1 && !hasmore2)
+         return false;
+      else if (hasmore1 && hasmore2) {
+         if (comp.compare(s1, s2) < 0)
+            currentscan = s1;
+         else
+            currentscan = s2;
+      }
+      else if (hasmore1)
+         currentscan = s1;
+      else if (hasmore2)
+         currentscan = s2;
+      return true;
+   }
+   
+   /**
+    * Closes the two underlying scans.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s1.close();
+      if (s2 != null)
+         s2.close();
+   }
+   
+   /**
+    * Gets the Constant value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      return currentscan.getVal(fldname);
+   }
+   
+   /**
+    * Gets the integer value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return currentscan.getInt(fldname);
+   }
+   
+   /**
+    * Gets the string value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return currentscan.getString(fldname);
+   }
+   
+   /**
+    * Returns true if the specified field is in the current scan.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return currentscan.hasField(fldname);
+   }
+   
+   /**
+    * Saves the position of the current record,
+    * so that it can be restored at a later time.
+    */
+   public void savePosition() {
+      RID rid1 = s1.getRid();
+      RID rid2 = (s2 == null) ? null : s2.getRid();
+      savedposition = Arrays.asList(rid1,rid2);
+   }
+   
+   /**
+    * Moves the scan to its previously-saved position.
+    */
+   public void restorePosition() {
+      RID rid1 = savedposition.get(0);
+      RID rid2 = savedposition.get(1);
+      s1.moveToRid(rid1);
+      if (rid2 != null)
+         s2.moveToRid(rid2);
+   }
+}
diff --git a/simpledb/materialize/SortScan.java~ b/simpledb/materialize/SortScan.java~
new file mode 100644
index 0000000..48e2dfe
--- /dev/null
+++ b/simpledb/materialize/SortScan.java~
@@ -0,0 +1,155 @@
+package simpledb.materialize;
+
+import simpledb.record.RID;
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * The Scan class for the <i>sort</i> operator.
+ * @author Edward Sciore
+ */
+/**
+ * @author sciore
+ *
+ */
+public class SortScan implements Scan {
+   private UpdateScan s1, s2=null, currentscan=null;
+   private RecordComparator comp;
+   private boolean hasmore1, hasmore2=false;
+   private List<RID> savedposition;
+   
+   /**
+    * Creates a sort scan, given a list of 1 or 2 runs.
+    * If there is only 1 run, then s2 will be null and
+    * hasmore2 will be false.
+    * @param runs the list of runs
+    * @param comp the record comparator
+    */
+   public SortScan(List<TempTable> runs, RecordComparator comp) {
+      this.comp = comp;
+      s1 = (UpdateScan) runs.get(0).open();
+      hasmore1 = s1.next();
+      if (runs.size() > 1) {
+         s2 = (UpdateScan) runs.get(1).open();
+         hasmore2 = s2.next();
+      }
+   }
+   
+   /**
+    * Positions the scan before the first record in sorted order.
+    * Internally, it moves to the first record of each underlying scan.
+    * The variable currentscan is set to null, indicating that there is
+    * no current scan.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      currentscan = null;
+      s1.beforeFirst();
+      hasmore1 = s1.next();
+      if (s2 != null) {
+         s2.beforeFirst();
+         hasmore2 = s2.next();
+      }
+   }
+   
+   /**
+    * Moves to the next record in sorted order.
+    * First, the current scan is moved to the next record.
+    * Then the lowest record of the two scans is found, and that
+    * scan is chosen to be the new current scan.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      if (currentscan != null) {
+         if (currentscan == s1)
+            hasmore1 = s1.next();
+         else if (currentscan == s2)
+            hasmore2 = s2.next();
+      }
+      
+      if (!hasmore1 && !hasmore2)
+         return false;
+      else if (hasmore1 && hasmore2) {
+         if (comp.compare(s1, s2) < 0)
+            currentscan = s1;
+         else
+            currentscan = s2;
+      }
+      else if (hasmore1)
+         currentscan = s1;
+      else if (hasmore2)
+         currentscan = s2;
+      return true;
+   }
+   
+   /**
+    * Closes the two underlying scans.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s1.close();
+      if (s2 != null)
+         s2.close();
+   }
+   
+   /**
+    * Gets the Constant value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      return currentscan.getVal(fldname);
+   }
+   
+   /**
+    * Gets the integer value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return currentscan.getInt(fldname);
+   }
+   
+   /**
+    * Gets the string value of the specified field
+    * of the current scan.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return currentscan.getString(fldname);
+   }
+   
+   /**
+    * Returns true if the specified field is in the current scan.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return currentscan.hasField(fldname);
+   }
+   
+   /**
+    * Saves the position of the current record,
+    * so that it can be restored at a later time.
+    */
+   public void savePosition() {
+      if (currentscan == null)
+        savedposition = null;
+      else {
+        RID rid1 = s1.getRid();
+        RID rid2 = s2.getRid();
+        savedposition = Arrays.asList(rid1,rid2);
+      }
+   }
+   
+   /**
+    * Moves the scan to its previously-saved position.
+    */
+   public void restorePosition() {
+     if (currentscan != null) {
+       RID rid1 = savedposition.get(0);
+       RID rid2 = savedposition.get(1);
+       s1.moveToRid(rid1);
+       s2.moveToRid(rid2);
+     }
+   }
+}
diff --git a/simpledb/materialize/TempTable.class b/simpledb/materialize/TempTable.class
new file mode 100755
index 0000000..05623f7
Binary files /dev/null and b/simpledb/materialize/TempTable.class differ
diff --git a/simpledb/materialize/TempTable.java b/simpledb/materialize/TempTable.java
new file mode 100755
index 0000000..4107ea9
--- /dev/null
+++ b/simpledb/materialize/TempTable.java
@@ -0,0 +1,50 @@
+package simpledb.materialize;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.query.*;
+
+/**
+ * A class that creates temporary tables.
+ * A temporary table is not registered in the catalog.
+ * The class therefore has a method getTableInfo to return the 
+ * table's metadata. 
+ * @author Edward Sciore
+ */
+public class TempTable {
+   private static int nextTableNum = 0;
+   private TableInfo ti;
+   private Transaction tx;
+   
+   /**
+    * Allocates a name for for a new temporary table
+    * having the specified schema.
+    * @param sch the new table's schema
+    * @param tx the calling transaction
+    */
+   public TempTable(Schema sch, Transaction tx) {
+      String tblname = nextTableName();
+      ti = new TableInfo(tblname, sch);
+      this.tx = tx;
+   }
+   
+   /**
+    * Opens a table scan for the temporary table.
+    */
+   public UpdateScan open() {
+      return new TableScan(ti, tx);
+   }
+   
+   /**
+    * Return the table's metadata.
+    * @return the table's metadata
+    */
+   public TableInfo getTableInfo() {
+      return ti;
+   }
+   
+   private static synchronized String nextTableName() {
+      nextTableNum++;
+      return "temp" + nextTableNum;
+   }
+}
\ No newline at end of file
diff --git a/simpledb/metadata/.DS_Store b/simpledb/metadata/.DS_Store
new file mode 100644
index 0000000..5008ddf
Binary files /dev/null and b/simpledb/metadata/.DS_Store differ
diff --git a/simpledb/metadata/IndexInfo.class b/simpledb/metadata/IndexInfo.class
new file mode 100755
index 0000000..7421f00
Binary files /dev/null and b/simpledb/metadata/IndexInfo.class differ
diff --git a/simpledb/metadata/IndexInfo.java b/simpledb/metadata/IndexInfo.java
new file mode 100644
index 0000000..7b599c2
--- /dev/null
+++ b/simpledb/metadata/IndexInfo.java
@@ -0,0 +1,116 @@
+package simpledb.metadata;
+
+import static java.sql.Types.INTEGER;
+import static simpledb.file.Page.BLOCK_SIZE;
+import simpledb.server.SimpleDB;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.index.Index;
+import simpledb.index.hash.HashIndex; 
+import simpledb.index.btree.BTreeIndex; //in case we change to btree indexing
+
+
+/**
+ * The information about an index.
+ * This information is used by the query planner in order to
+ * estimate the costs of using the index,
+ * and to obtain the schema of the index records.
+ * Its methods are essentially the same as those of Plan.
+ * @author Edward Sciore
+ */
+public class IndexInfo {
+   private String idxname, fldname;
+   private Transaction tx;
+   private TableInfo ti;
+   private StatInfo si;
+   
+   /**
+    * Creates an IndexInfo object for the specified index.
+    * @param idxname the name of the index
+    * @param tblname the name of the table
+    * @param fldname the name of the indexed field
+    * @param tx the calling transaction
+    */
+   public IndexInfo(String idxname, String tblname, String fldname,
+                    Transaction tx) {
+      this.idxname = idxname;
+      this.fldname = fldname;
+      this.tx = tx;
+      ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
+      si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
+   }
+   
+   /**
+    * Opens the index described by this object.
+    * @return the Index object associated with this information
+    */
+   public Index open() {
+      Schema sch = schema();
+      // Create new HashIndex for hash indexing
+      return new HashIndex(idxname, sch, tx);
+   }
+   
+   /**
+    * Estimates the number of block accesses required to
+    * find all index records having a particular search key.
+    * The method uses the table's metadata to estimate the
+    * size of the index file and the number of index records
+    * per block.
+    * It then passes this information to the traversalCost
+    * method of the appropriate index type,
+    * which provides the estimate.
+    * @return the number of block accesses required to traverse the index
+    */
+   public int blocksAccessed() {
+      TableInfo idxti = new TableInfo("", schema());
+      int rpb = BLOCK_SIZE / idxti.recordLength();
+      int numblocks = si.recordsOutput() / rpb;
+      // Call HashIndex.searchCost for hash indexing
+      return HashIndex.searchCost(numblocks, rpb);
+   }
+   
+   /**
+    * Returns the estimated number of records having a
+    * search key.  This value is the same as doing a select
+    * query; that is, it is the number of records in the table
+    * divided by the number of distinct values of the indexed field.
+    * @return the estimated number of records having a search key
+    */
+   public int recordsOutput() {
+      return si.recordsOutput() / si.distinctValues(fldname);
+   }
+   
+   /** 
+    * Returns the distinct values for a specified field 
+    * in the underlying table, or 1 for the indexed field.
+    * @param fname the specified field
+    */
+   public int distinctValues(String fname) {
+      if (fldname.equals(fname))
+         return 1;
+      else 
+         return Math.min(si.distinctValues(fldname), recordsOutput());
+   }
+   
+   /**
+    * Returns the schema of the index records.
+    * The schema consists of the dataRID (which is
+    * represented as two integers, the block number and the
+    * record ID) and the dataval (which is the indexed field).
+    * Schema information about the indexed field is obtained
+    * via the table's metadata.
+    * @return the schema of the index records
+    */
+   private Schema schema() {
+      Schema sch = new Schema();
+      sch.addIntField("block");
+      sch.addIntField("id");
+      if (ti.schema().type(fldname) == INTEGER)
+         sch.addIntField("dataval");
+      else {
+         int fldlen = ti.schema().length(fldname);
+         sch.addStringField("dataval", fldlen);
+      }
+      return sch;
+   }
+}
diff --git a/simpledb/metadata/IndexMgr.class b/simpledb/metadata/IndexMgr.class
new file mode 100755
index 0000000..0af5415
Binary files /dev/null and b/simpledb/metadata/IndexMgr.class differ
diff --git a/simpledb/metadata/IndexMgr.java b/simpledb/metadata/IndexMgr.java
new file mode 100755
index 0000000..9f11b89
--- /dev/null
+++ b/simpledb/metadata/IndexMgr.java
@@ -0,0 +1,72 @@
+package simpledb.metadata;
+
+import static simpledb.metadata.TableMgr.MAX_NAME;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import java.util.*;
+
+/**
+ * The index manager.
+ * The index manager has similar functionalty to the table manager.
+ * @author Edward Sciore
+ */
+public class IndexMgr {
+   private TableInfo ti;
+   
+   /**
+    * Creates the index manager.
+    * This constructor is called during system startup.
+    * If the database is new, then the <i>idxcat</i> table is created.
+    * @param isnew indicates whether this is a new database
+    * @param tx the system startup transaction
+    */
+   public IndexMgr(boolean isnew, TableMgr tblmgr, Transaction tx) {
+      if (isnew) {
+         Schema sch = new Schema();
+         sch.addStringField("indexname", MAX_NAME);
+         sch.addStringField("tablename", MAX_NAME);
+         sch.addStringField("fieldname", MAX_NAME);
+         tblmgr.createTable("idxcat", sch, tx);
+      }
+      ti = tblmgr.getTableInfo("idxcat", tx);
+   }
+   
+   /**
+    * Creates an index of the specified type for the specified field.
+    * A unique ID is assigned to this index, and its information
+    * is stored in the idxcat table.
+    * @param idxname the name of the index
+    * @param tblname the name of the indexed table
+    * @param fldname the name of the indexed field
+    * @param tx the calling transaction
+    */
+   public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
+      RecordFile rf = new RecordFile(ti, tx);
+      rf.insert();
+      rf.setString("indexname", idxname);
+      rf.setString("tablename", tblname);
+      rf.setString("fieldname", fldname);
+      rf.close();
+   }
+   
+   /**
+    * Returns a map containing the index info for all indexes
+    * on the specified table.
+    * @param tblname the name of the table
+    * @param tx the calling transaction
+    * @return a map of IndexInfo objects, keyed by their field names
+    */
+   public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
+      Map<String,IndexInfo> result = new HashMap<String,IndexInfo>();
+      RecordFile rf = new RecordFile(ti, tx);
+      while (rf.next())
+         if (rf.getString("tablename").equals(tblname)) {
+         String idxname = rf.getString("indexname");
+         String fldname = rf.getString("fieldname");
+         IndexInfo ii = new IndexInfo(idxname, tblname, fldname, tx);
+         result.put(fldname, ii);
+      }
+      rf.close();
+      return result;
+   }
+}
diff --git a/simpledb/metadata/MetadataMgr.class b/simpledb/metadata/MetadataMgr.class
new file mode 100755
index 0000000..5019e65
Binary files /dev/null and b/simpledb/metadata/MetadataMgr.class differ
diff --git a/simpledb/metadata/MetadataMgr.java b/simpledb/metadata/MetadataMgr.java
new file mode 100755
index 0000000..f2aa8ef
--- /dev/null
+++ b/simpledb/metadata/MetadataMgr.java
@@ -0,0 +1,47 @@
+package simpledb.metadata;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import java.util.Map;
+
+public class MetadataMgr {
+   private static TableMgr  tblmgr;
+   private static ViewMgr   viewmgr;
+   private static StatMgr   statmgr;
+   private static IndexMgr  idxmgr;
+   
+   public MetadataMgr(boolean isnew, Transaction tx) {
+      tblmgr  = new TableMgr(isnew, tx);
+      viewmgr = new ViewMgr(isnew, tblmgr, tx);
+      statmgr = new StatMgr(tblmgr, tx);
+      idxmgr  = new IndexMgr(isnew, tblmgr, tx);
+   }
+   
+   public void createTable(String tblname, Schema sch, Transaction tx) {
+      tblmgr.createTable(tblname, sch, tx);
+   }
+   
+   public TableInfo getTableInfo(String tblname, Transaction tx) {
+      return tblmgr.getTableInfo(tblname, tx);
+   }
+   
+   public void createView(String viewname, String viewdef, Transaction tx) {
+      viewmgr.createView(viewname, viewdef, tx);
+   }
+   
+   public String getViewDef(String viewname, Transaction tx) {
+      return viewmgr.getViewDef(viewname, tx);
+   }
+   
+   public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
+      idxmgr.createIndex(idxname, tblname, fldname, tx);
+   }
+   
+   public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
+      return idxmgr.getIndexInfo(tblname, tx);
+   }
+   
+   public StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
+      return statmgr.getStatInfo(tblname, ti, tx);
+   }
+}
diff --git a/simpledb/metadata/StatInfo.class b/simpledb/metadata/StatInfo.class
new file mode 100755
index 0000000..188d946
Binary files /dev/null and b/simpledb/metadata/StatInfo.class differ
diff --git a/simpledb/metadata/StatInfo.java b/simpledb/metadata/StatInfo.java
new file mode 100755
index 0000000..198ea2b
--- /dev/null
+++ b/simpledb/metadata/StatInfo.java
@@ -0,0 +1,52 @@
+package simpledb.metadata;
+
+/**
+ * Holds three pieces of statistical information about a table:
+ * the number of blocks, the number of records,
+ * and the number of distinct values for each field. 
+ * @author Edward Sciore
+ */
+public class StatInfo {
+   private int numBlocks;
+   private int numRecs;
+   
+   /**
+    * Creates a StatInfo object.
+    * Note that the number of distinct values is not
+    * passed into the constructor.
+    * The object fakes this value.
+    * @param numblocks the number of blocks in the table
+    * @param numrecs the number of records in the table
+    */
+   public StatInfo(int numblocks, int numrecs) {
+      this.numBlocks = numblocks;
+      this.numRecs   = numrecs;
+   }
+   
+   /**
+    * Returns the estimated number of blocks in the table.
+    * @return the estimated number of blocks in the table
+    */
+   public int blocksAccessed() {
+      return numBlocks;
+   }
+   
+   /**
+    * Returns the estimated number of records in the table.
+    * @return the estimated number of records in the table
+    */
+   public int recordsOutput() {
+      return numRecs;
+   }
+   
+   /**
+    * Returns the estimated number of distinct values
+    * for the specified field.
+    * In actuality, this estimate is a complete guess.
+    * @param fldname the name of the field
+    * @return a guess as to the number of distinct field values
+    */
+   public int distinctValues(String fldname) {
+      return 1 + (numRecs / 3);
+   }
+}
diff --git a/simpledb/metadata/StatMgr.class b/simpledb/metadata/StatMgr.class
new file mode 100755
index 0000000..a67122d
Binary files /dev/null and b/simpledb/metadata/StatMgr.class differ
diff --git a/simpledb/metadata/StatMgr.java b/simpledb/metadata/StatMgr.java
new file mode 100755
index 0000000..e128c6a
--- /dev/null
+++ b/simpledb/metadata/StatMgr.java
@@ -0,0 +1,75 @@
+package simpledb.metadata;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import java.util.*;
+
+/**
+ * The statistics manager, which is responsible for
+ * keeping statistical information about each table.
+ * The manager does not store this information in the database.
+ * Instead, it calculates this information on system startup,
+ * and periodically refreshes it.
+ * @author Edward Sciore
+ */
+class StatMgr {
+   private TableMgr tblMgr;
+   private Map<String,StatInfo> tablestats;
+   private int numcalls;
+   
+   /**
+    * Creates the statistics manager.
+    * The initial statistics are calculated by
+    * traversing the entire database.
+    * @param tx the startup transaction
+    */
+   public StatMgr(TableMgr tblMgr, Transaction tx) {
+      this.tblMgr = tblMgr;
+      refreshStatistics(tx);
+   }
+   
+   /**
+    * Returns the statistical information about the specified table.
+    * @param tblname the name of the table
+    * @param ti the table's metadata
+    * @param tx the calling transaction
+    * @return the statistical information about the table
+    */
+   public synchronized StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
+      numcalls++;
+      if (numcalls > 100)
+         refreshStatistics(tx);
+      StatInfo si = tablestats.get(tblname);
+      if (si == null) {
+         si = calcTableStats(ti, tx);
+         tablestats.put(tblname, si);
+      }
+      return si;
+   }
+   
+   private synchronized void refreshStatistics(Transaction tx) {
+      tablestats = new HashMap<String,StatInfo>();
+      numcalls = 0;
+      TableInfo tcatmd = tblMgr.getTableInfo("tblcat", tx);
+      RecordFile tcatfile = new RecordFile(tcatmd, tx);
+      while(tcatfile.next()) {
+         String tblname = tcatfile.getString("tblname");
+         TableInfo md = tblMgr.getTableInfo(tblname, tx);
+         StatInfo si = calcTableStats(md, tx);
+         tablestats.put(tblname, si);
+      }
+      tcatfile.close();
+   }
+   
+   private synchronized StatInfo calcTableStats(TableInfo ti, Transaction tx) {
+      int numRecs = 0;
+      RecordFile rf = new RecordFile(ti, tx);
+      int numblocks = 0;
+      while (rf.next()) {
+         numRecs++;
+         numblocks = rf.currentRid().blockNumber() + 1;
+      }
+      rf.close();
+      return new StatInfo(numblocks, numRecs);
+   }
+}
diff --git a/simpledb/metadata/TableMgr.class b/simpledb/metadata/TableMgr.class
new file mode 100755
index 0000000..99b887b
Binary files /dev/null and b/simpledb/metadata/TableMgr.class differ
diff --git a/simpledb/metadata/TableMgr.java b/simpledb/metadata/TableMgr.java
new file mode 100755
index 0000000..9f8b1b9
--- /dev/null
+++ b/simpledb/metadata/TableMgr.java
@@ -0,0 +1,112 @@
+package simpledb.metadata;
+
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import java.util.*;
+
+/**
+ * The table manager.
+ * There are methods to create a table, save the metadata
+ * in the catalog, and obtain the metadata of a
+ * previously-created table.
+ * @author Edward Sciore
+ *
+ */
+public class TableMgr {
+   /**
+    * The maximum number of characters in any
+    * tablename or fieldname.
+    * Currently, this value is 16.
+    */
+   public static final int MAX_NAME = 16;
+   
+   private TableInfo tcatInfo, fcatInfo;
+   
+   /**
+    * Creates a new catalog manager for the database system.
+    * If the database is new, then the two catalog tables
+    * are created.
+    * @param isNew has the value true if the database is new
+    * @param tx the startup transaction
+    */
+   public TableMgr(boolean isNew, Transaction tx) {
+      Schema tcatSchema = new Schema();
+      tcatSchema.addStringField("tblname", MAX_NAME);
+      tcatSchema.addIntField("reclength");
+      tcatInfo = new TableInfo("tblcat", tcatSchema);
+      
+      Schema fcatSchema = new Schema();
+      fcatSchema.addStringField("tblname", MAX_NAME);
+      fcatSchema.addStringField("fldname", MAX_NAME);
+      fcatSchema.addIntField("type");
+      fcatSchema.addIntField("length");
+      fcatSchema.addIntField("offset");
+      fcatInfo = new TableInfo("fldcat", fcatSchema);
+      
+      if (isNew) {
+         createTable("tblcat", tcatSchema, tx);
+         createTable("fldcat", fcatSchema, tx);
+      }
+   }
+   
+   /**
+    * Creates a new table having the specified name and schema.
+    * @param tblname the name of the new table
+    * @param sch the table's schema
+    * @param tx the transaction creating the table
+    */
+   public void createTable(String tblname, Schema sch, Transaction tx) {
+      TableInfo ti = new TableInfo(tblname, sch);
+      // insert one record into tblcat
+      RecordFile tcatfile = new RecordFile(tcatInfo, tx);
+      tcatfile.insert();
+      tcatfile.setString("tblname", tblname);
+      tcatfile.setInt("reclength", ti.recordLength());
+      tcatfile.close();
+      
+      // insert a record into fldcat for each field
+      RecordFile fcatfile = new RecordFile(fcatInfo, tx);
+      for (String fldname : sch.fields()) {
+         fcatfile.insert();
+         fcatfile.setString("tblname", tblname);
+         fcatfile.setString("fldname", fldname);
+         fcatfile.setInt   ("type",   sch.type(fldname));
+         fcatfile.setInt   ("length", sch.length(fldname));
+         fcatfile.setInt   ("offset", ti.offset(fldname));
+      }
+      fcatfile.close();
+   }
+   
+   /**
+    * Retrieves the metadata for the specified table
+    * out of the catalog.
+    * @param tblname the name of the table
+    * @param tx the transaction
+    * @return the table's stored metadata
+    */
+   public TableInfo getTableInfo(String tblname, Transaction tx) {
+      RecordFile tcatfile = new RecordFile(tcatInfo, tx);
+      int reclen = -1;
+      while (tcatfile.next())
+         if(tcatfile.getString("tblname").equals(tblname)) {
+         reclen = tcatfile.getInt("reclength");
+         break;
+      }
+      tcatfile.close();
+      
+      RecordFile fcatfile = new RecordFile(fcatInfo, tx);
+      Schema sch = new Schema();
+      Map<String,Integer> offsets = new HashMap<String,Integer>();
+      while (fcatfile.next())
+         if (fcatfile.getString("tblname").equals(tblname)) {
+         String fldname = fcatfile.getString("fldname");
+         int fldtype    = fcatfile.getInt("type");
+         int fldlen     = fcatfile.getInt("length");
+         int offset     = fcatfile.getInt("offset");
+         offsets.put(fldname, offset);
+         sch.addField(fldname, fldtype, fldlen);
+      }
+      fcatfile.close();
+      return new TableInfo(tblname, sch, offsets, reclen);
+   }
+}
\ No newline at end of file
diff --git a/simpledb/metadata/ViewMgr.class b/simpledb/metadata/ViewMgr.class
new file mode 100755
index 0000000..c1f3a99
Binary files /dev/null and b/simpledb/metadata/ViewMgr.class differ
diff --git a/simpledb/metadata/ViewMgr.java b/simpledb/metadata/ViewMgr.java
new file mode 100755
index 0000000..9b60e8f
--- /dev/null
+++ b/simpledb/metadata/ViewMgr.java
@@ -0,0 +1,41 @@
+package simpledb.metadata;
+
+import simpledb.record.*;
+import simpledb.tx.Transaction;
+
+class ViewMgr {
+   private static final int MAX_VIEWDEF = 100;
+   TableMgr tblMgr;
+   
+   public ViewMgr(boolean isNew, TableMgr tblMgr, Transaction tx) {
+      this.tblMgr = tblMgr;
+      if (isNew) {
+         Schema sch = new Schema();
+         sch.addStringField("viewname", TableMgr.MAX_NAME);
+         sch.addStringField("viewdef", MAX_VIEWDEF);
+         tblMgr.createTable("viewcat", sch, tx);
+      }
+   }
+   
+   public void createView(String vname, String vdef, Transaction tx) {
+      TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
+      RecordFile rf = new RecordFile(ti, tx);
+      rf.insert();
+      rf.setString("viewname", vname);
+      rf.setString("viewdef", vdef);
+      rf.close();
+   }
+   
+   public String getViewDef(String vname, Transaction tx) {
+      String result = null;
+      TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
+      RecordFile rf = new RecordFile(ti, tx);
+      while (rf.next())
+         if (rf.getString("viewname").equals(vname)) {
+         result = rf.getString("viewdef");
+         break;
+      }
+      rf.close();
+      return result;
+   }
+}
diff --git a/simpledb/multibuffer/BufferNeeds.class b/simpledb/multibuffer/BufferNeeds.class
new file mode 100755
index 0000000..de2c5e2
Binary files /dev/null and b/simpledb/multibuffer/BufferNeeds.class differ
diff --git a/simpledb/multibuffer/BufferNeeds.java b/simpledb/multibuffer/BufferNeeds.java
new file mode 100755
index 0000000..f8ab1e5
--- /dev/null
+++ b/simpledb/multibuffer/BufferNeeds.java
@@ -0,0 +1,54 @@
+package simpledb.multibuffer;
+
+import simpledb.server.SimpleDB;
+
+/**
+ * A class containing static methods,
+ * which estimate the optimal number of buffers
+ * to allocate for a scan.
+ * @author Edward Sciore
+ */
+public class BufferNeeds {
+   
+   /**
+    * This method considers the various roots
+    * of the specified output size (in blocks),
+    * and returns the highest root that is less than
+    * the number of available buffers.
+    * @param size the size of the output file
+    * @return the highest number less than the number of available buffers, that is a root of the plan's output size
+    */
+   public static int bestRoot(int size) {
+      int avail = SimpleDB.bufferMgr().available();
+      if (avail <= 1)
+         return 1;
+      int k = Integer.MAX_VALUE;
+      double i = 1.0;
+      while (k > avail) {
+         i++;
+         k = (int)Math.ceil(Math.pow(size, 1/i));
+      }
+      return k;
+   }
+   
+   /**
+    * This method considers the various factors
+    * of the specified output size (in blocks),
+    * and returns the highest factor that is less than
+    * the number of available buffers.
+    * @param size the size of the output file
+    * @return the highest number less than the number of available buffers, that is a factor of the plan's output size
+    */
+   public static int bestFactor(int size) {
+      int avail = SimpleDB.bufferMgr().available();
+      if (avail <= 1)
+         return 1;
+      int k = size;
+      double i = 1.0;
+      while (k > avail) {
+         i++;
+         k = (int)Math.ceil(size / i);
+      }
+      return k;
+   }
+}
diff --git a/simpledb/multibuffer/ChunkScan.class b/simpledb/multibuffer/ChunkScan.class
new file mode 100755
index 0000000..a88cdf0
Binary files /dev/null and b/simpledb/multibuffer/ChunkScan.class differ
diff --git a/simpledb/multibuffer/ChunkScan.java b/simpledb/multibuffer/ChunkScan.java
new file mode 100755
index 0000000..b0b4cb8
--- /dev/null
+++ b/simpledb/multibuffer/ChunkScan.java
@@ -0,0 +1,111 @@
+package simpledb.multibuffer;
+
+import static java.sql.Types.INTEGER;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.file.Block;
+import simpledb.query.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The class for the <i>chunk</i> operator.
+ * @author Edward Sciore
+ */
+public class ChunkScan implements Scan {
+   private List<RecordPage> pages;
+   private int startbnum, endbnum, current;
+   private Schema sch;
+   private RecordPage rp;
+   
+   /**
+    * Creates a chunk consisting of the specified pages. 
+    * @param ti the metadata for the chunked table
+    * @param startbnum the starting block number
+    * @param endbnum  the ending block number
+    * @param tx the current transaction
+    */ 
+   public ChunkScan(TableInfo ti, int startbnum, int endbnum, Transaction tx) {
+      pages = new ArrayList<RecordPage>();
+      this.startbnum = startbnum;
+      this.endbnum   = endbnum;
+      this.sch = ti.schema();
+      String filename = ti.fileName();
+      for (int i=startbnum; i<=endbnum; i++) {
+         Block blk = new Block(filename, i);
+         pages.add(new RecordPage(blk, ti, tx));
+      }
+      beforeFirst();
+   }
+   
+   
+   /**
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      moveToBlock(startbnum);
+   }
+   
+   /**
+    * Moves to the next record in the current block of the chunk.
+    * If there are no more records, then make
+    * the next block be current.
+    * If there are no more blocks in the chunk, return false.
+    * @see simpledb.query.Scan#next()  
+    */
+   public boolean next() {
+      while (true) {
+         if (rp.next())
+            return true;
+         if (current == endbnum)
+            return false;
+         moveToBlock(current+1);
+      }
+   }
+   
+   /**
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      for (RecordPage r : pages)
+         r.close();
+   }
+   
+   /**
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (sch.type(fldname) == INTEGER)
+         return new IntConstant(rp.getInt(fldname));
+      else
+         return new StringConstant(rp.getString(fldname));
+   }
+   
+   /**
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return rp.getInt(fldname);
+   }
+   
+   /**
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return rp.getString(fldname);
+   }
+   
+   /**
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return sch.hasField(fldname);
+   }
+   
+   private void moveToBlock(int blknum) {
+      current = blknum;
+      rp = pages.get(current - startbnum);
+      rp.moveToId(-1);
+   }
+}
\ No newline at end of file
diff --git a/simpledb/multibuffer/MultiBufferProductPlan.class b/simpledb/multibuffer/MultiBufferProductPlan.class
new file mode 100755
index 0000000..4975a63
Binary files /dev/null and b/simpledb/multibuffer/MultiBufferProductPlan.class differ
diff --git a/simpledb/multibuffer/MultiBufferProductPlan.java b/simpledb/multibuffer/MultiBufferProductPlan.java
new file mode 100755
index 0000000..2a8b354
--- /dev/null
+++ b/simpledb/multibuffer/MultiBufferProductPlan.java
@@ -0,0 +1,116 @@
+package simpledb.multibuffer;
+
+import simpledb.server.SimpleDB;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+import simpledb.materialize.*;
+import simpledb.query.*;
+
+/**
+ * The Plan class for the muti-buffer version of the
+ * <i>product</i> operator.
+ * @author Edward Sciore
+ */
+public class MultiBufferProductPlan implements Plan {
+   private Plan lhs, rhs;
+   private Transaction tx;
+   private Schema schema = new Schema();
+   
+   /**
+    * Creates a product plan for the specified queries.
+    * @param lhs the plan for the LHS query
+    * @param rhs the plan for the RHS query
+    * @param tx the calling transaction
+    */
+   public MultiBufferProductPlan(Plan lhs, Plan rhs, Transaction tx) {
+      this.lhs = lhs;
+      this.rhs = rhs;
+      this.tx = tx;
+      schema.addAll(lhs.schema());
+      schema.addAll(rhs.schema());
+   }
+   
+   /**
+    * A scan for this query is created and returned, as follows.
+    * First, the method materializes its RHS query.
+    * It then determines the optimal chunk size,
+    * based on the size of the materialized file and the
+    * number of available buffers.
+    * It creates a chunk plan for each chunk, saving them in a list.
+    * Finally, it creates a multiscan for this list of plans,
+    * and returns that scan.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      TempTable tt = copyRecordsFrom(rhs);
+      TableInfo ti = tt.getTableInfo();
+      Scan leftscan = lhs.open();
+      return new MultiBufferProductScan(leftscan, ti, tx);
+   }
+   
+   /**
+    * Returns an estimate of the number of block accesses
+    * required to execute the query. The formula is:
+    * <pre> B(product(p1,p2)) = B(p2) + B(p1)*C(p2) </pre>
+    * where C(p2) is the number of chunks of p2.
+    * The method uses the current number of available buffers
+    * to calculate C(p2), and so this value may differ
+    * when the query scan is opened.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      // this guesses at the # of chunks
+      int avail = SimpleDB.bufferMgr().available();
+      int size = new MaterializePlan(rhs, tx).blocksAccessed();
+      int numchunks = size / avail;
+      return rhs.blocksAccessed() +
+         (lhs.blocksAccessed() * numchunks);
+   }
+   
+   /**
+    * Estimates the number of output records in the product.
+    * The formula is:
+    * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return lhs.recordsOutput() * rhs.recordsOutput();
+   }
+   
+   /**
+    * Estimates the distinct number of field values in the product.
+    * Since the product does not increase or decrease field values,
+    * the estimate is the same as in the appropriate underlying query.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (lhs.schema().hasField(fldname))
+         return lhs.distinctValues(fldname);
+      else
+         return rhs.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the product,
+    * which is the union of the schemas of the underlying queries.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return schema;
+   }
+   
+   private TempTable copyRecordsFrom(Plan p) {
+      Scan   src = p.open(); 
+      Schema sch = p.schema();
+      TempTable tt = new TempTable(sch, tx);
+      UpdateScan dest = (UpdateScan) tt.open();
+      while (src.next()) {
+         dest.insert();
+         for (String fldname : sch.fields())
+            dest.setVal(fldname, src.getVal(fldname));
+      }
+      src.close();
+      dest.close();
+      return tt;
+   }
+}
diff --git a/simpledb/multibuffer/MultiBufferProductScan.class b/simpledb/multibuffer/MultiBufferProductScan.class
new file mode 100755
index 0000000..2e372f0
Binary files /dev/null and b/simpledb/multibuffer/MultiBufferProductScan.class differ
diff --git a/simpledb/multibuffer/MultiBufferProductScan.java b/simpledb/multibuffer/MultiBufferProductScan.java
new file mode 100755
index 0000000..3fc21d3
--- /dev/null
+++ b/simpledb/multibuffer/MultiBufferProductScan.java
@@ -0,0 +1,122 @@
+package simpledb.multibuffer;
+
+import simpledb.tx.Transaction;
+import simpledb.record.TableInfo;
+import simpledb.query.*;
+
+/** 
+ * The Scan class for the muti-buffer version of the
+ * <i>product</i> operator.
+ * @author Edward Sciore
+ */
+public class MultiBufferProductScan implements Scan {
+   private Scan lhsscan, rhsscan=null, prodscan;
+   private TableInfo ti;
+   private Transaction tx;
+   private int chunksize, nextblknum, filesize;
+   
+   
+   /**
+    * Creates the scan class for the product of the LHS scan and a table.
+    * @param lhsscan the LHS scan
+    * @param ti the metadata for the RHS table
+    * @param tx the current transaction
+    */
+   public MultiBufferProductScan(Scan lhsscan, TableInfo ti, Transaction tx) {
+      this.lhsscan = lhsscan;
+      this.ti = ti;
+      this.tx = tx;
+      filesize = tx.size(ti.fileName());
+      chunksize = BufferNeeds.bestFactor(filesize);
+      beforeFirst();
+   }
+   
+   /**
+    * Positions the scan before the first record.
+    * That is, the LHS scan is positioned at its first record,
+    * and the RHS scan is positioned before the first record of the first chunk.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      nextblknum = 0;
+      useNextChunk();
+   }
+   
+   /**
+    * Moves to the next record in the current scan.
+    * If there are no more records in the current chunk,
+    * then move to the next LHS record and the beginning of that chunk.
+    * If there are no more LHS records, then move to the next chunk
+    * and begin again.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      while (!prodscan.next()) 
+         if (!useNextChunk())
+         return false;
+      return true;
+   }
+   
+   /**
+    * Closes the current scans.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      prodscan.close();
+   }
+   
+   /** 
+    * Returns the value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      return prodscan.getVal(fldname);
+   }
+   
+   /** 
+    * Returns the integer value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      return prodscan.getInt(fldname);
+   }
+   
+   /** 
+    * Returns the string value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      return prodscan.getString(fldname);
+   }
+   
+   /**
+    * Returns true if the specified field is in
+    * either of the underlying scans.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return prodscan.hasField(fldname);
+   }
+   
+   private boolean useNextChunk() {
+      if (rhsscan != null)
+         rhsscan.close();
+      if (nextblknum >= filesize)
+         return false;
+      int end = nextblknum + chunksize - 1;
+      if (end >= filesize)
+         end = filesize - 1;
+      rhsscan = new ChunkScan(ti, nextblknum, end, tx);
+      lhsscan.beforeFirst();
+      prodscan = new ProductScan(lhsscan, rhsscan);
+      nextblknum = end + 1;
+      return true;
+   }
+}
+
diff --git a/simpledb/opt/HeuristicQueryPlanner.class b/simpledb/opt/HeuristicQueryPlanner.class
new file mode 100755
index 0000000..63b6e8f
Binary files /dev/null and b/simpledb/opt/HeuristicQueryPlanner.class differ
diff --git a/simpledb/opt/HeuristicQueryPlanner.java b/simpledb/opt/HeuristicQueryPlanner.java
new file mode 100755
index 0000000..fec17b8
--- /dev/null
+++ b/simpledb/opt/HeuristicQueryPlanner.java
@@ -0,0 +1,91 @@
+package simpledb.opt;
+
+import simpledb.tx.Transaction;
+import simpledb.query.*;
+import simpledb.opt.TablePlanner;
+import simpledb.parse.QueryData;
+import simpledb.planner.QueryPlanner;
+import java.util.*;
+
+/**
+ * A query planner that optimizes using a heuristic-based algorithm.
+ * @author Edward Sciore
+ */
+public class HeuristicQueryPlanner implements QueryPlanner {
+   private Collection<TablePlanner> tableplanners = new ArrayList<TablePlanner>();
+   
+   /**
+    * Creates an optimized left-deep query plan using the following
+    * heuristics.
+    * H1. Choose the smallest table (considering selection predicates)
+    * to be first in the join order.
+    * H2. Add the table to the join order which
+    * results in the smallest output.
+    */
+   public Plan createPlan(QueryData data, Transaction tx) {
+      
+      // Step 1:  Create a TablePlanner object for each mentioned table
+      for (String tblname : data.tables()) {
+         TablePlanner tp = new TablePlanner(tblname, data.pred(), tx);
+         tableplanners.add(tp);
+      }
+      
+      // Step 2:  Choose the lowest-size plan to begin the join order
+      Plan currentplan = getLowestSelectPlan();
+      
+      // Step 3:  Repeatedly add a plan to the join order
+      while (!tableplanners.isEmpty()) {
+         Plan p = getLowestJoinPlan(currentplan);
+         if (p != null)
+            currentplan = p;
+         else  // no applicable join
+            currentplan = getLowestProductPlan(currentplan);
+      }
+      
+      // Step 4.  Project on the field names and return
+      return new ProjectPlan(currentplan, data.fields());
+   }
+   
+   private Plan getLowestSelectPlan() {
+      TablePlanner besttp = null;
+      Plan bestplan = null;
+      for (TablePlanner tp : tableplanners) {
+         Plan plan = tp.makeSelectPlan();
+         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
+            besttp = tp;
+            bestplan = plan;
+         }
+      }
+      tableplanners.remove(besttp);
+      return bestplan;
+   }
+   
+   private Plan getLowestJoinPlan(Plan current) {
+      TablePlanner besttp = null;
+      Plan bestplan = null;
+      for (TablePlanner tp : tableplanners) {
+         Plan plan = tp.makeJoinPlan(current);
+         if (plan != null && (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput())) {
+            besttp = tp;
+            bestplan = plan;
+         }
+      }
+      if (bestplan != null)
+         tableplanners.remove(besttp);
+      return bestplan;
+   }
+   
+   private Plan getLowestProductPlan(Plan current) {
+      TablePlanner besttp = null;
+      Plan bestplan = null;
+      for (TablePlanner tp : tableplanners) {
+         Plan plan = tp.makeProductPlan(current);
+         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
+            besttp = tp;
+            bestplan = plan;
+         }
+      }
+      tableplanners.remove(besttp);
+      return bestplan;
+   }
+}
diff --git a/simpledb/opt/TablePlanner.class b/simpledb/opt/TablePlanner.class
new file mode 100755
index 0000000..5edcc24
Binary files /dev/null and b/simpledb/opt/TablePlanner.class differ
diff --git a/simpledb/opt/TablePlanner.java b/simpledb/opt/TablePlanner.java
new file mode 100755
index 0000000..b3b8da1
--- /dev/null
+++ b/simpledb/opt/TablePlanner.java
@@ -0,0 +1,128 @@
+package simpledb.opt;
+
+import simpledb.tx.Transaction;
+import simpledb.record.Schema;
+import simpledb.query.*;
+import simpledb.index.query.*;
+import simpledb.metadata.IndexInfo;
+import simpledb.multibuffer.MultiBufferProductPlan;
+import simpledb.server.SimpleDB;
+import java.util.Map;
+
+/**
+ * This class contains methods for planning a single table.
+ * @author Edward Sciore
+ */
+class TablePlanner {
+   private TablePlan myplan;
+   private Predicate mypred;
+   private Schema myschema;
+   private Map<String,IndexInfo> indexes;
+   private Transaction tx;
+   
+   /**
+    * Creates a new table planner.
+    * The specified predicate applies to the entire query.
+    * The table planner is responsible for determining
+    * which portion of the predicate is useful to the table,
+    * and when indexes are useful.
+    * @param tblname the name of the table
+    * @param mypred the query predicate
+    * @param tx the calling transaction
+    */
+   public TablePlanner(String tblname, Predicate mypred, Transaction tx) {
+      this.mypred  = mypred;
+      this.tx  = tx;
+      myplan   = new TablePlan(tblname, tx);
+      myschema = myplan.schema();
+      indexes  = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
+   }
+   
+   /**
+    * Constructs a select plan for the table.
+    * The plan will use an indexselect, if possible.
+    * @return a select plan for the table.
+    */
+   public Plan makeSelectPlan() {
+      Plan p = makeIndexSelect();
+      if (p == null)
+         p = myplan;
+      return addSelectPred(p);
+   }
+   
+   /**
+    * Constructs a join plan of the specified plan
+    * and the table.  The plan will use an indexjoin, if possible.
+    * (Which means that if an indexselect is also possible,
+    * the indexjoin operator takes precedence.)
+    * The method returns null if no join is possible.
+    * @param current the specified plan
+    * @return a join plan of the plan and this table
+    */
+   public Plan makeJoinPlan(Plan current) {
+      Schema currsch = current.schema();
+      Predicate joinpred = mypred.joinPred(myschema, currsch);
+      if (joinpred == null)
+         return null;
+      Plan p = makeIndexJoin(current, currsch);
+      if (p == null)
+         p = makeProductJoin(current, currsch);
+      return p;
+   }
+   
+   /**
+    * Constructs a product plan of the specified plan and
+    * this table.
+    * @param current the specified plan
+    * @return a product plan of the specified plan and this table
+    */
+   public Plan makeProductPlan(Plan current) {
+      Plan p = addSelectPred(myplan);
+      return new MultiBufferProductPlan(current, p, tx);
+   }
+   
+   private Plan makeIndexSelect() {
+      for (String fldname : indexes.keySet()) {
+         Constant val = mypred.equatesWithConstant(fldname);
+         if (val != null) {
+            IndexInfo ii = indexes.get(fldname);
+            return new IndexSelectPlan(myplan, ii, val, tx);
+         }
+      }
+      return null;
+   }
+   
+   private Plan makeIndexJoin(Plan current, Schema currsch) {
+      for (String fldname : indexes.keySet()) {
+         String outerfield = mypred.equatesWithField(fldname);
+         if (outerfield != null && currsch.hasField(outerfield)) {
+            IndexInfo ii = indexes.get(fldname);
+            Plan p = new IndexJoinPlan(current, myplan, ii, outerfield, tx);
+            p = addSelectPred(p);
+            return addJoinPred(p, currsch);
+         }
+      }
+      return null;
+   }
+   
+   private Plan makeProductJoin(Plan current, Schema currsch) {
+      Plan p = makeProductPlan(current);
+      return addJoinPred(p, currsch);
+   }
+   
+   private Plan addSelectPred(Plan p) {
+      Predicate selectpred = mypred.selectPred(myschema);
+      if (selectpred != null)
+         return new SelectPlan(p, selectpred);
+      else
+         return p;
+   }
+   
+   private Plan addJoinPred(Plan p, Schema currsch) {
+      Predicate joinpred = mypred.joinPred(currsch, myschema);
+      if (joinpred != null)
+         return new SelectPlan(p, joinpred);
+      else
+         return p;
+   }
+}
diff --git a/simpledb/parse/BadSyntaxException.class b/simpledb/parse/BadSyntaxException.class
new file mode 100755
index 0000000..870ef78
Binary files /dev/null and b/simpledb/parse/BadSyntaxException.class differ
diff --git a/simpledb/parse/BadSyntaxException.java b/simpledb/parse/BadSyntaxException.java
new file mode 100755
index 0000000..8abef7d
--- /dev/null
+++ b/simpledb/parse/BadSyntaxException.java
@@ -0,0 +1,12 @@
+package simpledb.parse;
+
+/**
+ * A runtime exception indicating that the submitted query
+ * has incorrect syntax.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+public class BadSyntaxException extends RuntimeException {
+   public BadSyntaxException() {
+   }
+}
diff --git a/simpledb/parse/CreateIndexData.class b/simpledb/parse/CreateIndexData.class
new file mode 100755
index 0000000..65fc086
Binary files /dev/null and b/simpledb/parse/CreateIndexData.class differ
diff --git a/simpledb/parse/CreateIndexData.java b/simpledb/parse/CreateIndexData.java
new file mode 100755
index 0000000..e2de0dd
--- /dev/null
+++ b/simpledb/parse/CreateIndexData.java
@@ -0,0 +1,43 @@
+package simpledb.parse;
+
+/**
+ * The parser for the <i>create index</i> statement.
+ * @author Edward Sciore
+ */
+public class CreateIndexData {
+   private String idxname, tblname, fldname;
+   
+   /**
+    * Saves the table and field names of the specified index.
+    */
+   public CreateIndexData(String idxname, String tblname, String fldname) {
+      this.idxname = idxname;
+      this.tblname = tblname;
+      this.fldname = fldname;
+   }
+   
+   /**
+    * Returns the name of the index.
+    * @return the name of the index
+    */
+   public String indexName() {
+      return idxname;
+   }
+   
+   /**
+    * Returns the name of the indexed table.
+    * @return the name of the indexed table
+    */
+   public String tableName() {
+      return tblname;
+   }
+   
+   /**
+    * Returns the name of the indexed field.
+    * @return the name of the indexed field
+    */
+   public String fieldName() {
+      return fldname;
+   }
+}
+
diff --git a/simpledb/parse/CreateTableData.class b/simpledb/parse/CreateTableData.class
new file mode 100755
index 0000000..83a8e40
Binary files /dev/null and b/simpledb/parse/CreateTableData.class differ
diff --git a/simpledb/parse/CreateTableData.java b/simpledb/parse/CreateTableData.java
new file mode 100755
index 0000000..35fa0f2
--- /dev/null
+++ b/simpledb/parse/CreateTableData.java
@@ -0,0 +1,37 @@
+package simpledb.parse;
+
+import simpledb.record.Schema;
+
+/**
+ * Data for the SQL <i>create table</i> statement.
+ * @author Edward Sciore
+ */
+public class CreateTableData {
+   private String tblname;
+   private Schema sch;
+   
+   /**
+    * Saves the table name and schema.
+    */
+   public CreateTableData(String tblname, Schema sch) {
+      this.tblname = tblname;
+      this.sch = sch;
+   }
+   
+   /**
+    * Returns the name of the new table.
+    * @return the name of the new table
+    */
+   public String tableName() {
+      return tblname;
+   }
+   
+   /**
+    * Returns the schema of the new table.
+    * @return the schema of the new table
+    */
+   public Schema newSchema() {
+      return sch;
+   }
+}
+
diff --git a/simpledb/parse/CreateViewData.class b/simpledb/parse/CreateViewData.class
new file mode 100755
index 0000000..1314087
Binary files /dev/null and b/simpledb/parse/CreateViewData.class differ
diff --git a/simpledb/parse/CreateViewData.java b/simpledb/parse/CreateViewData.java
new file mode 100755
index 0000000..2443d98
--- /dev/null
+++ b/simpledb/parse/CreateViewData.java
@@ -0,0 +1,34 @@
+package simpledb.parse;
+
+/**
+ * Data for the SQL <i>create view</i> statement.
+ * @author Edward Sciore
+ */
+public class CreateViewData {
+   private String viewname;
+   private QueryData qrydata;
+   
+   /**
+    * Saves the view name and its definition.
+    */
+   public CreateViewData(String viewname, QueryData qrydata) {
+      this.viewname = viewname;
+      this.qrydata = qrydata;
+   }
+   
+   /**
+    * Returns the name of the new view.
+    * @return the name of the new view
+    */
+   public String viewName() {
+      return viewname;
+   }
+   
+   /**
+    * Returns the definition of the new view.
+    * @return the definition of the new view
+    */
+   public String viewDef() {
+      return qrydata.toString();
+   }
+}
diff --git a/simpledb/parse/DeleteData.class b/simpledb/parse/DeleteData.class
new file mode 100755
index 0000000..bc5a3e7
Binary files /dev/null and b/simpledb/parse/DeleteData.class differ
diff --git a/simpledb/parse/DeleteData.java b/simpledb/parse/DeleteData.java
new file mode 100755
index 0000000..db97040
--- /dev/null
+++ b/simpledb/parse/DeleteData.java
@@ -0,0 +1,38 @@
+package simpledb.parse;
+
+import simpledb.query.*;
+
+/**
+ * Data for the SQL <i>delete</i> statement.
+ * @author Edward Sciore
+ */
+public class DeleteData {
+   private String tblname;
+   private Predicate pred;
+   
+   /**
+    * Saves the table name and predicate.
+    */
+   public DeleteData(String tblname, Predicate pred) {
+      this.tblname = tblname;
+      this.pred = pred;
+   }
+   
+   /**
+    * Returns the name of the affected table.
+    * @return the name of the affected table
+    */
+   public String tableName() {
+      return tblname;
+   }
+   
+   /**
+    * Returns the predicate that describes which
+    * records should be deleted.
+    * @return the deletion predicate
+    */
+   public Predicate pred() {
+      return pred;
+   }
+}
+
diff --git a/simpledb/parse/InsertData.class b/simpledb/parse/InsertData.class
new file mode 100755
index 0000000..5d2c677
Binary files /dev/null and b/simpledb/parse/InsertData.class differ
diff --git a/simpledb/parse/InsertData.java b/simpledb/parse/InsertData.java
new file mode 100755
index 0000000..51408a1
--- /dev/null
+++ b/simpledb/parse/InsertData.java
@@ -0,0 +1,51 @@
+package simpledb.parse;
+
+import simpledb.query.Constant;
+import java.util.*;
+
+/**
+ * Data for the SQL <i>insert</i> statement.
+ * @author Edward Sciore
+ */
+public class InsertData {
+   private String tblname;
+   private List<String> flds;
+   private List<Constant> vals;
+   
+   /**
+    * Saves the table name and the field and value lists.
+    */
+   public InsertData(String tblname, List<String> flds, List<Constant> vals) {
+      this.tblname = tblname;
+      this.flds = flds;
+      this.vals = vals;
+   }
+   
+   /**
+    * Returns the name of the affected table.
+    * @return the name of the affected table
+    */
+   public String tableName() {
+      return tblname;
+   }
+   
+   /**
+    * Returns a list of fields for which
+    * values will be specified in the new record.
+    * @return a list of field names
+    */
+   public List<String> fields() {
+      return flds;
+   }
+   
+   /**
+    * Returns a list of values for the specified fields.
+    * There is a one-one correspondence between this
+    * list of values and the list of fields.
+    * @return a list of Constant values.
+    */
+   public List<Constant> vals() {
+      return vals;
+   }
+}
+
diff --git a/simpledb/parse/Lexer.class b/simpledb/parse/Lexer.class
new file mode 100755
index 0000000..34d7e0e
Binary files /dev/null and b/simpledb/parse/Lexer.class differ
diff --git a/simpledb/parse/Lexer.java b/simpledb/parse/Lexer.java
new file mode 100755
index 0000000..0ae4404
--- /dev/null
+++ b/simpledb/parse/Lexer.java
@@ -0,0 +1,154 @@
+package simpledb.parse;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * The lexical analyzer.
+ * @author Edward Sciore
+ */
+public class Lexer {
+   private Collection<String> keywords;
+   private StreamTokenizer tok;
+   
+   /**
+    * Creates a new lexical analyzer for SQL statement s.
+    * @param s the SQL statement
+    */
+   public Lexer(String s) {
+      initKeywords();
+      tok = new StreamTokenizer(new StringReader(s));
+      tok.ordinaryChar('.');
+      tok.lowerCaseMode(true); //ids and keywords are converted
+      nextToken();
+   }
+   
+//Methods to check the status of the current token
+   
+   /**
+    * Returns true if the current token is
+    * the specified delimiter character.
+    * @param d a character denoting the delimiter
+    * @return true if the delimiter is the current token
+    */
+   public boolean matchDelim(char d) {
+      return d == (char)tok.ttype;
+   }
+   
+   /**
+    * Returns true if the current token is an integer.
+    * @return true if the current token is an integer
+    */
+   public boolean matchIntConstant() {
+      return tok.ttype == StreamTokenizer.TT_NUMBER;
+   }
+   
+   /**
+    * Returns true if the current token is a string.
+    * @return true if the current token is a string
+    */
+   public boolean matchStringConstant() {
+      return '\'' == (char)tok.ttype;
+   }
+   
+   /**
+    * Returns true if the current token is the specified keyword.
+    * @param w the keyword string
+    * @return true if that keyword is the current token
+    */
+   public boolean matchKeyword(String w) {
+      return tok.ttype == StreamTokenizer.TT_WORD && tok.sval.equals(w);
+   }
+   
+   /**
+    * Returns true if the current token is a legal identifier.
+    * @return true if the current token is an identifier
+    */
+   public boolean matchId() {
+      return  tok.ttype==StreamTokenizer.TT_WORD && !keywords.contains(tok.sval);
+   }
+   
+//Methods to "eat" the current token
+   
+   /**
+    * Throws an exception if the current token is not the
+    * specified delimiter. 
+    * Otherwise, moves to the next token.
+    * @param d a character denoting the delimiter
+    */
+   public void eatDelim(char d) {
+      if (!matchDelim(d))
+         throw new BadSyntaxException();
+      nextToken();
+   }
+   
+   /**
+    * Throws an exception if the current token is not 
+    * an integer. 
+    * Otherwise, returns that integer and moves to the next token.
+    * @return the integer value of the current token
+    */
+   public int eatIntConstant() {
+      if (!matchIntConstant())
+         throw new BadSyntaxException();
+      int i = (int) tok.nval;
+      nextToken();
+      return i;
+   }
+   
+   /**
+    * Throws an exception if the current token is not 
+    * a string. 
+    * Otherwise, returns that string and moves to the next token.
+    * @return the string value of the current token
+    */
+   public String eatStringConstant() {
+      if (!matchStringConstant())
+         throw new BadSyntaxException();
+      String s = tok.sval; //constants are not converted to lower case
+      nextToken();
+      return s;
+   }
+   
+   /**
+    * Throws an exception if the current token is not the
+    * specified keyword. 
+    * Otherwise, moves to the next token.
+    * @param w the keyword string
+    */
+   public void eatKeyword(String w) {
+      if (!matchKeyword(w))
+         throw new BadSyntaxException();
+      nextToken();
+   }
+   
+   /**
+    * Throws an exception if the current token is not 
+    * an identifier. 
+    * Otherwise, returns the identifier string 
+    * and moves to the next token.
+    * @return the string value of the current token
+    */
+   public String eatId() {
+      if (!matchId())
+         throw new BadSyntaxException();
+      String s = tok.sval;
+      nextToken();
+      return s;
+   }
+   
+   private void nextToken() {
+      try {
+         tok.nextToken();
+      }
+      catch(IOException e) {
+         throw new BadSyntaxException();
+      }
+   }
+   
+   private void initKeywords() {
+      keywords = Arrays.asList("select", "from", "where", "and",
+                               "insert", "into", "values", "delete", "update", "set", 
+                               "create", "table", "int", "varchar", "view", "as", "index", "on");
+   }
+}
\ No newline at end of file
diff --git a/simpledb/parse/ModifyData.class b/simpledb/parse/ModifyData.class
new file mode 100755
index 0000000..38a50ff
Binary files /dev/null and b/simpledb/parse/ModifyData.class differ
diff --git a/simpledb/parse/ModifyData.java b/simpledb/parse/ModifyData.java
new file mode 100755
index 0000000..88295d8
--- /dev/null
+++ b/simpledb/parse/ModifyData.java
@@ -0,0 +1,59 @@
+package simpledb.parse;
+
+import simpledb.query.*;
+
+/**
+ * Data for the SQL <i>update</i> statement.
+ * @author Edward Sciore
+ */
+public class ModifyData {
+   private String tblname;
+   private String fldname;
+   private Expression newval;
+   private Predicate pred;
+   
+   /**
+    * Saves the table name, the modified field and its new value, and the predicate.
+    */
+   public ModifyData(String tblname, String fldname, Expression newval, Predicate pred) {
+      this.tblname = tblname;
+      this.fldname = fldname;
+      this.newval = newval;
+      this.pred = pred;
+   }
+   
+   /**
+    * Returns the name of the affected table.
+    * @return the name of the affected table
+    */
+   public String tableName() {
+      return tblname;
+   }
+   
+   /**
+    * Returns the field whose values will be modified
+    * @return the name of the target field
+    */
+   public String targetField() {
+      return fldname;
+   }
+   
+   /**
+    * Returns an expression.
+    * Evaluating this expression for a record produces
+    * the value that will be stored in the record's target field.
+    * @return the target expression
+    */
+   public Expression newValue() {
+      return newval;
+   }
+   
+   /**
+    * Returns the predicate that describes which
+    * records should be modified.
+    * @return the modification predicate
+    */
+   public Predicate pred() {
+      return pred;
+   }
+}
\ No newline at end of file
diff --git a/simpledb/parse/Parser.class b/simpledb/parse/Parser.class
new file mode 100755
index 0000000..462b26b
Binary files /dev/null and b/simpledb/parse/Parser.class differ
diff --git a/simpledb/parse/Parser.java b/simpledb/parse/Parser.java
new file mode 100755
index 0000000..cf52092
--- /dev/null
+++ b/simpledb/parse/Parser.java
@@ -0,0 +1,245 @@
+package simpledb.parse;
+
+import java.util.*;
+import simpledb.query.*;
+import simpledb.record.Schema;
+
+/**
+ * The SimpleDB parser.
+ * @author Edward Sciore
+ */
+public class Parser {
+   private Lexer lex;
+   
+   public Parser(String s) {
+      lex = new Lexer(s);
+   }
+   
+// Methods for parsing predicates, terms, expressions, constants, and fields
+   
+   public String field() {
+      return lex.eatId();
+   }
+   
+   public Constant constant() {
+      if (lex.matchStringConstant())
+         return new StringConstant(lex.eatStringConstant());
+      else
+         return new IntConstant(lex.eatIntConstant());
+   }
+   
+   public Expression expression() {
+      if (lex.matchId())
+         return new FieldNameExpression(field());
+      else
+         return new ConstantExpression(constant());
+   }
+   
+   public Term term() {
+      Expression lhs = expression();
+      lex.eatDelim('=');
+      Expression rhs = expression();
+      return new Term(lhs, rhs);
+   }
+   
+   public Predicate predicate() {
+      Predicate pred = new Predicate(term());
+      if (lex.matchKeyword("and")) {
+         lex.eatKeyword("and");
+         pred.conjoinWith(predicate());
+      }
+      return pred;
+   }
+   
+// Methods for parsing queries
+   
+   public QueryData query() {
+      lex.eatKeyword("select");
+      Collection<String> fields = selectList();
+      lex.eatKeyword("from");
+      Collection<String> tables = tableList();
+      Predicate pred = new Predicate();
+      if (lex.matchKeyword("where")) {
+         lex.eatKeyword("where");
+         pred = predicate();
+      }
+      return new QueryData(fields, tables, pred);
+   }
+   
+   private Collection<String> selectList() {
+      Collection<String> L = new ArrayList<String>();
+      L.add(field());
+      if (lex.matchDelim(',')) {
+         lex.eatDelim(',');
+         L.addAll(selectList());
+      }
+      return L;
+   }
+   
+   private Collection<String> tableList() {
+      Collection<String> L = new ArrayList<String>();
+      L.add(lex.eatId());
+      if (lex.matchDelim(',')) {
+         lex.eatDelim(',');
+         L.addAll(tableList());
+      }
+      return L;
+   }
+   
+// Methods for parsing the various update commands
+   
+   public Object updateCmd() {
+      if (lex.matchKeyword("insert"))
+         return insert();
+      else if (lex.matchKeyword("delete"))
+         return delete();
+      else if (lex.matchKeyword("update"))
+         return modify();
+      else
+         return create();
+   }
+   
+   private Object create() {
+      lex.eatKeyword("create");
+      if (lex.matchKeyword("table"))
+         return createTable();
+      else if (lex.matchKeyword("view"))
+         return createView();
+      else
+         return createIndex();
+   }
+   
+// Method for parsing delete commands
+   
+   public DeleteData delete() {
+      lex.eatKeyword("delete");
+      lex.eatKeyword("from");
+      String tblname = lex.eatId();
+      Predicate pred = new Predicate();
+      if (lex.matchKeyword("where")) {
+         lex.eatKeyword("where");
+         pred = predicate();
+      }
+      return new DeleteData(tblname, pred);
+   }
+   
+// Methods for parsing insert commands
+   
+   public InsertData insert() {
+      lex.eatKeyword("insert");
+      lex.eatKeyword("into");
+      String tblname = lex.eatId();
+      lex.eatDelim('(');
+      List<String> flds = fieldList();
+      lex.eatDelim(')');
+      lex.eatKeyword("values");
+      lex.eatDelim('(');
+      List<Constant> vals = constList();
+      lex.eatDelim(')');
+      return new InsertData(tblname, flds, vals);
+   }
+   
+   private List<String> fieldList() {
+      List<String> L = new ArrayList<String>();
+      L.add(field());
+      if (lex.matchDelim(',')) {
+         lex.eatDelim(',');
+         L.addAll(fieldList());
+      }
+      return L;
+   }
+   
+   private List<Constant> constList() {
+      List<Constant> L = new ArrayList<Constant>();
+      L.add(constant());
+      if (lex.matchDelim(',')) {
+         lex.eatDelim(',');
+         L.addAll(constList());
+      }
+      return L;
+   }
+   
+// Method for parsing modify commands
+   
+   public ModifyData modify() {
+      lex.eatKeyword("update");
+      String tblname = lex.eatId();
+      lex.eatKeyword("set");
+      String fldname = field();
+      lex.eatDelim('=');
+      Expression newval = expression();
+      Predicate pred = new Predicate();
+      if (lex.matchKeyword("where")) {
+         lex.eatKeyword("where");
+         pred = predicate();
+      }
+      return new ModifyData(tblname, fldname, newval, pred);
+   }
+   
+// Method for parsing create table commands
+   
+   public CreateTableData createTable() {
+      lex.eatKeyword("table");
+      String tblname = lex.eatId();
+      lex.eatDelim('(');
+      Schema sch = fieldDefs();
+      lex.eatDelim(')');
+      return new CreateTableData(tblname, sch);
+   }
+   
+   private Schema fieldDefs() {
+      Schema schema = fieldDef();
+      if (lex.matchDelim(',')) {
+         lex.eatDelim(',');
+         Schema schema2 = fieldDefs();
+         schema.addAll(schema2);
+      }
+      return schema;
+   }
+   
+   private Schema fieldDef() {
+      String fldname = field();
+      return fieldType(fldname);
+   }
+   
+   private Schema fieldType(String fldname) {
+      Schema schema = new Schema();
+      if (lex.matchKeyword("int")) {
+         lex.eatKeyword("int");
+         schema.addIntField(fldname);
+      }
+      else {
+         lex.eatKeyword("varchar");
+         lex.eatDelim('(');
+         int strLen = lex.eatIntConstant();
+         lex.eatDelim(')');
+         schema.addStringField(fldname, strLen);
+      }
+      return schema;
+   }
+   
+// Method for parsing create view commands
+   
+   public CreateViewData createView() {
+      lex.eatKeyword("view");
+      String viewname = lex.eatId();
+      lex.eatKeyword("as");
+      QueryData qd = query();
+      return new CreateViewData(viewname, qd);
+   }
+   
+   
+//  Method for parsing create index commands
+   
+   public CreateIndexData createIndex() {
+      lex.eatKeyword("index");
+      String idxname = lex.eatId();
+      lex.eatKeyword("on");
+      String tblname = lex.eatId();
+      lex.eatDelim('(');
+      String fldname = field();
+      lex.eatDelim(')');
+      return new CreateIndexData(idxname, tblname, fldname);
+   }
+}
+
diff --git a/simpledb/parse/QueryData.class b/simpledb/parse/QueryData.class
new file mode 100755
index 0000000..d7f8cef
Binary files /dev/null and b/simpledb/parse/QueryData.class differ
diff --git a/simpledb/parse/QueryData.java b/simpledb/parse/QueryData.java
new file mode 100755
index 0000000..898c42b
--- /dev/null
+++ b/simpledb/parse/QueryData.java
@@ -0,0 +1,63 @@
+package simpledb.parse;
+
+import simpledb.query.*;
+import java.util.*;
+
+/**
+ * Data for the SQL <i>select</i> statement.
+ * @author Edward Sciore
+ */
+public class QueryData {
+   private Collection<String> fields;
+   private Collection<String> tables;
+   private Predicate pred;
+   
+   /**
+    * Saves the field and table list and predicate.
+    */
+   public QueryData(Collection<String> fields, Collection<String> tables, Predicate pred) {
+      this.fields = fields;
+      this.tables = tables;
+      this.pred = pred;
+   }
+   
+   /**
+    * Returns the fields mentioned in the select clause.
+    * @return a collection of field names
+    */
+   public Collection<String> fields() {
+      return fields;
+   }
+   
+   /**
+    * Returns the tables mentioned in the from clause.
+    * @return a collection of table names
+    */
+   public Collection<String> tables() {
+      return tables;
+   }
+   
+   /**
+    * Returns the predicate that describes which
+    * records should be in the output table.
+    * @return the query predicate
+    */
+   public Predicate pred() {
+      return pred;
+   }
+   
+   public String toString() {
+      String result = "select ";
+      for (String fldname : fields)
+         result += fldname + ", ";
+      result = result.substring(0, result.length()-2); //remove final comma
+      result += " from ";
+      for (String tblname : tables)
+         result += tblname + ", ";
+      result = result.substring(0, result.length()-2); //remove final comma
+      String predstring = pred.toString();
+      if (!predstring.equals(""))
+         result += " where " + predstring;
+      return result;
+   }
+}
diff --git a/simpledb/planner/BasicQueryPlanner.class b/simpledb/planner/BasicQueryPlanner.class
new file mode 100755
index 0000000..524b07d
Binary files /dev/null and b/simpledb/planner/BasicQueryPlanner.class differ
diff --git a/simpledb/planner/BasicQueryPlanner.java b/simpledb/planner/BasicQueryPlanner.java
new file mode 100755
index 0000000..dada735
--- /dev/null
+++ b/simpledb/planner/BasicQueryPlanner.java
@@ -0,0 +1,43 @@
+package simpledb.planner;
+
+import simpledb.tx.Transaction;
+import simpledb.query.*;
+import simpledb.parse.*;
+import simpledb.server.SimpleDB;
+import java.util.*;
+
+/**
+ * The simplest, most naive query planner possible.
+ * @author Edward Sciore
+ */
+public class BasicQueryPlanner implements QueryPlanner {
+   
+   /**
+    * Creates a query plan as follows.  It first takes
+    * the product of all tables and views; it then selects on the predicate;
+    * and finally it projects on the field list. 
+    */
+   public Plan createPlan(QueryData data, Transaction tx) {
+      //Step 1: Create a plan for each mentioned table or view
+      List<Plan> plans = new ArrayList<Plan>();
+      for (String tblname : data.tables()) {
+         String viewdef = SimpleDB.mdMgr().getViewDef(tblname, tx);
+         if (viewdef != null)
+            plans.add(SimpleDB.planner().createQueryPlan(viewdef, tx));
+         else
+            plans.add(new TablePlan(tblname, tx));
+      }
+      
+      //Step 2: Create the product of all table plans
+      Plan p = plans.remove(0);
+      for (Plan nextplan : plans)
+         p = new ProductPlan(p, nextplan);
+      
+      //Step 3: Add a selection plan for the predicate
+      p = new SelectPlan(p, data.pred());
+      
+      //Step 4: Project on the field names
+      p = new ProjectPlan(p, data.fields());
+      return p;
+   }
+}
diff --git a/simpledb/planner/BasicUpdatePlanner.class b/simpledb/planner/BasicUpdatePlanner.class
new file mode 100755
index 0000000..cb9368b
Binary files /dev/null and b/simpledb/planner/BasicUpdatePlanner.class differ
diff --git a/simpledb/planner/BasicUpdatePlanner.java b/simpledb/planner/BasicUpdatePlanner.java
new file mode 100755
index 0000000..c2b19da
--- /dev/null
+++ b/simpledb/planner/BasicUpdatePlanner.java
@@ -0,0 +1,68 @@
+package simpledb.planner;
+
+import java.util.Iterator;
+import simpledb.server.SimpleDB;
+import simpledb.tx.Transaction;
+import simpledb.parse.*;
+import simpledb.query.*;
+
+/**
+ * The basic planner for SQL update statements.
+ * @author sciore
+ */
+public class BasicUpdatePlanner implements UpdatePlanner {
+   
+   public int executeDelete(DeleteData data, Transaction tx) {
+      Plan p = new TablePlan(data.tableName(), tx);
+      p = new SelectPlan(p, data.pred());
+      UpdateScan us = (UpdateScan) p.open();
+      int count = 0;
+      while(us.next()) {
+         us.delete();
+         count++;
+      }
+      us.close();
+      return count;
+   }
+   
+   public int executeModify(ModifyData data, Transaction tx) {
+      Plan p = new TablePlan(data.tableName(), tx);
+      p = new SelectPlan(p, data.pred());
+      UpdateScan us = (UpdateScan) p.open();
+      int count = 0;
+      while(us.next()) {
+         Constant val = data.newValue().evaluate(us);
+         us.setVal(data.targetField(), val);
+         count++;
+      }
+      us.close();
+      return count;
+   }
+   
+   public int executeInsert(InsertData data, Transaction tx) {
+      Plan p = new TablePlan(data.tableName(), tx);
+      UpdateScan us = (UpdateScan) p.open();
+      us.insert();
+      Iterator<Constant> iter = data.vals().iterator();
+      for (String fldname : data.fields()) {
+         Constant val = iter.next();
+         us.setVal(fldname, val);
+      }
+      us.close();
+      return 1;
+   }
+   
+   public int executeCreateTable(CreateTableData data, Transaction tx) {
+      SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
+      return 0;
+   }
+   
+   public int executeCreateView(CreateViewData data, Transaction tx) {
+      SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
+      return 0;
+   }
+   public int executeCreateIndex(CreateIndexData data, Transaction tx) {
+      SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
+      return 0;  
+   }
+}
diff --git a/simpledb/planner/Planner.class b/simpledb/planner/Planner.class
new file mode 100755
index 0000000..3c0e2cb
Binary files /dev/null and b/simpledb/planner/Planner.class differ
diff --git a/simpledb/planner/Planner.java b/simpledb/planner/Planner.java
new file mode 100755
index 0000000..f272fdd
--- /dev/null
+++ b/simpledb/planner/Planner.java
@@ -0,0 +1,60 @@
+package simpledb.planner;
+
+import simpledb.tx.Transaction;
+import simpledb.parse.*;
+import simpledb.query.*;
+
+/**
+ * The object that executes SQL statements.
+ * @author sciore
+ */
+public class Planner {
+   private QueryPlanner qplanner;
+   private UpdatePlanner uplanner;
+   
+   public Planner(QueryPlanner qplanner, UpdatePlanner uplanner) {
+      this.qplanner = qplanner;
+      this.uplanner = uplanner;
+   }
+   
+   /**
+    * Creates a plan for an SQL select statement, using the supplied planner.
+    * @param qry the SQL query string
+    * @param tx the transaction
+    * @return the scan corresponding to the query plan
+    */
+   public Plan createQueryPlan(String qry, Transaction tx) {
+      Parser parser = new Parser(qry);
+      QueryData data = parser.query();
+      return qplanner.createPlan(data, tx);
+   }
+   
+   /**
+    * Executes an SQL insert, delete, modify, or
+    * create statement.
+    * The method dispatches to the appropriate method of the
+    * supplied update planner,
+    * depending on what the parser returns.
+    * @param cmd the SQL update string
+    * @param tx the transaction
+    * @return an integer denoting the number of affected records
+    */
+   public int executeUpdate(String cmd, Transaction tx) {
+      Parser parser = new Parser(cmd);
+      Object obj = parser.updateCmd();
+      if (obj instanceof InsertData)
+         return uplanner.executeInsert((InsertData)obj, tx);
+      else if (obj instanceof DeleteData)
+         return uplanner.executeDelete((DeleteData)obj, tx);
+      else if (obj instanceof ModifyData)
+         return uplanner.executeModify((ModifyData)obj, tx);
+      else if (obj instanceof CreateTableData)
+         return uplanner.executeCreateTable((CreateTableData)obj, tx);
+      else if (obj instanceof CreateViewData)
+         return uplanner.executeCreateView((CreateViewData)obj, tx);
+      else if (obj instanceof CreateIndexData)
+         return uplanner.executeCreateIndex((CreateIndexData)obj, tx);
+      else
+         return 0;
+   }
+}
diff --git a/simpledb/planner/QueryPlanner.class b/simpledb/planner/QueryPlanner.class
new file mode 100755
index 0000000..66f6e28
Binary files /dev/null and b/simpledb/planner/QueryPlanner.class differ
diff --git a/simpledb/planner/QueryPlanner.java b/simpledb/planner/QueryPlanner.java
new file mode 100755
index 0000000..b4f24d9
--- /dev/null
+++ b/simpledb/planner/QueryPlanner.java
@@ -0,0 +1,22 @@
+package simpledb.planner;
+
+import simpledb.tx.Transaction;
+import simpledb.query.Plan;
+import simpledb.parse.QueryData;
+
+/**
+ * The interface implemented by planners for 
+ * the SQL select statement.
+ * @author Edward Sciore
+ *
+ */
+public interface QueryPlanner {
+   
+   /**
+    * Creates a plan for the parsed query.
+    * @param data the parsed representation of the query
+    * @param tx the calling transaction
+    * @return a plan for that query
+    */
+   public Plan createPlan(QueryData data, Transaction tx);
+}
diff --git a/simpledb/planner/UpdatePlanner.class b/simpledb/planner/UpdatePlanner.class
new file mode 100755
index 0000000..c660368
Binary files /dev/null and b/simpledb/planner/UpdatePlanner.class differ
diff --git a/simpledb/planner/UpdatePlanner.java b/simpledb/planner/UpdatePlanner.java
new file mode 100755
index 0000000..3e7439d
--- /dev/null
+++ b/simpledb/planner/UpdatePlanner.java
@@ -0,0 +1,66 @@
+package simpledb.planner;
+
+import simpledb.tx.Transaction;
+import simpledb.parse.*;
+
+/**
+ * The interface implemented by the planners
+ * for SQL insert, delete, and modify statements.
+ * @author Edward Sciore
+ */
+public interface UpdatePlanner {
+   
+   /**
+    * Executes the specified insert statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the insert statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeInsert(InsertData data, Transaction tx);
+   
+   /**
+    * Executes the specified delete statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the delete statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeDelete(DeleteData data, Transaction tx);
+   
+   /**
+    * Executes the specified modify statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the modify statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeModify(ModifyData data, Transaction tx);
+   
+   /**
+    * Executes the specified create table statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the create table statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeCreateTable(CreateTableData data, Transaction tx);
+   
+   /**
+    * Executes the specified create view statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the create view statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeCreateView(CreateViewData data, Transaction tx);
+   
+   /**
+    * Executes the specified create index statement, and
+    * returns the number of affected records.
+    * @param data the parsed representation of the create index statement
+    * @param tx the calling transaction
+    * @return the number of affected records
+    */
+   public int executeCreateIndex(CreateIndexData data, Transaction tx);
+}
diff --git a/simpledb/query/Constant.class b/simpledb/query/Constant.class
new file mode 100755
index 0000000..c82d332
Binary files /dev/null and b/simpledb/query/Constant.class differ
diff --git a/simpledb/query/Constant.java b/simpledb/query/Constant.java
new file mode 100755
index 0000000..c15985b
--- /dev/null
+++ b/simpledb/query/Constant.java
@@ -0,0 +1,14 @@
+package simpledb.query;
+
+/**
+ * The interface that denotes values stored in the database.
+ * @author Edward Sciore
+ */
+public interface Constant extends Comparable<Constant> {
+   
+   /**
+    * Returns the Java object corresponding to this constant.
+    * @return the Java value of the constant
+    */
+   public Object  asJavaVal();
+}
diff --git a/simpledb/query/ConstantExpression.class b/simpledb/query/ConstantExpression.class
new file mode 100755
index 0000000..c59b6cb
Binary files /dev/null and b/simpledb/query/ConstantExpression.class differ
diff --git a/simpledb/query/ConstantExpression.java b/simpledb/query/ConstantExpression.java
new file mode 100755
index 0000000..28df6d1
--- /dev/null
+++ b/simpledb/query/ConstantExpression.java
@@ -0,0 +1,73 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/**
+ * An expression consisting entirely of a single constant.
+ * @author Edward Sciore
+ *
+ */
+public class ConstantExpression implements Expression {
+   private Constant val;
+   
+   /**
+    * Creates a new expression by wrapping a constant.
+    * @param c the constant
+    */
+   public ConstantExpression(Constant c) {
+      val = c;
+   }
+   
+   /**
+    * Returns true.
+    * @see simpledb.query.Expression#isConstant()
+    */
+   public boolean isConstant() {
+      return true;
+   }
+   
+   /**
+    * Returns false.
+    * @see simpledb.query.Expression#isFieldName()
+    */
+   public boolean isFieldName() {
+      return false;
+   }
+   
+   /**
+    * Unwraps the constant and returns it.
+    * @see simpledb.query.Expression#asConstant()
+    */
+   public Constant asConstant() {
+      return val;
+   }
+   
+   /**
+    * This method should never be called.
+    * Throws a ClassCastException.
+    * @see simpledb.query.Expression#asFieldName()
+    */
+   public String asFieldName() {
+      throw new ClassCastException();
+   }
+   
+   /**
+    * Returns the constant, regardless of the scan.
+    * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
+    */
+   public Constant evaluate(Scan s) {
+      return val;
+   }
+   
+   /**
+    * Returns true, because a constant applies to any schema.
+    * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
+    */
+   public boolean appliesTo(Schema sch) {
+      return true;
+   }
+   
+   public String toString() {
+      return val.toString();
+   }
+}
diff --git a/simpledb/query/Expression.class b/simpledb/query/Expression.class
new file mode 100755
index 0000000..1645341
Binary files /dev/null and b/simpledb/query/Expression.class differ
diff --git a/simpledb/query/Expression.java b/simpledb/query/Expression.java
new file mode 100755
index 0000000..a66d5e2
--- /dev/null
+++ b/simpledb/query/Expression.java
@@ -0,0 +1,55 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/**
+ * The interface corresponding to SQL expressions.
+ * @author Edward Sciore
+ *
+ */
+public interface Expression {
+   
+   /**
+    * Returns true if the expression is a constant.
+    * @return true if the expression is a constant
+    */
+   public boolean  isConstant();
+   
+   /**
+    * Returns true if the expression is a field reference.
+    * @return true if the expression denotes a field
+    */
+   public boolean  isFieldName();
+   
+   /**
+    * Returns the constant corresponding to a constant expression.
+    * Throws an exception if the expression does not
+    * denote a constant.
+    * @return the expression as a constant
+    */
+   public Constant asConstant();
+   
+   /**
+    * Returns the field name corresponding to a constant expression.
+    * Throws an exception if the expression does not
+    * denote a field.
+    * @return the expression as a field name
+    */
+   public String   asFieldName();
+   
+   /**
+    * Evaluates the expression with respect to the
+    * current record of the specified scan.
+    * @param s the scan
+    * @return the value of the expression, as a Constant
+    */
+   public Constant evaluate(Scan s);
+   
+   /**
+    * Determines if all of the fields mentioned in this expression
+    * are contained in the specified schema.
+    * @param sch the schema
+    * @return true if all fields in the expression are in the schema
+    */
+   public boolean  appliesTo(Schema sch);
+}
diff --git a/simpledb/query/FieldNameExpression.class b/simpledb/query/FieldNameExpression.class
new file mode 100755
index 0000000..ce19bc4
Binary files /dev/null and b/simpledb/query/FieldNameExpression.class differ
diff --git a/simpledb/query/FieldNameExpression.java b/simpledb/query/FieldNameExpression.java
new file mode 100755
index 0000000..65f2310
--- /dev/null
+++ b/simpledb/query/FieldNameExpression.java
@@ -0,0 +1,73 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/**
+ * An expression consisting entirely of a single field.
+ * @author Edward Sciore
+ *
+ */
+public class FieldNameExpression implements Expression {
+   private String fldname;
+   
+   /**
+    * Creates a new expression by wrapping a field.
+    * @param fldname the name of the wrapped field
+    */
+   public FieldNameExpression(String fldname) {
+      this.fldname = fldname;
+   }
+   
+   /**
+    * Returns false.
+    * @see simpledb.query.Expression#isConstant()
+    */
+   public boolean isConstant() {
+      return false;
+   }
+   
+   /**
+    * Returns true.
+    * @see simpledb.query.Expression#isFieldName()
+    */
+   public boolean isFieldName() {
+      return true;
+   }
+   
+   /**
+    * This method should never be called.
+    * Throws a ClassCastException.
+    * @see simpledb.query.Expression#asConstant()
+    */
+   public Constant asConstant() {
+      throw new ClassCastException();
+   }
+   
+   /**
+    * Unwraps the field name and returns it.
+    * @see simpledb.query.Expression#asFieldName()
+    */
+   public String asFieldName() {
+      return fldname;
+   }
+   
+   /**
+    * Evaluates the field by getting its value in the scan.
+    * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
+    */
+   public Constant evaluate(Scan s) {
+      return s.getVal(fldname);
+   }
+   
+   /** 
+    * Returns true if the field is in the specified schema.
+    * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
+    */
+   public boolean appliesTo(Schema sch) {
+      return sch.hasField(fldname);
+   }
+   
+   public String toString() {
+      return fldname;
+   }
+}
diff --git a/simpledb/query/IntConstant.class b/simpledb/query/IntConstant.class
new file mode 100755
index 0000000..3689f60
Binary files /dev/null and b/simpledb/query/IntConstant.class differ
diff --git a/simpledb/query/IntConstant.java b/simpledb/query/IntConstant.java
new file mode 100755
index 0000000..c739b57
--- /dev/null
+++ b/simpledb/query/IntConstant.java
@@ -0,0 +1,43 @@
+package simpledb.query;
+
+/**
+ * The class that wraps Java ints as database constants.
+ * @author Edward Sciore
+ */
+public class IntConstant implements Constant {
+   private Integer val;
+   
+   /**
+    * Create a constant by wrapping the specified int.
+    * @param n the int value
+    */
+   public IntConstant(int n) {
+      val = new Integer(n);
+   }
+   
+   /**
+    * Unwraps the Integer and returns it.
+    * @see simpledb.query.Constant#asJavaVal()
+    */
+   public Object asJavaVal() {
+      return val;
+   }
+   
+   public boolean equals(Object obj) {
+      IntConstant ic = (IntConstant) obj;
+      return ic != null && val.equals(ic.val);
+   }
+   
+   public int compareTo(Constant c) {
+      IntConstant ic = (IntConstant) c;
+      return val.compareTo(ic.val);
+   }
+   
+   public int hashCode() {
+      return val.hashCode();
+   }
+   
+   public String toString() {
+      return val.toString();
+   }
+}
diff --git a/simpledb/query/Plan.class b/simpledb/query/Plan.class
new file mode 100755
index 0000000..ca8bda5
Binary files /dev/null and b/simpledb/query/Plan.class differ
diff --git a/simpledb/query/Plan.java b/simpledb/query/Plan.java
new file mode 100755
index 0000000..f1e2b24
--- /dev/null
+++ b/simpledb/query/Plan.java
@@ -0,0 +1,47 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/**
+ * The interface implemented by each query plan.
+ * There is a Plan class for each relational algebra operator.
+ * @author Edward Sciore
+ *
+ */
+public interface Plan {
+   
+   /**
+    * Opens a scan corresponding to this plan.
+    * The scan will be positioned before its first record.
+    * @return a scan
+    */
+   public Scan   open();
+   
+   /**
+    * Returns an estimate of the number of block accesses
+    * that will occur when the scan is read to completion.
+    * @return the estimated number of block accesses
+    */
+   public int    blocksAccessed();
+   
+   /**
+    * Returns an estimate of the number of records
+    * in the query's output table.
+    * @return the estimated number of output records
+    */
+   public int    recordsOutput();
+   
+   /**
+    * Returns an estimate of the number of distinct values
+    * for the specified field in the query's output table.
+    * @param fldname the name of a field
+    * @return the estimated number of distinct field values in the output
+    */
+   public int    distinctValues(String fldname);
+   
+   /**
+    * Returns the schema of the query.
+    * @return the query's schema
+    */
+   public Schema schema();
+}
diff --git a/simpledb/query/Predicate.class b/simpledb/query/Predicate.class
new file mode 100755
index 0000000..4ea5bf6
Binary files /dev/null and b/simpledb/query/Predicate.class differ
diff --git a/simpledb/query/Predicate.java b/simpledb/query/Predicate.java
new file mode 100755
index 0000000..03f956d
--- /dev/null
+++ b/simpledb/query/Predicate.java
@@ -0,0 +1,146 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+import java.util.*;
+/**
+ * A predicate is a Boolean combination of terms.
+ * @author Edward Sciore
+ *
+ */
+public class Predicate {
+   private List<Term> terms = new ArrayList<Term>();
+   
+   /**
+    * Creates an empty predicate, corresponding to "true".
+    */
+   public Predicate() {}
+   
+   /**
+    * Creates a predicate containing a single term.
+    * @param t the term
+    */
+   public Predicate(Term t) {
+      terms.add(t);
+   }
+   
+   /**
+    * Modifies the predicate to be the conjunction of
+    * itself and the specified predicate.
+    * @param pred the other predicate
+    */
+   public void conjoinWith(Predicate pred) {
+      terms.addAll(pred.terms);
+   }
+   
+   /**
+    * Returns true if the predicate evaluates to true
+    * with respect to the specified scan.
+    * @param s the scan
+    * @return true if the predicate is true in the scan
+    */
+   public boolean isSatisfied(Scan s) {
+      for (Term t : terms)
+         if (!t.isSatisfied(s))
+         return false;
+      return true;
+   }
+   
+   /** 
+    * Calculates the extent to which selecting on the predicate 
+    * reduces the number of records output by a query.
+    * For example if the reduction factor is 2, then the
+    * predicate cuts the size of the output in half.
+    * @param p the query's plan
+    * @return the integer reduction factor.
+    */ 
+   public int reductionFactor(Plan p) {
+      int factor = 1;
+      for (Term t : terms)
+         factor *= t.reductionFactor(p);
+      return factor;
+   }
+   
+   /**
+    * Returns the subpredicate that applies to the specified schema.
+    * @param sch the schema
+    * @return the subpredicate applying to the schema
+    */
+   public Predicate selectPred(Schema sch) {
+      Predicate result = new Predicate();
+      for (Term t : terms)
+         if (t.appliesTo(sch))
+         result.terms.add(t);
+      if (result.terms.size() == 0)
+         return null;
+      else
+         return result;
+   }
+   
+   /**
+    * Returns the subpredicate consisting of terms that apply
+    * to the union of the two specified schemas, 
+    * but not to either schema separately.
+    * @param sch1 the first schema
+    * @param sch2 the second schema
+    * @return the subpredicate whose terms apply to the union of the two schemas but not either schema separately.
+    */
+   public Predicate joinPred(Schema sch1, Schema sch2) {
+      Predicate result = new Predicate();
+      Schema newsch = new Schema();
+      newsch.addAll(sch1);
+      newsch.addAll(sch2);
+      for (Term t : terms)
+         if (!t.appliesTo(sch1)  &&
+             !t.appliesTo(sch2) &&
+             t.appliesTo(newsch))
+         result.terms.add(t);
+      if (result.terms.size() == 0)
+         return null;
+      else
+         return result;
+   }
+   
+   /**
+    * Determines if there is a term of the form "F=c"
+    * where F is the specified field and c is some constant.
+    * If so, the method returns that constant.
+    * If not, the method returns null.
+    * @param fldname the name of the field
+    * @return either the constant or null
+    */
+   public Constant equatesWithConstant(String fldname) {
+      for (Term t : terms) {
+         Constant c = t.equatesWithConstant(fldname);
+         if (c != null)
+            return c;
+      }
+      return null;
+   }
+   
+   /**
+    * Determines if there is a term of the form "F1=F2"
+    * where F1 is the specified field and F2 is another field.
+    * If so, the method returns the name of that field.
+    * If not, the method returns null.
+    * @param fldname the name of the field
+    * @return the name of the other field, or null
+    */
+   public String equatesWithField(String fldname) {
+      for (Term t : terms) {
+         String s = t.equatesWithField(fldname);
+         if (s != null)
+            return s;
+      }
+      return null;
+   }
+   
+   public String toString() {
+      Iterator<Term> iter = terms.iterator();
+      if (!iter.hasNext()) 
+         return "";
+      String result = iter.next().toString();
+      while (iter.hasNext())
+         result += " and " + iter.next().toString();
+      return result;
+   }
+}
diff --git a/simpledb/query/ProductPlan.class b/simpledb/query/ProductPlan.class
new file mode 100755
index 0000000..7d89c90
Binary files /dev/null and b/simpledb/query/ProductPlan.class differ
diff --git a/simpledb/query/ProductPlan.java b/simpledb/query/ProductPlan.java
new file mode 100755
index 0000000..1e8f1d5
--- /dev/null
+++ b/simpledb/query/ProductPlan.java
@@ -0,0 +1,77 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/** The Plan class corresponding to the <i>product</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class ProductPlan implements Plan {
+   private Plan p1, p2;
+   private Schema schema = new Schema();
+   
+   /**
+    * Creates a new product node in the query tree,
+    * having the two specified subqueries.
+    * @param p1 the left-hand subquery
+    * @param p2 the right-hand subquery
+    */
+   public ProductPlan(Plan p1, Plan p2) {
+      this.p1 = p1;
+      this.p2 = p2;
+      schema.addAll(p1.schema());
+      schema.addAll(p2.schema());
+   }
+   
+   /**
+    * Creates a product scan for this query.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s1 = p1.open();
+      Scan s2 = p2.open();
+      return new ProductScan(s1, s2);
+   }
+   
+   /**
+    * Estimates the number of block accesses in the product.
+    * The formula is:
+    * <pre> B(product(p1,p2)) = B(p1) + R(p1)*B(p2) </pre>
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p1.blocksAccessed() + (p1.recordsOutput() * p2.blocksAccessed());
+   }
+   
+   /**
+    * Estimates the number of output records in the product.
+    * The formula is:
+    * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p1.recordsOutput() * p2.recordsOutput();
+   }
+   
+   /**
+    * Estimates the distinct number of field values in the product.
+    * Since the product does not increase or decrease field values,
+    * the estimate is the same as in the appropriate underlying query.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (p1.schema().hasField(fldname))
+         return p1.distinctValues(fldname);
+      else
+         return p2.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the product,
+    * which is the union of the schemas of the underlying queries.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return schema;
+   }
+}
diff --git a/simpledb/query/ProductScan.class b/simpledb/query/ProductScan.class
new file mode 100755
index 0000000..4775e66
Binary files /dev/null and b/simpledb/query/ProductScan.class differ
diff --git a/simpledb/query/ProductScan.java b/simpledb/query/ProductScan.java
new file mode 100755
index 0000000..23746ac
--- /dev/null
+++ b/simpledb/query/ProductScan.java
@@ -0,0 +1,108 @@
+package simpledb.query;
+
+/**
+ * The scan class corresponding to the <i>product</i> relational
+ * algebra operator.
+ * @author Edward Sciore
+ */
+public class ProductScan implements Scan {
+   private Scan s1, s2;
+   
+   /**
+    * Creates a product scan having the two underlying scans.
+    * @param s1 the LHS scan
+    * @param s2 the RHS scan
+    */
+   public ProductScan(Scan s1, Scan s2) {
+      this.s1 = s1;
+      this.s2 = s2;
+      s1.next();
+   }
+   
+   /**
+    * Positions the scan before its first record.
+    * In other words, the LHS scan is positioned at 
+    * its first record, and the RHS scan
+    * is positioned before its first record.
+    * @see simpledb.query.Scan#beforeFirst()
+    */
+   public void beforeFirst() {
+      s1.beforeFirst();
+      s1.next();
+      s2.beforeFirst();
+   }
+   
+   /**
+    * Moves the scan to the next record.
+    * The method moves to the next RHS record, if possible.
+    * Otherwise, it moves to the next LHS record and the
+    * first RHS record.
+    * If there are no more LHS records, the method returns false.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      if (s2.next())
+         return true;
+      else {
+         s2.beforeFirst();
+         return s2.next() && s1.next();
+      }
+   }
+   
+   /**
+    * Closes both underlying scans.
+    * @see simpledb.query.Scan#close()
+    */
+   public void close() {
+      s1.close();
+      s2.close();
+   }
+   
+   /** 
+    * Returns the value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getVal(fldname);
+      else
+         return s2.getVal(fldname);
+   }
+   
+   /** 
+    * Returns the integer value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getInt(fldname);
+      else
+         return s2.getInt(fldname);
+   }
+   
+   /** 
+    * Returns the string value of the specified field.
+    * The value is obtained from whichever scan
+    * contains the field.
+    * @see simpledb.query.Scan#getString(java.lang.String)
+    */
+   public String getString(String fldname) {
+      if (s1.hasField(fldname))
+         return s1.getString(fldname);
+      else
+         return s2.getString(fldname);
+   }
+   
+   /**
+    * Returns true if the specified field is in
+    * either of the underlying scans.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return s1.hasField(fldname) || s2.hasField(fldname);
+   }
+}
diff --git a/simpledb/query/ProjectPlan.class b/simpledb/query/ProjectPlan.class
new file mode 100755
index 0000000..5b6bc3a
Binary files /dev/null and b/simpledb/query/ProjectPlan.class differ
diff --git a/simpledb/query/ProjectPlan.java b/simpledb/query/ProjectPlan.java
new file mode 100755
index 0000000..8f7e877
--- /dev/null
+++ b/simpledb/query/ProjectPlan.java
@@ -0,0 +1,71 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+import java.util.Collection;
+
+/** The Plan class corresponding to the <i>project</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class ProjectPlan implements Plan {
+   private Plan p;
+   private Schema schema = new Schema();
+   
+   /**
+    * Creates a new project node in the query tree,
+    * having the specified subquery and field list.
+    * @param p the subquery
+    * @param fieldlist the list of fields
+    */
+   public ProjectPlan(Plan p, Collection<String> fieldlist) {
+      this.p = p;
+      for (String fldname : fieldlist)
+         schema.add(fldname, p.schema());
+   }
+   
+   /**
+    * Creates a project scan for this query.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s = p.open();
+      return new ProjectScan(s, schema.fields());
+   }
+   
+   /**
+    * Estimates the number of block accesses in the projection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p.blocksAccessed();
+   }
+   
+   /**
+    * Estimates the number of output records in the projection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p.recordsOutput();
+   }
+   
+   /**
+    * Estimates the number of distinct field values
+    * in the projection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      return p.distinctValues(fldname);
+   }
+   
+   /**
+    * Returns the schema of the projection,
+    * which is taken from the field list.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return schema;
+   }
+}
diff --git a/simpledb/query/ProjectScan.class b/simpledb/query/ProjectScan.class
new file mode 100755
index 0000000..3c764e3
Binary files /dev/null and b/simpledb/query/ProjectScan.class differ
diff --git a/simpledb/query/ProjectScan.java b/simpledb/query/ProjectScan.java
new file mode 100755
index 0000000..2498ecd
--- /dev/null
+++ b/simpledb/query/ProjectScan.java
@@ -0,0 +1,68 @@
+package simpledb.query;
+
+import java.util.*;
+
+/**
+ * The scan class corresponding to the <i>project</i> relational
+ * algebra operator.
+ * All methods except hasField delegate their work to the
+ * underlying scan.
+ * @author Edward Sciore
+ */
+public class ProjectScan implements Scan {
+   private Scan s;
+   private Collection<String> fieldlist;
+   
+   /**
+    * Creates a project scan having the specified
+    * underlying scan and field list.
+    * @param s the underlying scan
+    * @param fieldlist the list of field names
+    */
+   public ProjectScan(Scan s, Collection<String> fieldlist) {
+      this.s = s;
+      this.fieldlist = fieldlist;
+   }
+   
+   public void beforeFirst() {
+      s.beforeFirst();
+   }
+   
+   public boolean next() {
+      return s.next();
+   }
+   
+   public void close() {
+      s.close();
+   }
+   
+   public Constant getVal(String fldname) {
+      if (hasField(fldname))
+         return s.getVal(fldname);
+      else
+         throw new RuntimeException("field " + fldname + " not found.");
+   }
+   
+   public int getInt(String fldname) {
+      if (hasField(fldname))
+         return s.getInt(fldname);
+      else
+         throw new RuntimeException("field " + fldname + " not found.");
+   }
+   
+   public String getString(String fldname) {
+      if (hasField(fldname))
+         return s.getString(fldname);
+      else
+         throw new RuntimeException("field " + fldname + " not found.");
+   }
+   
+   /**
+    * Returns true if the specified field
+    * is in the projection list.
+    * @see simpledb.query.Scan#hasField(java.lang.String)
+    */
+   public boolean hasField(String fldname) {
+      return fieldlist.contains(fldname);
+   }
+}
diff --git a/simpledb/query/Scan.class b/simpledb/query/Scan.class
new file mode 100755
index 0000000..c4288d1
Binary files /dev/null and b/simpledb/query/Scan.class differ
diff --git a/simpledb/query/Scan.java b/simpledb/query/Scan.java
new file mode 100755
index 0000000..4f9191c
--- /dev/null
+++ b/simpledb/query/Scan.java
@@ -0,0 +1,57 @@
+package simpledb.query;
+
+/**
+ * The interface will be implemented by each query scan.
+ * There is a Scan class for each relational
+ * algebra operator.
+ * @author Edward Sciore
+ */
+public interface Scan {
+   
+   /**
+    * Positions the scan before its first record.
+    */
+   public void     beforeFirst();
+   
+   /**
+    * Moves the scan to the next record.
+    * @return false if there is no next record
+    */
+   public boolean  next();
+   
+   /**
+    * Closes the scan and its subscans, if any. 
+    */
+   public void     close();
+   
+   /**
+    * Returns the value of the specified field in the current record.
+    * The value is expressed as a Constant.
+    * @param fldname the name of the field
+    * @return the value of that field, expressed as a Constant.
+    */
+   public Constant getVal(String fldname);
+   
+   /**
+    * Returns the value of the specified integer field 
+    * in the current record.
+    * @param fldname the name of the field
+    * @return the field's integer value in the current record
+    */
+   public int      getInt(String fldname);
+   
+   /**
+    * Returns the value of the specified string field 
+    * in the current record.
+    * @param fldname the name of the field
+    * @return the field's string value in the current record
+    */
+   public String   getString(String fldname);
+   
+   /**
+    * Returns true if the scan has the specified field.
+    * @param fldname the name of the field
+    * @return true if the scan has that field
+    */
+   public boolean  hasField(String fldname);
+}
diff --git a/simpledb/query/SelectPlan.class b/simpledb/query/SelectPlan.class
new file mode 100755
index 0000000..821f74a
Binary files /dev/null and b/simpledb/query/SelectPlan.class differ
diff --git a/simpledb/query/SelectPlan.java b/simpledb/query/SelectPlan.java
new file mode 100644
index 0000000..360bdf4
--- /dev/null
+++ b/simpledb/query/SelectPlan.java
@@ -0,0 +1,84 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/** The Plan class corresponding to the <i>select</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class SelectPlan implements Plan {
+   private Plan p;
+   private Predicate pred;
+   
+   /**
+    * Creates a new select node in the query tree,
+    * having the specified subquery and predicate.
+    * @param p the subquery
+    * @param pred the predicate
+    */
+   public SelectPlan(Plan p, Predicate pred) {
+      this.p = p;
+      this.pred = pred;
+   }
+   
+   /**
+    * Creates a select scan for this query.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s = p.open();
+      return new SelectScan(s, pred);
+   }
+   
+   /**
+    * Estimates the number of block accesses in the selection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p.blocksAccessed();
+   }
+   
+   /**
+    * Estimates the number of output records in the selection,
+    * which is determined by the 
+    * reduction factor of the predicate.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p.recordsOutput() / pred.reductionFactor(p);
+   }
+   
+   /**
+    * Estimates the number of distinct field values
+    * in the projection.
+    * If the predicate contains a term equating the specified 
+    * field to a constant, then this value will be 1.
+    * Otherwise, it will be the number of the distinct values
+    * in the underlying query 
+    * (but not more than the size of the output table).
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (pred.equatesWithConstant(fldname) != null)
+         return 1;
+      else {
+         String fldname2 = pred.equatesWithField(fldname);
+         if (fldname2 != null) 
+            return Math.min(p.distinctValues(fldname),
+                            p.distinctValues(fldname2));
+         else
+            return Math.min(p.distinctValues(fldname),
+                            recordsOutput());
+      }
+   }
+   
+   /**
+    * Returns the schema of the selection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return p.schema();
+   }
+}
diff --git a/simpledb/query/SelectPlan.java~ b/simpledb/query/SelectPlan.java~
new file mode 100644
index 0000000..ad5cb2b
--- /dev/null
+++ b/simpledb/query/SelectPlan.java~
@@ -0,0 +1,84 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/** The Plan class corresponding to the <i>select</i>
+  * relational algebra operator.
+  * @author Edward Sciore
+  */
+public class SelectPlan implements Plan {
+   private Plan p;
+   private Predicate pred;
+   
+   /**
+    * Creates a new select node in the query tree,
+    * having the specified subquery and predicate.
+    * @param p the subquery
+    * @param pred the predicate
+    */
+   public SelectPlan(Plan p, Predicate pred) {
+      this.p = p;
+      this.pred = pred;
+   }
+   
+   /**
+    * Creates a select scan for this query.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      Scan s = p.open();
+      return new SelectScan(s, pred);
+   }
+   
+   /**
+    * Estimates the number of block accesses in the selection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */
+   public int blocksAccessed() {
+      return p.blocksAccessed();
+   }
+   
+   /**
+    * Estimates the number of output records in the selection,
+    * which is determined by the 
+    * reduction factor of the predicate.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return p.recordsOutput() / pred.reductionFactor(p);
+   }
+   
+   /**
+    * Estimates the number of distinct field values
+    * in the projection.
+    * If the predicate contains a term equating the specified 
+    * field to a constant, then this value will be 1.
+    * Otherwise, it will be the number of the distinct values
+    * in the underlying query 
+    * (but not more than the size of the output table).
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      if (pred.equatesWithConstant(fldname) != null)
+         return 1;
+      else {
+          String fldname2 = pred.equatesWithField(fldname);
+          if (fldname2 != null) 
+              return Math.min(p.distinctValues(fldname),
+                              p.distinctValues(fldname2));
+          else
+              return Math.min(p.distinctValues(fldname),
+                              recordsOutput());
+      }
+   }
+   
+   /**
+    * Returns the schema of the selection,
+    * which is the same as in the underlying query.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return p.schema();
+   }
+}
diff --git a/simpledb/query/SelectScan.class b/simpledb/query/SelectScan.class
new file mode 100755
index 0000000..ef519f6
Binary files /dev/null and b/simpledb/query/SelectScan.class differ
diff --git a/simpledb/query/SelectScan.java b/simpledb/query/SelectScan.java
new file mode 100755
index 0000000..ea14ec9
--- /dev/null
+++ b/simpledb/query/SelectScan.java
@@ -0,0 +1,103 @@
+package simpledb.query;
+
+import simpledb.record.*;
+
+/**
+ * The scan class corresponding to the <i>select</i> relational
+ * algebra operator.
+ * All methods except next delegate their work to the
+ * underlying scan.
+ * @author Edward Sciore
+ */
+public class SelectScan implements UpdateScan {
+   private Scan s;
+   private Predicate pred;
+   
+   /**
+    * Creates a select scan having the specified underlying
+    * scan and predicate.
+    * @param s the scan of the underlying query
+    * @param pred the selection predicate
+    */
+   public SelectScan(Scan s, Predicate pred) {
+      this.s = s;
+      this.pred = pred;
+   }
+   
+   // Scan methods
+   
+   public void beforeFirst() {
+      s.beforeFirst();
+   }
+   
+   /**
+    * Move to the next record satisfying the predicate.
+    * The method repeatedly calls next on the underlying scan
+    * until a suitable record is found, or the underlying scan
+    * contains no more records.
+    * @see simpledb.query.Scan#next()
+    */
+   public boolean next() {
+      while (s.next())
+         if (pred.isSatisfied(s))
+         return true;
+      return false;
+   }
+   
+   public void close() {
+      s.close();
+   }
+   
+   public Constant getVal(String fldname) {
+      return s.getVal(fldname);
+   }
+   
+   public int getInt(String fldname) {
+      return s.getInt(fldname);
+   }
+   
+   public String getString(String fldname) {
+      return s.getString(fldname);
+   }
+   
+   public boolean hasField(String fldname) {
+      return s.hasField(fldname);
+   }
+   
+   // UpdateScan methods
+   
+   public void setVal(String fldname, Constant val) {
+      UpdateScan us = (UpdateScan) s;
+      us.setVal(fldname, val);
+   }
+   
+   public void setInt(String fldname, int val) {
+      UpdateScan us = (UpdateScan) s;
+      us.setInt(fldname, val);
+   }
+   
+   public void setString(String fldname, String val) {
+      UpdateScan us = (UpdateScan) s;
+      us.setString(fldname, val);
+   }
+   
+   public void delete() {
+      UpdateScan us = (UpdateScan) s;
+      us.delete();
+   }
+   
+   public void insert() {
+      UpdateScan us = (UpdateScan) s;
+      us.insert();
+   }
+   
+   public RID getRid() {
+      UpdateScan us = (UpdateScan) s;
+      return us.getRid();
+   }
+   
+   public void moveToRid(RID rid) {
+      UpdateScan us = (UpdateScan) s;
+      us.moveToRid(rid);
+   }
+}
diff --git a/simpledb/query/StringConstant.class b/simpledb/query/StringConstant.class
new file mode 100755
index 0000000..805668d
Binary files /dev/null and b/simpledb/query/StringConstant.class differ
diff --git a/simpledb/query/StringConstant.java b/simpledb/query/StringConstant.java
new file mode 100755
index 0000000..b3884a9
--- /dev/null
+++ b/simpledb/query/StringConstant.java
@@ -0,0 +1,43 @@
+package simpledb.query;
+
+/**
+ * The class that wraps Java strings as database constants.
+ * @author Edward Sciore
+ */
+public class StringConstant implements Constant {
+   private String val;
+   
+   /**
+    * Create a constant by wrapping the specified string.
+    * @param s the string value
+    */
+   public StringConstant(String s) {
+      val = s;
+   }
+   
+   /**
+    * Unwraps the string and returns it.
+    * @see simpledb.query.Constant#asJavaVal()
+    */
+   public String asJavaVal() {
+      return val;
+   }
+   
+   public boolean equals(Object obj) {
+      StringConstant sc = (StringConstant) obj;
+      return sc != null && val.equals(sc.val);
+   }
+   
+   public int compareTo(Constant c) {
+      StringConstant sc = (StringConstant) c;
+      return val.compareTo(sc.val);
+   }
+   
+   public int hashCode() {
+      return val.hashCode();
+   }
+   
+   public String toString() {
+      return val;
+   }
+}
diff --git a/simpledb/query/TablePlan.class b/simpledb/query/TablePlan.class
new file mode 100755
index 0000000..bfc58d8
Binary files /dev/null and b/simpledb/query/TablePlan.class differ
diff --git a/simpledb/query/TablePlan.java b/simpledb/query/TablePlan.java
new file mode 100755
index 0000000..4e6b949
--- /dev/null
+++ b/simpledb/query/TablePlan.java
@@ -0,0 +1,71 @@
+package simpledb.query;
+
+import simpledb.server.SimpleDB;
+import simpledb.tx.Transaction;
+import simpledb.metadata.*;
+import simpledb.record.*;
+
+/** The Plan class corresponding to a table.
+  * @author Edward Sciore
+  */
+public class TablePlan implements Plan {
+   private Transaction tx;
+   private TableInfo ti;
+   private StatInfo si;
+   
+   /**
+    * Creates a leaf node in the query tree corresponding
+    * to the specified table.
+    * @param tblname the name of the table
+    * @param tx the calling transaction
+    */
+   public TablePlan(String tblname, Transaction tx) {
+      this.tx = tx;
+      ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
+      si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
+   }
+   
+   /**
+    * Creates a table scan for this query.
+    * @see simpledb.query.Plan#open()
+    */
+   public Scan open() {
+      return new TableScan(ti, tx);
+   }
+   
+   /**
+    * Estimates the number of block accesses for the table,
+    * which is obtainable from the statistics manager.
+    * @see simpledb.query.Plan#blocksAccessed()
+    */ 
+   public int blocksAccessed() {
+      return si.blocksAccessed();
+   }
+   
+   /**
+    * Estimates the number of records in the table,
+    * which is obtainable from the statistics manager.
+    * @see simpledb.query.Plan#recordsOutput()
+    */
+   public int recordsOutput() {
+      return si.recordsOutput();
+   }
+   
+   /**
+    * Estimates the number of distinct field values in the table,
+    * which is obtainable from the statistics manager.
+    * @see simpledb.query.Plan#distinctValues(java.lang.String)
+    */
+   public int distinctValues(String fldname) {
+      return si.distinctValues(fldname);
+   }
+   
+   /**
+    * Determines the schema of the table,
+    * which is obtainable from the catalog manager.
+    * @see simpledb.query.Plan#schema()
+    */
+   public Schema schema() {
+      return ti.schema();
+   }
+}
diff --git a/simpledb/query/TableScan.class b/simpledb/query/TableScan.class
new file mode 100755
index 0000000..61f3c49
Binary files /dev/null and b/simpledb/query/TableScan.class differ
diff --git a/simpledb/query/TableScan.java b/simpledb/query/TableScan.java
new file mode 100755
index 0000000..d13d26f
--- /dev/null
+++ b/simpledb/query/TableScan.java
@@ -0,0 +1,109 @@
+package simpledb.query;
+
+import static java.sql.Types.INTEGER;
+import simpledb.tx.Transaction;
+import simpledb.record.*;
+
+/**
+ * The Scan class corresponding to a table.
+ * A table scan is just a wrapper for a RecordFile object;
+ * most methods just delegate to the corresponding
+ * RecordFile methods.
+ * @author Edward Sciore
+ *
+ */
+public class TableScan implements UpdateScan {
+   private RecordFile rf;
+   private Schema sch;
+   
+   /**
+    * Creates a new table scan,
+    * and opens its corresponding record file. 
+    * @param ti the table's metadata
+    * @param tx the calling transaction
+    */
+   public TableScan(TableInfo ti, Transaction tx) {
+      rf  = new RecordFile(ti, tx);
+      sch = ti.schema();
+   }
+   
+   // Scan methods
+   
+   public void beforeFirst() {
+      rf.beforeFirst();
+   }
+   
+   public boolean next() {
+      return rf.next();
+   }
+   
+   public void close() {
+      rf.close();
+   }
+   
+   /**
+    * Returns the value of the specified field, as a Constant.
+    * The schema is examined to determine the field's type.
+    * If INTEGER, then the record file's getInt method is called;
+    * otherwise, the getString method is called.
+    * @see simpledb.query.Scan#getVal(java.lang.String)
+    */
+   public Constant getVal(String fldname) {
+      if (sch.type(fldname) == INTEGER)
+         return new IntConstant(rf.getInt(fldname));
+      else
+         return new StringConstant(rf.getString(fldname));
+   }
+   
+   public int getInt(String fldname) {
+      return rf.getInt(fldname);
+   }
+   
+   public String getString(String fldname) {
+      return rf.getString(fldname);
+   }
+   
+   public boolean hasField(String fldname) {
+      return sch.hasField(fldname);
+   }
+   
+   // UpdateScan methods
+   
+   /**
+    * Sets the value of the specified field, as a Constant.
+    * The schema is examined to determine the field's type.
+    * If INTEGER, then the record file's setInt method is called;
+    * otherwise, the setString method is called.
+    * @see simpledb.query.UpdateScan#setVal(java.lang.String, simpledb.query.Constant)
+    */ 
+   public void setVal(String fldname, Constant val) {
+      if (sch.type(fldname) == INTEGER)
+         rf.setInt(fldname, (Integer)val.asJavaVal());
+      else
+         rf.setString(fldname, (String)val.asJavaVal());
+   }
+   
+   public void setInt(String fldname, int val) {
+      rf.setInt(fldname, val);
+   }
+   
+   public void setString(String fldname, String val) {
+      rf.setString(fldname, val);
+   }
+   
+   public void delete() {
+      rf.delete();
+   }
+   
+   public void insert() {
+      rf.insert();
+   }
+   
+   public RID getRid() {
+      return rf.currentRid();
+   }
+   
+   public void moveToRid(RID rid) {
+      rf.moveToRid(rid);
+   }
+}
diff --git a/simpledb/query/Term.class b/simpledb/query/Term.class
new file mode 100755
index 0000000..4936314
Binary files /dev/null and b/simpledb/query/Term.class differ
diff --git a/simpledb/query/Term.java b/simpledb/query/Term.java
new file mode 100755
index 0000000..fef85d1
--- /dev/null
+++ b/simpledb/query/Term.java
@@ -0,0 +1,123 @@
+package simpledb.query;
+
+import simpledb.record.Schema;
+
+/**
+ * A term is a comparison between two expressions.
+ * @author Edward Sciore
+ *
+ */
+public class Term {
+   private Expression lhs, rhs;
+   
+   /**
+    * Creates a new term that compares two expressions
+    * for equality.
+    * @param lhs  the LHS expression
+    * @param rhs  the RHS expression
+    */
+   public Term(Expression lhs, Expression rhs) {
+      this.lhs = lhs;
+      this.rhs = rhs;
+   }
+   
+   /**
+    * Calculates the extent to which selecting on the term reduces 
+    * the number of records output by a query.
+    * For example if the reduction factor is 2, then the
+    * term cuts the size of the output in half.
+    * @param p the query's plan
+    * @return the integer reduction factor.
+    */
+   public int reductionFactor(Plan p) {
+      String lhsName, rhsName;
+      if (lhs.isFieldName() && rhs.isFieldName()) {
+         lhsName = lhs.asFieldName();
+         rhsName = rhs.asFieldName();
+         return Math.max(p.distinctValues(lhsName),
+                         p.distinctValues(rhsName));
+      }
+      if (lhs.isFieldName()) {
+         lhsName = lhs.asFieldName();
+         return p.distinctValues(lhsName);
+      }
+      if (rhs.isFieldName()) {
+         rhsName = rhs.asFieldName();
+         return p.distinctValues(rhsName);
+      }
+      // otherwise, the term equates constants
+      if (lhs.asConstant().equals(rhs.asConstant()))
+         return 1;
+      else
+         return Integer.MAX_VALUE;
+   }
+   
+   /**
+    * Determines if this term is of the form "F=c"
+    * where F is the specified field and c is some constant.
+    * If so, the method returns that constant.
+    * If not, the method returns null.
+    * @param fldname the name of the field
+    * @return either the constant or null
+    */
+   public Constant equatesWithConstant(String fldname) {
+      if (lhs.isFieldName() &&
+          lhs.asFieldName().equals(fldname) &&
+          rhs.isConstant())
+         return rhs.asConstant();
+      else if (rhs.isFieldName() &&
+               rhs.asFieldName().equals(fldname) &&
+               lhs.isConstant())
+         return lhs.asConstant();
+      else
+         return null;
+   }
+   
+   /**
+    * Determines if this term is of the form "F1=F2"
+    * where F1 is the specified field and F2 is another field.
+    * If so, the method returns the name of that field.
+    * If not, the method returns null.
+    * @param fldname the name of the field
+    * @return either the name of the other field, or null
+    */
+   public String equatesWithField(String fldname) {
+      if (lhs.isFieldName() &&
+          lhs.asFieldName().equals(fldname) &&
+          rhs.isFieldName())
+         return rhs.asFieldName();
+      else if (rhs.isFieldName() &&
+               rhs.asFieldName().equals(fldname) &&
+               lhs.isFieldName())
+         return lhs.asFieldName();
+      else
+         return null;
+   }
+   
+   /**
+    * Returns true if both of the term's expressions
+    * apply to the specified schema.
+    * @param sch the schema
+    * @return true if both expressions apply to the schema
+    */
+   public boolean appliesTo(Schema sch) {
+      return lhs.appliesTo(sch) && rhs.appliesTo(sch);
+   }
+   
+   /**
+    * Returns true if both of the term's expressions
+    * evaluate to the same constant,
+    * with respect to the specified scan.
+    * @param s the scan
+    * @return true if both expressions have the same value in the scan
+    */
+   public boolean isSatisfied(Scan s) {
+      Constant lhsval = lhs.evaluate(s);
+      Constant rhsval = rhs.evaluate(s);
+      return rhsval.equals(lhsval);
+   }
+   
+   public String toString() {
+      return lhs.toString() + "=" + rhs.toString();
+   }
+}
diff --git a/simpledb/query/UpdateScan.class b/simpledb/query/UpdateScan.class
new file mode 100755
index 0000000..8d27e6a
Binary files /dev/null and b/simpledb/query/UpdateScan.class differ
diff --git a/simpledb/query/UpdateScan.java b/simpledb/query/UpdateScan.java
new file mode 100755
index 0000000..e9e3a63
--- /dev/null
+++ b/simpledb/query/UpdateScan.java
@@ -0,0 +1,53 @@
+package simpledb.query;
+
+import simpledb.record.RID;
+
+/**
+ * The interface implemented by all updateable scans.
+ * @author Edward Sciore
+ */
+public interface UpdateScan extends Scan {
+   /**
+    * Modifies the field value of the current record.
+    * @param fldname the name of the field
+    * @param val the new value, expressed as a Constant
+    */
+   public void setVal(String fldname, Constant val);
+   
+   /**
+    * Modifies the field value of the current record.
+    * @param fldname the name of the field
+    * @param val the new integer value
+    */
+   public void setInt(String fldname, int val);
+   
+   /**
+    * Modifies the field value of the current record.
+    * @param fldname the name of the field
+    * @param val the new string value
+    */
+   public void setString(String fldname, String val);
+   
+   /**
+    * Inserts a new record somewhere in the scan.
+    */
+   public void insert();
+   
+   /**
+    * Deletes the current record from the scan.
+    */
+   public void delete();
+   
+   /**
+    * Returns the RID of the current record.
+    * @return the RID of the current record
+    */
+   public RID  getRid();
+   
+   /**
+    * Positions the scan so that the current record has
+    * the specified RID.
+    * @param rid the RID of the desired record
+    */
+   public void moveToRid(RID rid);
+}
diff --git a/simpledb/record/RID.class b/simpledb/record/RID.class
new file mode 100755
index 0000000..fd49e40
Binary files /dev/null and b/simpledb/record/RID.class differ
diff --git a/simpledb/record/RID.java b/simpledb/record/RID.java
new file mode 100755
index 0000000..b76cbbe
--- /dev/null
+++ b/simpledb/record/RID.java
@@ -0,0 +1,48 @@
+package simpledb.record;
+
+/**
+ * An identifier for a record within a file.
+ * A RID consists of the block number in the file,
+ * and the ID of the record in that block.
+ * @author Edward Sciore
+ */
+public class RID {
+	private int blknum;
+	private int id;
+
+	/**
+	 * Creates a RID for the record having the
+	 * specified ID in the specified block.
+	 * @param blknum the block number where the record lives
+	 * @param id the record's ID
+	 */
+	public RID(int blknum, int id) {
+		this.blknum = blknum;
+		this.id     = id;
+	}
+
+	/**
+	 * Returns the block number associated with this RID.
+	 * @return the block number
+	 */
+	public int blockNumber() {
+		return blknum;
+	}
+
+	/**
+	 * Returns the ID associated with this RID.
+	 * @return the ID
+	 */
+	public int id() {
+		return id;
+	}
+
+	public boolean equals(Object obj) {
+		RID r = (RID) obj;
+		return blknum == r.blknum && id==r.id;
+	}
+
+	public String toString() {
+		return "[" + blknum + ", " + id + "]";
+	}
+}
diff --git a/simpledb/record/RecordFile.class b/simpledb/record/RecordFile.class
new file mode 100755
index 0000000..fc45218
Binary files /dev/null and b/simpledb/record/RecordFile.class differ
diff --git a/simpledb/record/RecordFile.java b/simpledb/record/RecordFile.java
new file mode 100755
index 0000000..0c463ca
--- /dev/null
+++ b/simpledb/record/RecordFile.java
@@ -0,0 +1,164 @@
+package simpledb.record;
+
+import simpledb.file.Block;
+import simpledb.tx.Transaction;
+
+/**
+ * Manages a file of records.
+ * There are methods for iterating through the records
+ * and accessing their contents.
+ * @author Edward Sciore
+ */
+public class RecordFile {
+   private TableInfo ti;
+   private Transaction tx;
+   private String filename;
+   private RecordPage rp;
+   private int currentblknum;
+   
+   /**
+    * Constructs an object to manage a file of records.
+    * If the file does not exist, it is created.
+    * @param ti the table metadata
+    * @param tx the transaction
+    */
+   public RecordFile(TableInfo ti, Transaction tx) {
+      this.ti = ti;
+      this.tx = tx;
+      filename = ti.fileName();
+      if (tx.size(filename) == 0)
+         appendBlock();
+      moveTo(0);
+   }
+   
+   /**
+    * Closes the record file.
+    */
+   public void close() {
+      rp.close();
+   }
+   
+   /**
+    * Positions the current record so that a call to method next
+    * will wind up at the first record. 
+    */
+   public void beforeFirst() {
+      moveTo(0);
+   }
+   
+   /**
+    * Moves to the next record. Returns false if there
+    * is no next record.
+    * @return false if there is no next record.
+    */
+   public boolean next() {
+      while (true) {
+         if (rp.next())
+            return true;
+         if (atLastBlock())
+            return false;
+         moveTo(currentblknum + 1);
+      }
+   }
+   
+   /**
+    * Returns the value of the specified field
+    * in the current record.
+    * @param fldname the name of the field
+    * @return the integer value at that field
+    */
+   public int getInt(String fldname) {
+      return rp.getInt(fldname);
+   }
+   
+   /**
+    * Returns the value of the specified field
+    * in the current record.
+    * @param fldname the name of the field
+    * @return the string value at that field
+    */
+   public String getString(String fldname) {
+      return rp.getString(fldname);
+   }
+   
+   /**
+    * Sets the value of the specified field 
+    * in the current record.
+    * @param fldname the name of the field
+    * @param val the new value for the field
+    */
+   public void setInt(String fldname, int val) {
+      rp.setInt(fldname, val);
+   }
+   
+   /**
+    * Sets the value of the specified field 
+    * in the current record.
+    * @param fldname the name of the field
+    * @param val the new value for the field
+    */
+   public void setString(String fldname, String val) {
+      rp.setString(fldname, val);
+   }
+   
+   /**
+    * Deletes the current record.
+    * The client must call next() to move to
+    * the next record.
+    * Calls to methods on a deleted record 
+    * have unspecified behavior.
+    */
+   public void delete() {
+      rp.delete();
+   }
+   
+   /**
+    * Inserts a new, blank record somewhere in the file
+    * beginning at the current record.
+    * If the new record does not fit into an existing block,
+    * then a new block is appended to the file.
+    */
+   public void insert() {
+      while (!rp.insert()) {
+         if (atLastBlock())
+            appendBlock();
+         moveTo(currentblknum + 1);
+      }
+   }
+   
+   /**
+    * Positions the current record as indicated by the
+    * specified RID. 
+    * @param rid a record identifier
+    */
+   public void moveToRid(RID rid) {
+      moveTo(rid.blockNumber());
+      rp.moveToId(rid.id());
+   }
+   
+   /**
+    * Returns the RID of the current record.
+    * @return a record identifier
+    */
+   public RID currentRid() {
+      int id = rp.currentId();
+      return new RID(currentblknum, id);
+   }
+   
+   private void moveTo(int b) {
+      if (rp != null)
+         rp.close();
+      currentblknum = b;
+      Block blk = new Block(filename, currentblknum);
+      rp = new RecordPage(blk, ti, tx);
+   }
+   
+   private boolean atLastBlock() {
+      return currentblknum == tx.size(filename) - 1;
+   }
+   
+   private void appendBlock() {
+      RecordFormatter fmtr = new RecordFormatter(ti);
+      tx.append(filename, fmtr);
+   }
+}
\ No newline at end of file
diff --git a/simpledb/record/RecordFormatter.class b/simpledb/record/RecordFormatter.class
new file mode 100755
index 0000000..4d1e210
Binary files /dev/null and b/simpledb/record/RecordFormatter.class differ
diff --git a/simpledb/record/RecordFormatter.java b/simpledb/record/RecordFormatter.java
new file mode 100755
index 0000000..9059544
--- /dev/null
+++ b/simpledb/record/RecordFormatter.java
@@ -0,0 +1,50 @@
+package simpledb.record;
+
+import static java.sql.Types.INTEGER;
+import static simpledb.file.Page.*;
+import static simpledb.record.RecordPage.EMPTY;
+import simpledb.file.Page;
+import simpledb.buffer.PageFormatter;
+
+/**
+ * An object that can format a page to look like a block of 
+ * empty records.
+ * @author Edward Sciore
+ */
+class RecordFormatter implements PageFormatter {
+   private TableInfo ti;
+   
+   /**
+    * Creates a formatter for a new page of a table.
+    * @param ti the table's metadata
+    */
+   public RecordFormatter(TableInfo ti) {
+      this.ti = ti;
+   }
+   
+   /** 
+    * Formats the page by allocating as many record slots
+    * as possible, given the record length.
+    * Each record slot is assigned a flag of EMPTY.
+    * Each integer field is given a value of 0, and
+    * each string field is given a value of "".
+    * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
+    */
+   public void format(Page page) {
+      int recsize = ti.recordLength() + INT_SIZE;
+      for (int pos=0; pos+recsize<=BLOCK_SIZE; pos += recsize) {
+         page.setInt(pos, EMPTY);
+         makeDefaultRecord(page, pos);
+      }
+   }
+   
+   private void makeDefaultRecord(Page page, int pos) {
+      for (String fldname : ti.schema().fields()) {
+         int offset = ti.offset(fldname);
+         if (ti.schema().type(fldname) == INTEGER)
+            page.setInt(pos + INT_SIZE + offset, 0);
+         else
+            page.setString(pos + INT_SIZE + offset, "");
+      }
+   }
+}
diff --git a/simpledb/record/RecordPage.class b/simpledb/record/RecordPage.class
new file mode 100755
index 0000000..226da80
Binary files /dev/null and b/simpledb/record/RecordPage.class differ
diff --git a/simpledb/record/RecordPage.java b/simpledb/record/RecordPage.java
new file mode 100755
index 0000000..5cbf4ae
--- /dev/null
+++ b/simpledb/record/RecordPage.java
@@ -0,0 +1,162 @@
+package simpledb.record;
+
+import static simpledb.file.Page.*;
+import simpledb.file.Block;
+import simpledb.tx.Transaction;
+
+/**
+ * Manages the placement and access of records in a block.
+ * @author Edward Sciore
+ */
+public class RecordPage {
+   public static final int EMPTY = 0, INUSE = 1;
+   
+   private Block blk;
+   private TableInfo ti;
+   private Transaction tx;
+   private int slotsize;
+   private int currentslot = -1;
+   
+   /** Creates the record manager for the specified block.
+     * The current record is set to be prior to the first one.
+     * @param blk a reference to the disk block
+     * @param ti the table's metadata
+     * @param tx the transaction performing the operations
+     */
+   public RecordPage(Block blk, TableInfo ti, Transaction tx) {
+      this.blk = blk;
+      this.ti = ti;
+      this.tx = tx;
+      slotsize = ti.recordLength() + INT_SIZE;
+      tx.pin(blk);
+  }
+   
+   /**
+    * Closes the manager, by unpinning the block.
+    */
+   public void close() {
+      if (blk != null) {
+    	  tx.unpin(blk);
+    	  blk = null;
+      }
+   }
+   
+   /**
+    * Moves to the next record in the block.
+    * @return false if there is no next record.
+    */
+   public boolean next() {
+      return searchFor(INUSE);
+   }
+   
+   /**
+    * Returns the integer value stored for the
+    * specified field of the current record.
+    * @param fldname the name of the field.
+    * @return the integer stored in that field
+    */
+   public int getInt(String fldname) {
+      int position = fieldpos(fldname);
+      return tx.getInt(blk, position);
+   }
+   
+   /**
+    * Returns the string value stored for the
+    * specified field of the current record.
+    * @param fldname the name of the field.
+    * @return the string stored in that field
+    */
+   public String getString(String fldname) {
+      int position = fieldpos(fldname);
+      return tx.getString(blk, position);
+   }
+   
+   /**
+    * Stores an integer at the specified field
+    * of the current record.
+    * @param fldname the name of the field
+    * @param val the integer value stored in that field
+    */
+   public void setInt(String fldname, int val) {
+      int position = fieldpos(fldname);
+      tx.setInt(blk, position, val);
+   }
+   
+   /**
+    * Stores a string at the specified field
+    * of the current record.
+    * @param fldname the name of the field
+    * @param val the string value stored in that field
+    */
+   public void setString(String fldname, String val) {
+      int position = fieldpos(fldname);
+      tx.setString(blk, position, val);
+   }
+   
+   /**
+    * Deletes the current record.
+    * Deletion is performed by just marking the record
+    * as "deleted"; the current record does not change. 
+    * To get to the next record, call next().
+    */
+   public void delete() {
+      int position = currentpos();
+      tx.setInt(blk, position, EMPTY);
+   }
+   
+   /**
+    * Inserts a new, blank record somewhere in the page.
+    * Return false if there were no available slots.
+    * @return false if the insertion was not possible
+    */
+   public boolean insert() {
+      currentslot = -1;
+      boolean found = searchFor(EMPTY);
+      if (found) {
+         int position = currentpos();
+         tx.setInt(blk, position, INUSE);
+      }
+      return found;
+   }
+   
+   /**
+    * Sets the current record to be the record having the
+    * specified ID.
+    * @param id the ID of the record within the page.
+    */
+   public void moveToId(int id) {
+      currentslot = id;
+   }
+   
+   /**
+    * Returns the ID of the current record.
+    * @return the ID of the current record
+    */
+   public int currentId() {
+      return currentslot;
+   }
+   
+   private int currentpos() {
+      return currentslot * slotsize;
+   }
+   
+   private int fieldpos(String fldname) {
+      int offset = INT_SIZE + ti.offset(fldname);
+      return currentpos() + offset;
+   }
+   
+   private boolean isValidSlot() {
+      return currentpos() + slotsize <= BLOCK_SIZE;
+   }
+   
+   private boolean searchFor(int flag) {
+      currentslot++;
+      while (isValidSlot()) {
+         int position = currentpos();
+         if (tx.getInt(blk, position) == flag)
+            return true;
+         currentslot++;
+      }
+      return false;
+   }
+}
diff --git a/simpledb/record/Schema$FieldInfo.class b/simpledb/record/Schema$FieldInfo.class
new file mode 100755
index 0000000..df484c1
Binary files /dev/null and b/simpledb/record/Schema$FieldInfo.class differ
diff --git a/simpledb/record/Schema.class b/simpledb/record/Schema.class
new file mode 100755
index 0000000..8361bb1
Binary files /dev/null and b/simpledb/record/Schema.class differ
diff --git a/simpledb/record/Schema.java b/simpledb/record/Schema.java
new file mode 100755
index 0000000..155391e
--- /dev/null
+++ b/simpledb/record/Schema.java
@@ -0,0 +1,126 @@
+package simpledb.record;
+
+import static java.sql.Types.*;
+import java.util.*;
+
+/**
+ * The record schema of a table.
+ * A schema contains the name and type of
+ * each field of the table, as well as the length
+ * of each varchar field.
+ * @author Edward Sciore
+ *
+ */
+public class Schema {
+   private Map<String,FieldInfo> info = new HashMap<String,FieldInfo>();
+   
+   /**
+    * Creates an empty schema.
+    * Field information can be added to a schema
+    * via the five addXXX methods. 
+    */
+   public Schema() {}
+   
+   /**
+    * Adds a field to the schema having a specified
+    * name, type, and length.
+    * If the field type is "integer", then the length
+    * value is irrelevant.
+    * @param fldname the name of the field
+    * @param type the type of the field, according to the constants in simpledb.sql.types
+    * @param length the conceptual length of a string field.
+    */
+   public void addField(String fldname, int type, int length) {
+      info.put(fldname, new FieldInfo(type, length));
+   }
+   
+   /**
+    * Adds an integer field to the schema.
+    * @param fldname the name of the field
+    */
+   public void addIntField(String fldname) {
+      addField(fldname, INTEGER, 0);
+   }
+   
+   /**
+    * Adds a string field to the schema.
+    * The length is the conceptual length of the field.
+    * For example, if the field is defined as varchar(8),
+    * then its length is 8.
+    * @param fldname the name of the field
+    * @param length the number of chars in the varchar definition
+    */
+   public void addStringField(String fldname, int length) {
+      addField(fldname, VARCHAR, length);
+   }
+   
+   /**
+    * Adds a field to the schema having the same
+    * type and length as the corresponding field
+    * in another schema.
+    * @param fldname the name of the field
+    * @param sch the other schema
+    */
+   public void add(String fldname, Schema sch) {
+      int type   = sch.type(fldname);
+      int length = sch.length(fldname);
+      addField(fldname, type, length);
+   }
+   
+   /**
+    * Adds all of the fields in the specified schema
+    * to the current schema.
+    * @param sch the other schema
+    */
+   public void addAll(Schema sch) {
+      info.putAll(sch.info);
+   }
+   
+   /**
+    * Returns a collection containing the name of
+    * each field in the schema.
+    * @return the collection of the schema's field names
+    */
+   public Collection<String> fields() {
+      return info.keySet();
+   }
+   
+   /**
+    * Returns true if the specified field
+    * is in the schema
+    * @param fldname the name of the field
+    * @return true if the field is in the schema
+    */
+   public boolean hasField(String fldname) {
+      return fields().contains(fldname);
+   }
+   
+   /**
+    * Returns the type of the specified field, using the
+    * constants in {@link java.sql.Types}.
+    * @param fldname the name of the field
+    * @return the integer type of the field
+    */
+   public int type(String fldname) {
+      return info.get(fldname).type;
+   }
+   
+   /**
+    * Returns the conceptual length of the specified field.
+    * If the field is not a string field, then
+    * the return value is undefined.
+    * @param fldname the name of the field
+    * @return the conceptual length of the field
+    */
+   public int length(String fldname) {
+      return info.get(fldname).length;
+   }
+   
+   class FieldInfo {
+      int type, length;
+      public FieldInfo(int type, int length) {
+         this.type = type;
+         this.length = length;
+      }
+   }
+}
diff --git a/simpledb/record/TableInfo.class b/simpledb/record/TableInfo.class
new file mode 100755
index 0000000..a0cc903
Binary files /dev/null and b/simpledb/record/TableInfo.class differ
diff --git a/simpledb/record/TableInfo.java b/simpledb/record/TableInfo.java
new file mode 100755
index 0000000..883d7cb
--- /dev/null
+++ b/simpledb/record/TableInfo.java
@@ -0,0 +1,96 @@
+package simpledb.record;
+
+import static java.sql.Types.INTEGER;
+import static simpledb.file.Page.*;
+import java.util.*;
+
+/**
+ * The metadata about a table and its records.
+ * @author Edward Sciore
+ */
+public class TableInfo {
+   private Schema schema;
+   private Map<String,Integer> offsets;
+   private int recordlen;
+   private String tblname;
+   
+   /**
+    * Creates a TableInfo object, given a table name
+    * and schema. The constructor calculates the
+    * physical offset of each field.
+    * This constructor is used when a table is created. 
+    * @param tblname the name of the table
+    * @param schema the schema of the table's records
+    */
+   public TableInfo(String tblname, Schema schema) {
+      this.schema = schema;
+      this.tblname = tblname;
+      offsets  = new HashMap<String,Integer>();
+      int pos = 0;
+      for (String fldname : schema.fields()) {
+         offsets.put(fldname, pos);
+         pos += lengthInBytes(fldname);
+      }
+      recordlen = pos;
+   }
+   
+   /**
+    * Creates a TableInfo object from the 
+    * specified metadata.
+    * This constructor is used when the metadata
+    * is retrieved from the catalog.
+    * @param tblname the name of the table
+    * @param schema the schema of the table's records
+    * @param offsets the already-calculated offsets of the fields within a record
+    * @param recordlen the already-calculated length of each record
+    */
+   public TableInfo(String tblname, Schema schema, Map<String,Integer> offsets, int recordlen) {
+      this.tblname   = tblname;
+      this.schema    = schema;
+      this.offsets   = offsets;
+      this.recordlen = recordlen;
+   }
+   
+   /**
+    * Returns the filename assigned to this table.
+    * Currently, the filename is the table name
+    * followed by ".tbl".
+    * @return the name of the file assigned to the table
+    */
+   public String fileName() {
+      return tblname + ".tbl";
+   }
+   
+   /**
+    * Returns the schema of the table's records
+    * @return the table's record schema
+    */
+   public Schema schema() {
+      return schema;
+   }
+   
+   /**
+    * Returns the offset of a specified field within a record
+    * @param fldname the name of the field
+    * @return the offset of that field within a record
+    */
+   public int offset(String fldname) {
+      return offsets.get(fldname);
+   }
+   
+   /**
+    * Returns the length of a record, in bytes.
+    * @return the length in bytes of a record
+    */
+   public int recordLength() {
+      return recordlen;
+   }
+   
+   private int lengthInBytes(String fldname) {
+      int fldtype = schema.type(fldname);
+      if (fldtype == INTEGER)
+         return INT_SIZE;
+      else
+         return STR_SIZE(schema.length(fldname));
+   }
+}
\ No newline at end of file
diff --git a/simpledb/remote/ConnectionAdapter.class b/simpledb/remote/ConnectionAdapter.class
new file mode 100755
index 0000000..27982ae
Binary files /dev/null and b/simpledb/remote/ConnectionAdapter.class differ
diff --git a/simpledb/remote/ConnectionAdapter.java b/simpledb/remote/ConnectionAdapter.java
new file mode 100755
index 0000000..60e1335
--- /dev/null
+++ b/simpledb/remote/ConnectionAdapter.java
@@ -0,0 +1,207 @@
+package simpledb.remote;
+
+import java.sql.*;
+import java.util.*;
+
+/**
+ * This class implements all of the methods of the Connection interface,
+ * by throwing an exception for each one.
+ * Subclasses (such as SimpleConnection) can override those methods that 
+ * it want to implement.
+ * @author Edward Sciore
+ */
+public abstract class ConnectionAdapter implements Connection {
+   public void clearWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void close() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void commit() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Blob createBlob() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Clob createClob() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public NClob createNClob() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLXML createSQLXML() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Statement createStatement() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean getAutoCommit() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getCatalog() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Properties getClientInfo() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getClientInfo(String name) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getHoldability() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public DatabaseMetaData getMetaData() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getTransactionIsolation() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Map<String,Class<?>> getTypeMap() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLWarning getWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isClosed() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isReadOnly() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isValid(int timeout) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String nativeSQL(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public CallableStatement prepareCall(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void releaseSavepoint(Savepoint savepoint) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void rollback() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void rollback(Savepoint svepoint) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setAutoCommit(boolean autoCommit) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setCatalog(String catalog) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setClientInfo(String name, String value) {
+   }
+   
+   public void setClientInfo(Properties properties) {
+   }
+   
+   public void setHoldability(int holdability) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setReadOnly(boolean readOnly) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Savepoint setSavepoint() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Savepoint setSavepoint(String name) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setTransactionIsolation(int level) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setTypeMap(Map<String,Class<?>> map) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isWrapperFor(Class<?> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public <T> T unwrap(Class<T> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+}
\ No newline at end of file
diff --git a/simpledb/remote/DriverAdapter.class b/simpledb/remote/DriverAdapter.class
new file mode 100755
index 0000000..986d084
Binary files /dev/null and b/simpledb/remote/DriverAdapter.class differ
diff --git a/simpledb/remote/DriverAdapter.java b/simpledb/remote/DriverAdapter.java
new file mode 100755
index 0000000..81dc727
--- /dev/null
+++ b/simpledb/remote/DriverAdapter.java
@@ -0,0 +1,37 @@
+package simpledb.remote;
+
+import java.sql.*;
+import java.util.*;
+
+/**
+ * This class implements all of the methods of the Driver interface,
+ * by throwing an exception for each one.
+ * Subclasses (such as SimpleDriver) can override those methods that 
+ * it want to implement.
+ * @author Edward Sciore
+ */
+public abstract class DriverAdapter implements Driver {
+   public boolean acceptsURL(String url) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Connection connect(String url, Properties info) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getMajorVersion() {
+      return 0;
+   }
+   
+   public int getMinorVersion() {
+      return 0;
+   }
+   
+   public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
+      return null;
+   }
+   
+   public boolean jdbcCompliant() {
+      return false;
+   }
+}
\ No newline at end of file
diff --git a/simpledb/remote/RemoteConnection.class b/simpledb/remote/RemoteConnection.class
new file mode 100755
index 0000000..2ba5375
Binary files /dev/null and b/simpledb/remote/RemoteConnection.class differ
diff --git a/simpledb/remote/RemoteConnection.java b/simpledb/remote/RemoteConnection.java
new file mode 100755
index 0000000..a65dbd8
--- /dev/null
+++ b/simpledb/remote/RemoteConnection.java
@@ -0,0 +1,15 @@
+package simpledb.remote;
+
+import java.rmi.*;
+
+/**
+ * The RMI remote interface corresponding to Connection.
+ * The methods are identical to those of Connection, 
+ * except that they throw RemoteExceptions instead of SQLExceptions.
+ * @author Edward Sciore
+ */
+public interface RemoteConnection extends Remote {
+   public RemoteStatement createStatement() throws RemoteException;
+   public void close() throws RemoteException;
+}
+
diff --git a/simpledb/remote/RemoteConnectionImpl.class b/simpledb/remote/RemoteConnectionImpl.class
new file mode 100755
index 0000000..06aeab0
Binary files /dev/null and b/simpledb/remote/RemoteConnectionImpl.class differ
diff --git a/simpledb/remote/RemoteConnectionImpl.java b/simpledb/remote/RemoteConnectionImpl.java
new file mode 100755
index 0000000..6cfc369
--- /dev/null
+++ b/simpledb/remote/RemoteConnectionImpl.java
@@ -0,0 +1,70 @@
+package simpledb.remote;
+
+import simpledb.tx.Transaction;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+/**
+ * The RMI server-side implementation of RemoteConnection.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial") 
+class RemoteConnectionImpl extends UnicastRemoteObject implements RemoteConnection {
+   private Transaction tx;
+   
+   /**
+    * Creates a remote connection
+    * and begins a new transaction for it.
+    * @throws RemoteException
+    */
+   RemoteConnectionImpl() throws RemoteException {
+      tx = new Transaction();
+   }
+   
+   /**
+    * Creates a new RemoteStatement for this connection.
+    * @see simpledb.remote.RemoteConnection#createStatement()
+    */
+   public RemoteStatement createStatement() throws RemoteException {
+      return new RemoteStatementImpl(this);
+   }
+   
+   /**
+    * Closes the connection.
+    * The current transaction is committed.
+    * @see simpledb.remote.RemoteConnection#close()
+    */
+   public void close() throws RemoteException {
+      tx.commit();
+   }
+   
+// The following methods are used by the server-side classes.
+   
+   /**
+    * Returns the transaction currently associated with
+    * this connection.
+    * @return the transaction associated with this connection
+    */
+   Transaction getTransaction() {  
+      return tx;
+   }
+   
+   /**
+    * Commits the current transaction,
+    * and begins a new one.
+    */
+   void commit() {
+      tx.commit();
+      tx = new Transaction();
+   }
+   
+   /**
+    * Rolls back the current transaction,
+    * and begins a new one.
+    */
+   void rollback() {
+      tx.rollback();
+      tx = new Transaction();
+   }
+}
+
diff --git a/simpledb/remote/RemoteDriver.class b/simpledb/remote/RemoteDriver.class
new file mode 100755
index 0000000..e34bb35
Binary files /dev/null and b/simpledb/remote/RemoteDriver.class differ
diff --git a/simpledb/remote/RemoteDriver.java b/simpledb/remote/RemoteDriver.java
new file mode 100755
index 0000000..eaaa30d
--- /dev/null
+++ b/simpledb/remote/RemoteDriver.java
@@ -0,0 +1,15 @@
+package simpledb.remote;
+
+import java.rmi.*;
+
+/**
+ * The RMI remote interface corresponding to Driver.
+ * The method is similar to that of Driver, 
+ * except that it takes no arguments and
+ * throws RemoteExceptions instead of SQLExceptions.
+ * @author Edward Sciore
+ */
+public interface RemoteDriver extends Remote {
+   public RemoteConnection connect() throws RemoteException;
+}
+
diff --git a/simpledb/remote/RemoteDriverImpl.class b/simpledb/remote/RemoteDriverImpl.class
new file mode 100755
index 0000000..f781833
Binary files /dev/null and b/simpledb/remote/RemoteDriverImpl.class differ
diff --git a/simpledb/remote/RemoteDriverImpl.java b/simpledb/remote/RemoteDriverImpl.java
new file mode 100755
index 0000000..b709cfa
--- /dev/null
+++ b/simpledb/remote/RemoteDriverImpl.java
@@ -0,0 +1,24 @@
+package simpledb.remote;
+
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+/**
+ * The RMI server-side implementation of RemoteDriver.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+public class RemoteDriverImpl extends UnicastRemoteObject implements RemoteDriver {
+   public RemoteDriverImpl() throws RemoteException {
+   }
+   
+   /**
+    * Creates a new RemoteConnectionImpl object and 
+    * returns it.
+    * @see simpledb.remote.RemoteDriver#connect()
+    */
+   public RemoteConnection connect() throws RemoteException {
+      return new RemoteConnectionImpl();
+   }
+}
+
diff --git a/simpledb/remote/RemoteMetaData.class b/simpledb/remote/RemoteMetaData.class
new file mode 100755
index 0000000..add08a4
Binary files /dev/null and b/simpledb/remote/RemoteMetaData.class differ
diff --git a/simpledb/remote/RemoteMetaData.java b/simpledb/remote/RemoteMetaData.java
new file mode 100755
index 0000000..418edc6
--- /dev/null
+++ b/simpledb/remote/RemoteMetaData.java
@@ -0,0 +1,17 @@
+package simpledb.remote;
+
+import java.rmi.*;
+
+/**
+ * The RMI remote interface corresponding to ResultSetMetaData.
+ * The methods are identical to those of ResultSetMetaData, 
+ * except that they throw RemoteExceptions instead of SQLExceptions.
+ * @author Edward Sciore
+ */
+public interface RemoteMetaData extends Remote {
+   public int    getColumnCount()              throws RemoteException;
+   public String getColumnName(int column)     throws RemoteException;
+   public int    getColumnType(int column)     throws RemoteException;
+   public int getColumnDisplaySize(int column) throws RemoteException;
+}
+
diff --git a/simpledb/remote/RemoteMetaDataImpl.class b/simpledb/remote/RemoteMetaDataImpl.class
new file mode 100755
index 0000000..cf189a6
Binary files /dev/null and b/simpledb/remote/RemoteMetaDataImpl.class differ
diff --git a/simpledb/remote/RemoteMetaDataImpl.java b/simpledb/remote/RemoteMetaDataImpl.java
new file mode 100755
index 0000000..b2ec583
--- /dev/null
+++ b/simpledb/remote/RemoteMetaDataImpl.java
@@ -0,0 +1,81 @@
+package simpledb.remote;
+
+import simpledb.record.Schema;
+import static java.sql.Types.INTEGER;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+import java.util.*;
+
+/**
+ * The RMI server-side implementation of RemoteMetaData.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+public class RemoteMetaDataImpl extends UnicastRemoteObject implements RemoteMetaData {
+   private Schema sch;
+   private List<String> fields = new ArrayList<String>();
+   
+   /**
+    * Creates a metadata object that wraps the specified schema.
+    * The method also creates a list to hold the schema's
+    * collection of field names,
+    * so that the fields can be accessed by position.
+    * @param sch the schema
+    * @throws RemoteException
+    */
+   public RemoteMetaDataImpl(Schema sch) throws RemoteException {
+      this.sch = sch;
+      fields.addAll(sch.fields());
+   }
+   
+   /**
+    * Returns the size of the field list.
+    * @see simpledb.remote.RemoteMetaData#getColumnCount()
+    */
+   public int getColumnCount() throws RemoteException {
+      return fields.size();
+   }
+   
+   /**
+    * Returns the field name for the specified column number.
+    * In JDBC, column numbers start with 1, so the field
+    * is taken from position (column-1) in the list.
+    * @see simpledb.remote.RemoteMetaData#getColumnName(int)
+    */
+   public String getColumnName(int column) throws RemoteException {
+      return fields.get(column-1);
+   }
+   
+   /**
+    * Returns the type of the specified column.
+    * The method first finds the name of the field in that column,
+    * and then looks up its type in the schema.
+    * @see simpledb.remote.RemoteMetaData#getColumnType(int)
+    */
+   public int getColumnType(int column) throws RemoteException {
+      String fldname = getColumnName(column);
+      return sch.type(fldname);
+   }
+   
+   /**
+    * Returns the number of characters required to display the
+    * specified column.
+    * For a string-type field, the method simply looks up the 
+    * field's length in the schema and returns that.
+    * For an int-type field, the method needs to decide how
+    * large integers can be.
+    * Here, the method arbitrarily chooses 6 characters,
+    * which means that integers over 999,999 will  
+    * probably get displayed improperly.
+    * @see simpledb.remote.RemoteMetaData#getColumnDisplaySize(int)
+    */
+   public int getColumnDisplaySize(int column) throws RemoteException {
+      String fldname = getColumnName(column);
+      int fldtype = sch.type(fldname);
+      int fldlength = sch.length(fldname);
+      if (fldtype == INTEGER)
+         return 6;  // accommodate 6-digit integers
+      else
+         return fldlength;
+   }
+}
diff --git a/simpledb/remote/RemoteResultSet.class b/simpledb/remote/RemoteResultSet.class
new file mode 100755
index 0000000..b93bc2c
Binary files /dev/null and b/simpledb/remote/RemoteResultSet.class differ
diff --git a/simpledb/remote/RemoteResultSet.java b/simpledb/remote/RemoteResultSet.java
new file mode 100755
index 0000000..ac847a2
--- /dev/null
+++ b/simpledb/remote/RemoteResultSet.java
@@ -0,0 +1,18 @@
+package simpledb.remote;
+
+import java.rmi.*;
+
+/**
+ * The RMI remote interface corresponding to ResultSet.
+ * The methods are identical to those of ResultSet, 
+ * except that they throw RemoteExceptions instead of SQLExceptions.
+ * @author Edward Sciore
+ */
+public interface RemoteResultSet extends Remote {
+   public boolean next()                   throws RemoteException;
+   public int getInt(String fldname)       throws RemoteException;
+   public String getString(String fldname) throws RemoteException;
+   public RemoteMetaData getMetaData()     throws RemoteException;
+   public void close()                     throws RemoteException;
+}
+
diff --git a/simpledb/remote/RemoteResultSetImpl.class b/simpledb/remote/RemoteResultSetImpl.class
new file mode 100755
index 0000000..6ecfbba
Binary files /dev/null and b/simpledb/remote/RemoteResultSetImpl.class differ
diff --git a/simpledb/remote/RemoteResultSetImpl.java b/simpledb/remote/RemoteResultSetImpl.java
new file mode 100755
index 0000000..50d2366
--- /dev/null
+++ b/simpledb/remote/RemoteResultSetImpl.java
@@ -0,0 +1,96 @@
+package simpledb.remote;
+
+import simpledb.record.Schema;
+import simpledb.query.*;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+/**
+ * The RMI server-side implementation of RemoteResultSet.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+class RemoteResultSetImpl extends UnicastRemoteObject implements RemoteResultSet {
+   private Scan s;
+   private Schema sch;
+   private RemoteConnectionImpl rconn;
+
+   /**
+    * Creates a RemoteResultSet object.
+    * The specified plan is opened, and the scan is saved.
+    * @param plan the query plan
+    * @param rconn TODO
+    * @throws RemoteException
+    */
+   public RemoteResultSetImpl(Plan plan, RemoteConnectionImpl rconn) throws RemoteException {
+      s = plan.open();
+      sch = plan.schema();
+      this.rconn = rconn;
+   }
+
+   /**
+    * Moves to the next record in the result set,
+    * by moving to the next record in the saved scan.
+    * @see simpledb.remote.RemoteResultSet#next()
+    */
+   public boolean next() throws RemoteException {
+		try {
+	      return s.next();
+      }
+      catch(RuntimeException e) {
+         rconn.rollback();
+         throw e;
+      }
+   }
+
+   /**
+    * Returns the integer value of the specified field,
+    * by returning the corresponding value on the saved scan.
+    * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
+    */
+   public int getInt(String fldname) throws RemoteException {
+		try {
+	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
+	      return s.getInt(fldname);
+      }
+      catch(RuntimeException e) {
+         rconn.rollback();
+         throw e;
+      }
+   }
+
+   /**
+    * Returns the integer value of the specified field,
+    * by returning the corresponding value on the saved scan.
+    * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
+    */
+   public String getString(String fldname) throws RemoteException {
+		try {
+	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
+	      return s.getString(fldname);
+      }
+      catch(RuntimeException e) {
+         rconn.rollback();
+         throw e;
+      }
+   }
+
+   /**
+    * Returns the result set's metadata,
+    * by passing its schema into the RemoteMetaData constructor.
+    * @see simpledb.remote.RemoteResultSet#getMetaData()
+    */
+   public RemoteMetaData getMetaData() throws RemoteException {
+      return new RemoteMetaDataImpl(sch);
+   }
+
+   /**
+    * Closes the result set by closing its scan.
+    * @see simpledb.remote.RemoteResultSet#close()
+    */
+   public void close() throws RemoteException {
+      s.close();
+      rconn.commit();
+   }
+}
+
diff --git a/simpledb/remote/RemoteStatement.class b/simpledb/remote/RemoteStatement.class
new file mode 100755
index 0000000..7a076c0
Binary files /dev/null and b/simpledb/remote/RemoteStatement.class differ
diff --git a/simpledb/remote/RemoteStatement.java b/simpledb/remote/RemoteStatement.java
new file mode 100755
index 0000000..e8a54ca
--- /dev/null
+++ b/simpledb/remote/RemoteStatement.java
@@ -0,0 +1,15 @@
+package simpledb.remote;
+
+import java.rmi.*;
+
+/**
+ * The RMI remote interface corresponding to Statement.
+ * The methods are identical to those of Statement, 
+ * except that they throw RemoteExceptions instead of SQLExceptions.
+ * @author Edward Sciore
+ */
+public interface RemoteStatement extends Remote {
+   public RemoteResultSet executeQuery(String qry) throws RemoteException;
+   public int            executeUpdate(String cmd) throws RemoteException;
+}
+
diff --git a/simpledb/remote/RemoteStatementImpl.class b/simpledb/remote/RemoteStatementImpl.class
new file mode 100755
index 0000000..6916d72
Binary files /dev/null and b/simpledb/remote/RemoteStatementImpl.class differ
diff --git a/simpledb/remote/RemoteStatementImpl.java b/simpledb/remote/RemoteStatementImpl.java
new file mode 100755
index 0000000..bc67a20
--- /dev/null
+++ b/simpledb/remote/RemoteStatementImpl.java
@@ -0,0 +1,58 @@
+package simpledb.remote;
+
+import simpledb.tx.Transaction;
+import simpledb.query.Plan;
+import simpledb.server.SimpleDB;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+/**
+ * The RMI server-side implementation of RemoteStatement.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+class RemoteStatementImpl extends UnicastRemoteObject implements RemoteStatement {
+   private RemoteConnectionImpl rconn;
+   
+   public RemoteStatementImpl(RemoteConnectionImpl rconn) throws RemoteException {
+      this.rconn = rconn;
+   }
+   
+   /**
+    * Executes the specified SQL query string.
+    * The method calls the query planner to create a plan
+    * for the query. It then sends the plan to the
+    * RemoteResultSetImpl constructor for processing.
+    * @see simpledb.remote.RemoteStatement#executeQuery(java.lang.String)
+    */
+   public RemoteResultSet executeQuery(String qry) throws RemoteException {
+      try {
+         Transaction tx = rconn.getTransaction();
+         Plan pln = SimpleDB.planner().createQueryPlan(qry, tx);
+         return new RemoteResultSetImpl(pln, rconn);
+      }
+      catch(RuntimeException e) {
+         rconn.rollback();
+         throw e;
+      }
+   }
+   
+   /**
+    * Executes the specified SQL update command.
+    * The method sends the command to the update planner,
+    * which executes it.
+    * @see simpledb.remote.RemoteStatement#executeUpdate(java.lang.String)
+    */
+   public int executeUpdate(String cmd) throws RemoteException {
+      try {
+         Transaction tx = rconn.getTransaction();
+         int result = SimpleDB.planner().executeUpdate(cmd, tx);
+         rconn.commit();
+         return result;
+      }
+      catch(RuntimeException e) {
+         rconn.rollback();
+         throw e;
+      }
+   }
+}
diff --git a/simpledb/remote/ResultSetAdapter.class b/simpledb/remote/ResultSetAdapter.class
new file mode 100755
index 0000000..a31ef74
Binary files /dev/null and b/simpledb/remote/ResultSetAdapter.class differ
diff --git a/simpledb/remote/ResultSetAdapter.java b/simpledb/remote/ResultSetAdapter.java
new file mode 100755
index 0000000..eed4994
--- /dev/null
+++ b/simpledb/remote/ResultSetAdapter.java
@@ -0,0 +1,773 @@
+package simpledb.remote;
+
+import java.sql.*;
+import java.util.Map;
+import java.util.Calendar;
+import java.io.*;
+import java.math.BigDecimal;
+import java.net.URL;
+
+/**
+ * This class implements all of the methods of the ResultSet interface,
+ * by throwing an exception for each one.
+ * Subclasses (such as SimpleResultSet) can override those methods that 
+ * it want to implement.
+ * @author Edward Sciore
+ */
+public abstract class ResultSetAdapter implements ResultSet {
+   public boolean absolute(int row) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void afterLast() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void beforeFirst() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void cancelRowUpdates() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void clearWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void close() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void deleteRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int findColumn(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean first() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Array getArray(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Array getArray(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getAsciiStream(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getAsciiStream(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getBinaryStream(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getBinaryStream(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Blob getBlob(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Blob getBlob(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean getBoolean(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean getBoolean(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public byte getByte(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public byte getByte(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public byte[] getBytes(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public byte[] getBytes(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Reader getCharacterStream(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Reader getCharacterStream(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Clob getClob(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Clob getClob(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getConcurrency() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getCursorName() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Date getDate(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Date getDate(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Date getDate(int columnIndex, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Date getDate(String columnLabel, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public double getDouble(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public double getDouble(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getFetchDirection() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getFetchSize() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public float getFloat(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public float getFloat(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getHoldability() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getInt(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getInt(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public long getLong(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public long getLong(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public ResultSetMetaData getMetaData() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Reader getNCharacterStream(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Reader getNCharacterStream(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public NClob getNClob(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public NClob getNClob(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getNString(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getNString(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Object getObject(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Object getObject(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Object getObject(int columnIndex, Map<String,Class<?>> map) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Object getObject(String columnLabel, Map<String,Class<?>> map) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Ref getRef(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Ref getRef(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public RowId getRowId(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public RowId getRowId(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public short getShort(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public short getShort(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLXML getSQLXML(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLXML getSQLXML(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Statement getStatement() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getString(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getString(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Time getTime(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Time getTime(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Time getTime(int columnIndex, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Time getTime(String columnLabel, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Timestamp getTimestamp(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Timestamp getTimestamp(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getType() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getUnicodeStream(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public InputStream getUnicodeStream(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public URL getURL(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public URL getURL(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLWarning getWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void insertRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isAfterLast() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isBeforeFirst() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isClosed() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isFirst() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isLast() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean last() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void moveToCurrentRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void moveToInsertRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean next() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean previous() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void refreshRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean relative(int rows) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean rowDeleted() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean rowInserted() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean rowUpdated() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setFetchDirection(int direction) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setFetchSize(int rows) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateArray(int columnIndex, Array x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateArray(String columnLabel, Array x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(int columnIndex, Blob x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(String columnLabel, Blob x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBoolean(int columnIndex, boolean x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBoolean(String columnLabel, boolean x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateByte(int columnIndex, byte x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateByte(String columnLabel, byte x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBytes(int columnIndex, byte[] x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateBytes(String columnLabel, byte[] x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(String columnLabel, Reader x, int length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(int columnIndex, Clob x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(String columnLabel, Clob x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(int columnIndex, Reader reader) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(String columnLabel, Reader reader) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateDate(int columnIndex, Date x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateDate(String columnLabel, Date x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateDouble(int columnIndex, double x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateDouble(String columnLabel, double x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateFloat(int columnIndex, float x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateFloat(String columnLabel, float x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateInt(int columnIndex, int x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateInt(String columnLabel, int x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateLong(int columnIndex, long x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateLong(String columnLabel, long x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(int columnIndex, Reader reader) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(String columnLabel, Reader reader) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNString(int columnIndex, String nstring) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNString(String columnLabel, String nstring) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNull(int columnIndex) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateNull(String columnLabel) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateObject(int columnIndex, Object x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateObject(String columnLabel, Object x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateObject(String columnLabel, Object x, int scale) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateRef(int columnIndex, Ref x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateRef(String columnLabel, Ref x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateRow() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateRowId(int columnIndex, RowId x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateRowId(String columnLabel, RowId x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateShort(int columnIndex, short x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateShort(String columnLabel, short x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateString(int columnIndex, String x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateString(String columnLabel, String x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateTime(int columnIndex, Time x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateTime(String columnLabel, Time x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean wasNull() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isWrapperFor(Class<?> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public <T> T unwrap(Class<T> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+}
\ No newline at end of file
diff --git a/simpledb/remote/ResultSetMetaDataAdapter.class b/simpledb/remote/ResultSetMetaDataAdapter.class
new file mode 100755
index 0000000..7ea7554
Binary files /dev/null and b/simpledb/remote/ResultSetMetaDataAdapter.class differ
diff --git a/simpledb/remote/ResultSetMetaDataAdapter.java b/simpledb/remote/ResultSetMetaDataAdapter.java
new file mode 100755
index 0000000..576e7e2
--- /dev/null
+++ b/simpledb/remote/ResultSetMetaDataAdapter.java
@@ -0,0 +1,104 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * This class implements all of the methods of the ResultSetMetaData interface,
+ * by throwing an exception for each one.
+ * Subclasses (such as SimpleMetaData) can override those methods that 
+ * it want to implement.
+ * @author Edward Sciore
+ */
+public abstract class ResultSetMetaDataAdapter implements ResultSetMetaData {
+   public String getCatalogName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getColumnClassName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getColumnCount() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getColumnDisplaySize(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getColumnLabel(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getColumnName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getColumnType(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getColumnTypeName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getPrecision(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getScale(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getSchemaName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public String getTableName(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isAutoIncrement(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isCaseSensitive(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isCurrency(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isDefinitelyWritable(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int isNullable(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isReadOnly(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isSearchable(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isSigned(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isWritable(int column) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isWrapperFor(Class<?> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public <T> T unwrap(Class<T> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+}
\ No newline at end of file
diff --git a/simpledb/remote/SimpleConnection.class b/simpledb/remote/SimpleConnection.class
new file mode 100755
index 0000000..8d58c54
Binary files /dev/null and b/simpledb/remote/SimpleConnection.class differ
diff --git a/simpledb/remote/SimpleConnection.java b/simpledb/remote/SimpleConnection.java
new file mode 100755
index 0000000..dd971eb
--- /dev/null
+++ b/simpledb/remote/SimpleConnection.java
@@ -0,0 +1,37 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * An adapter class that wraps RemoteConnection.
+ * Its methods do nothing except transform RemoteExceptions
+ * into SQLExceptions.
+ * @author Edward Sciore
+ */
+public class SimpleConnection extends ConnectionAdapter {
+   private RemoteConnection rconn;
+   
+   public SimpleConnection(RemoteConnection c) {
+      rconn = c;
+   }
+   
+   public Statement createStatement() throws SQLException {
+      try {
+         RemoteStatement rstmt = rconn.createStatement();
+         return new SimpleStatement(rstmt);
+      }
+      catch(Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public void close() throws SQLException {
+      try {
+         rconn.close();
+      }
+      catch(Exception e) {
+         throw new SQLException(e);
+      }
+   }
+}
+
diff --git a/simpledb/remote/SimpleDriver.class b/simpledb/remote/SimpleDriver.class
new file mode 100755
index 0000000..6d0c7ad
Binary files /dev/null and b/simpledb/remote/SimpleDriver.class differ
diff --git a/simpledb/remote/SimpleDriver.java b/simpledb/remote/SimpleDriver.java
new file mode 100755
index 0000000..612504f
--- /dev/null
+++ b/simpledb/remote/SimpleDriver.java
@@ -0,0 +1,38 @@
+package simpledb.remote;
+
+import java.sql.*;
+import java.rmi.*;
+import java.util.Properties;
+
+/**
+ * The SimpleDB database driver.
+ * @author Edward Sciore
+ */
+public class SimpleDriver extends DriverAdapter {
+   
+   /**
+    * Connects to the SimpleDB server on the specified host.
+    * The method retrieves the RemoteDriver stub from
+    * the RMI registry on the specified host.
+    * It then calls the connect method on that stub,
+    * which in turn creates a new connection and
+    * returns the RemoteConnection stub for it.
+    * This stub is wrapped in a SimpleConnection object
+    * and is returned. 
+    * <P>
+    * The current implementation of this method ignores the 
+    * properties argument.
+    * @see java.sql.Driver#connect(java.lang.String, Properties)
+    */
+   public Connection connect(String url, Properties prop) throws SQLException {
+      try {
+         String newurl = url.replace("jdbc:simpledb", "rmi") + "/simpledb";
+         RemoteDriver rdvr = (RemoteDriver) Naming.lookup(newurl);
+         RemoteConnection rconn = rdvr.connect();
+         return new SimpleConnection(rconn);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+}
diff --git a/simpledb/remote/SimpleMetaData.class b/simpledb/remote/SimpleMetaData.class
new file mode 100755
index 0000000..41f27b3
Binary files /dev/null and b/simpledb/remote/SimpleMetaData.class differ
diff --git a/simpledb/remote/SimpleMetaData.java b/simpledb/remote/SimpleMetaData.java
new file mode 100755
index 0000000..9865f9b
--- /dev/null
+++ b/simpledb/remote/SimpleMetaData.java
@@ -0,0 +1,54 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * An adapter class that wraps RemoteMetaData.
+ * Its methods do nothing except transform RemoteExceptions
+ * into SQLExceptions.
+ * @author Edward Sciore
+ */
+public class SimpleMetaData extends ResultSetMetaDataAdapter {
+   private RemoteMetaData rmd;
+   
+   public SimpleMetaData(RemoteMetaData md) {
+      rmd = md;
+   }
+   
+   public int getColumnCount() throws SQLException {
+      try {
+         return rmd.getColumnCount();
+      }
+      catch(Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public String getColumnName(int column) throws SQLException {
+      try {
+         return rmd.getColumnName(column);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public int getColumnType(int column) throws SQLException {
+      try {
+         return rmd.getColumnType(column);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public int getColumnDisplaySize(int column) throws SQLException {
+      try {
+         return rmd.getColumnDisplaySize(column);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+}
+
diff --git a/simpledb/remote/SimpleResultSet.class b/simpledb/remote/SimpleResultSet.class
new file mode 100755
index 0000000..0fab540
Binary files /dev/null and b/simpledb/remote/SimpleResultSet.class differ
diff --git a/simpledb/remote/SimpleResultSet.java b/simpledb/remote/SimpleResultSet.java
new file mode 100755
index 0000000..d8f49eb
--- /dev/null
+++ b/simpledb/remote/SimpleResultSet.java
@@ -0,0 +1,64 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * An adapter class that wraps RemoteResultSet.
+ * Its methods do nothing except transform RemoteExceptions
+ * into SQLExceptions.
+ * @author Edward Sciore
+ */
+public class SimpleResultSet extends ResultSetAdapter {
+   private RemoteResultSet rrs;
+   
+   public SimpleResultSet(RemoteResultSet s) {
+      rrs = s;
+   }
+   
+   public boolean next() throws SQLException {
+      try {
+         return rrs.next();
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public int getInt(String fldname) throws SQLException {
+      try {
+         return rrs.getInt(fldname);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public String getString(String fldname) throws SQLException {
+      try {
+         return rrs.getString(fldname);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public ResultSetMetaData getMetaData() throws SQLException {
+      try {
+         RemoteMetaData rmd = rrs.getMetaData();
+         return new SimpleMetaData(rmd);
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public void close() throws SQLException {
+      try {
+         rrs.close();
+      }
+      catch (Exception e) {
+         throw new SQLException(e);
+      }
+   }
+}
+
diff --git a/simpledb/remote/SimpleStatement.class b/simpledb/remote/SimpleStatement.class
new file mode 100755
index 0000000..8960ae9
Binary files /dev/null and b/simpledb/remote/SimpleStatement.class differ
diff --git a/simpledb/remote/SimpleStatement.java b/simpledb/remote/SimpleStatement.java
new file mode 100755
index 0000000..17e297f
--- /dev/null
+++ b/simpledb/remote/SimpleStatement.java
@@ -0,0 +1,37 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * An adapter class that wraps RemoteStatement.
+ * Its methods do nothing except transform RemoteExceptions
+ * into SQLExceptions.
+ * @author Edward Sciore
+ */
+public class SimpleStatement extends StatementAdapter {
+   private RemoteStatement rstmt;
+   
+   public SimpleStatement(RemoteStatement s) {
+      rstmt = s;
+   }
+   
+   public ResultSet executeQuery(String qry) throws SQLException {
+      try {
+         RemoteResultSet rrs = rstmt.executeQuery(qry);
+         return new SimpleResultSet(rrs);
+      }
+      catch(Exception e) {
+         throw new SQLException(e);
+      }
+   }
+   
+   public int executeUpdate(String cmd) throws SQLException {
+      try {
+         return rstmt.executeUpdate(cmd);
+      }
+      catch(Exception e) {
+         throw new SQLException(e);
+      }
+   }
+}
+
diff --git a/simpledb/remote/StatementAdapter.class b/simpledb/remote/StatementAdapter.class
new file mode 100755
index 0000000..4b1dc7d
Binary files /dev/null and b/simpledb/remote/StatementAdapter.class differ
diff --git a/simpledb/remote/StatementAdapter.java b/simpledb/remote/StatementAdapter.java
new file mode 100755
index 0000000..7d7eeb8
--- /dev/null
+++ b/simpledb/remote/StatementAdapter.java
@@ -0,0 +1,177 @@
+package simpledb.remote;
+
+import java.sql.*;
+
+/**
+ * This class implements all of the methods of the Statement interface,
+ * by throwing an exception for each one.
+ * Subclasses (such as SimpleStatement) can override those methods that 
+ * it want to implement.
+ * @author Edward Sciore
+ */
+public abstract class StatementAdapter implements Statement {
+   public void addBatch(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void cancel() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void clearBatch() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void clearWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void close() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean execute(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean execute(String sql, int[] columnIndexes) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean execute(String sql, String[] columnNames) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int[] executeBatch() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public ResultSet executeQuery(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int executeUpdate(String sql) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int executeUpdate(String sql, String[] columnNames) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public Connection getConnection() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getFetchDirection() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getFetchSize() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public ResultSet getGeneratedKeys() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getMaxFieldSize() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getMaxRows() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean getMoreResults() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean getMoreResults(int current) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getQueryTimeout() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public ResultSet getResultSet() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getResultSetConcurrency() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getResultSetHoldability() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getResultSetType() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public int getUpdateCount() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public SQLWarning getWarnings() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isClosed() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public boolean isPoolable() throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setCursorName(String name) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setEscapeProcessing(boolean enable) {
+   }
+   
+   public void setFetchDirection(int direction) {
+   }
+   
+   public void setFetchSize(int rows) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setMaxFieldSize(int max) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setMaxRows(int max) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setPoolable(boolean poolable) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public void setQueryTimeout(int seconds) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   public boolean isWrapperFor(Class<?> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+   
+   public <T> T unwrap(Class<T> iface) throws SQLException {
+      throw new SQLException("operation not implemented");
+   }
+}
\ No newline at end of file
diff --git a/simpledb/server/SimpleDB.class b/simpledb/server/SimpleDB.class
new file mode 100755
index 0000000..9b3908c
Binary files /dev/null and b/simpledb/server/SimpleDB.class differ
diff --git a/simpledb/server/SimpleDB.java b/simpledb/server/SimpleDB.java
new file mode 100755
index 0000000..821029b
--- /dev/null
+++ b/simpledb/server/SimpleDB.java
@@ -0,0 +1,107 @@
+package simpledb.server;
+
+import simpledb.file.FileMgr;
+import simpledb.buffer.*;
+import simpledb.tx.Transaction;
+import simpledb.log.LogMgr;
+import simpledb.metadata.MetadataMgr;
+import simpledb.planner.*;
+import simpledb.opt.HeuristicQueryPlanner;
+import simpledb.index.planner.IndexUpdatePlanner;
+
+/**
+ * The class that provides system-wide static global values.
+ * These values must be initialized by the method
+ * {@link #init(String) init} before use.
+ * The methods {@link #initFileMgr(String) initFileMgr},
+ * {@link #initFileAndLogMgr(String) initFileAndLogMgr},
+ * {@link #initFileLogAndBufferMgr(String) initFileLogAndBufferMgr},
+ * and {@link #initMetadataMgr(boolean, Transaction) initMetadataMgr}
+ * provide limited initialization, and are useful for 
+ * debugging purposes.
+ * 
+ * @author Edward Sciore
+ */
+public class SimpleDB {
+   public static int BUFFER_SIZE = 8;
+   public static String LOG_FILE = "simpledb.log";
+   
+   private static FileMgr     fm;
+   private static BufferMgr   bm;
+   private static LogMgr      logm;
+   private static MetadataMgr mdm;
+   
+   /**
+    * Initializes the system.
+    * This method is called during system startup.
+    * @param dirname the name of the database directory
+    */
+   public static void init(String dirname) {
+      initFileLogAndBufferMgr(dirname);
+      Transaction tx = new Transaction();
+      boolean isnew = fm.isNew();
+      if (isnew)
+         System.out.println("creating new database");
+      else {
+         System.out.println("recovering existing database");
+         tx.recover();
+      }
+      initMetadataMgr(isnew, tx);
+      tx.commit();
+   }
+   
+   // The following initialization methods are useful for 
+   // testing the lower-level components of the system 
+   // without having to initialize everything.
+   
+   /**
+    * Initializes only the file manager.
+    * @param dirname the name of the database directory
+    */
+   public static void initFileMgr(String dirname) {
+      fm = new FileMgr(dirname);
+   }
+   
+   /**
+    * Initializes the file and log managers.
+    * @param dirname the name of the database directory
+    */
+   public static void initFileAndLogMgr(String dirname) {
+      initFileMgr(dirname);
+      logm = new LogMgr(LOG_FILE);
+   }
+   
+   /**
+    * Initializes the file, log, and buffer managers.
+    * @param dirname the name of the database directory
+    */
+   public static void initFileLogAndBufferMgr(String dirname) {
+      initFileAndLogMgr(dirname);
+      bm = new BufferMgr(BUFFER_SIZE);
+   }
+   
+   /**
+    * Initializes metadata manager.
+    * @param isnew an indication of whether a new
+    * database needs to be created.
+    * @param tx the transaction performing the initialization
+    */
+   public static void initMetadataMgr(boolean isnew, Transaction tx) {
+      mdm = new MetadataMgr(isnew, tx);
+   }
+   
+   public static FileMgr     fileMgr()   { return fm; }
+   public static BufferMgr   bufferMgr() { return bm; }
+   public static LogMgr      logMgr()    { return logm; }
+   public static MetadataMgr mdMgr()     { return mdm; }
+   
+   /**
+    * Creates a planner for SQL commands.
+    * To change how the planner works, modify this method.
+    * @return the system's planner for SQL commands
+    */public static Planner planner() {
+      QueryPlanner  qplanner = new BasicQueryPlanner();
+      UpdatePlanner uplanner = new BasicUpdatePlanner();
+      return new Planner(qplanner, uplanner);
+   }
+}
diff --git a/simpledb/server/Startup.class b/simpledb/server/Startup.class
new file mode 100755
index 0000000..ef00934
Binary files /dev/null and b/simpledb/server/Startup.class differ
diff --git a/simpledb/server/Startup.java b/simpledb/server/Startup.java
new file mode 100755
index 0000000..09405ec
--- /dev/null
+++ b/simpledb/server/Startup.java
@@ -0,0 +1,17 @@
+package simpledb.server;
+
+import simpledb.remote.*;
+import java.rmi.*;
+
+public class Startup {
+   public static void main(String args[]) throws Exception {
+      // configure and initialize the database
+      SimpleDB.init(args[0]);
+      
+      // post the server entry in the rmi registry
+      RemoteDriver d = new RemoteDriverImpl();
+      Naming.rebind("simpledb", d);
+      
+      System.out.println("database server ready");
+   }
+}
diff --git a/simpledb/tx/BufferList.class b/simpledb/tx/BufferList.class
new file mode 100755
index 0000000..bbe44dc
Binary files /dev/null and b/simpledb/tx/BufferList.class differ
diff --git a/simpledb/tx/BufferList.java b/simpledb/tx/BufferList.java
new file mode 100755
index 0000000..c192ee1
--- /dev/null
+++ b/simpledb/tx/BufferList.java
@@ -0,0 +1,76 @@
+package simpledb.tx;
+
+import simpledb.server.SimpleDB;
+import simpledb.file.Block;
+import simpledb.buffer.*;
+import java.util.*;
+
+/**
+ * Manages the transaction's currently-pinned buffers. 
+ * @author Edward Sciore
+ */
+class BufferList {
+   private Map<Block,Buffer> buffers = new HashMap<Block,Buffer>();
+   private List<Block> pins = new ArrayList<Block>();
+   private BufferMgr bufferMgr = SimpleDB.bufferMgr();
+   
+   /**
+    * Returns the buffer pinned to the specified block.
+    * The method returns null if the transaction has not
+    * pinned the block.
+    * @param blk a reference to the disk block
+    * @return the buffer pinned to that block
+    */
+   Buffer getBuffer(Block blk) {
+      return buffers.get(blk);
+   }
+   
+   /**
+    * Pins the block and keeps track of the buffer internally.
+    * @param blk a reference to the disk block
+    */
+   void pin(Block blk) {
+      Buffer buff = bufferMgr.pin(blk);
+      buffers.put(blk, buff);
+      pins.add(blk);
+   }
+   
+   /**
+    * Appends a new block to the specified file
+    * and pins it.
+    * @param filename the name of the file
+    * @param fmtr the formatter used to initialize the new page
+    * @return a reference to the newly-created block
+    */
+   Block pinNew(String filename, PageFormatter fmtr) {
+      Buffer buff = bufferMgr.pinNew(filename, fmtr);
+      Block blk = buff.block();
+      buffers.put(blk, buff);
+      pins.add(blk);
+      return blk;
+   }
+   
+   /**
+    * Unpins the specified block.
+    * @param blk a reference to the disk block
+    */
+   void unpin(Block blk) {
+      Buffer buff = buffers.get(blk);
+      bufferMgr.unpin(buff);
+      pins.remove(blk);
+      if (!pins.contains(blk))
+         buffers.remove(blk);
+   }
+   
+   /**
+    * Unpins any buffers still pinned by this transaction.
+    */
+   void unpinAll() {
+      for (Block blk : pins) {
+         Buffer buff = buffers.get(blk);
+         bufferMgr.unpin(buff);
+      }
+      buffers.clear();
+      pins.clear();
+   }
+}
\ No newline at end of file
diff --git a/simpledb/tx/Transaction.class b/simpledb/tx/Transaction.class
new file mode 100755
index 0000000..fc54d9e
Binary files /dev/null and b/simpledb/tx/Transaction.class differ
diff --git a/simpledb/tx/Transaction.java b/simpledb/tx/Transaction.java
new file mode 100755
index 0000000..64b17e5
--- /dev/null
+++ b/simpledb/tx/Transaction.java
@@ -0,0 +1,206 @@
+package simpledb.tx;
+
+import simpledb.server.SimpleDB;
+import simpledb.file.Block;
+import simpledb.buffer.*;
+import simpledb.tx.recovery.RecoveryMgr;
+import simpledb.tx.concurrency.ConcurrencyMgr;
+
+/**
+ * Provides transaction management for clients,
+ * ensuring that all transactions are serializable, recoverable,
+ * and in general satisfy the ACID properties.
+ * @author Edward Sciore
+ */
+public class Transaction {
+   private static int nextTxNum = 0;
+   private static final int END_OF_FILE = -1;
+   private RecoveryMgr    recoveryMgr;
+   private ConcurrencyMgr concurMgr;
+   private int txnum;
+   private BufferList myBuffers = new BufferList();
+   
+   /**
+    * Creates a new transaction and its associated 
+    * recovery and concurrency managers.
+    * This constructor depends on the file, log, and buffer
+    * managers that it gets from the class
+    * {@link simpledb.server.SimpleDB}.
+    * Those objects are created during system initialization.
+    * Thus this constructor cannot be called until either
+    * {@link simpledb.server.SimpleDB#init(String)} or 
+    * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)} or
+    * is called first.
+    */
+   public Transaction() {
+      txnum       = nextTxNumber();
+      recoveryMgr = new RecoveryMgr(txnum);
+      concurMgr   = new ConcurrencyMgr();
+   }
+   
+   /**
+    * Commits the current transaction.
+    * Flushes all modified buffers (and their log records),
+    * writes and flushes a commit record to the log,
+    * releases all locks, and unpins any pinned buffers.
+    */
+   public void commit() {
+      recoveryMgr.commit();
+      concurMgr.release();
+      myBuffers.unpinAll();
+      System.out.println("transaction " + txnum + " committed");
+   }
+   
+   /**
+    * Rolls back the current transaction.
+    * Undoes any modified values,
+    * flushes those buffers,
+    * writes and flushes a rollback record to the log,
+    * releases all locks, and unpins any pinned buffers.
+    */
+   public void rollback() {
+      recoveryMgr.rollback();
+      concurMgr.release();
+      myBuffers.unpinAll();
+      System.out.println("transaction " + txnum + " rolled back");
+   }
+   
+   /**
+    * Flushes all modified buffers.
+    * Then goes through the log, rolling back all
+    * uncommitted transactions.  Finally, 
+    * writes a quiescent checkpoint record to the log.
+    * This method is called only during system startup,
+    * before user transactions begin.
+    */
+   public void recover() {
+      SimpleDB.bufferMgr().flushAll(txnum);
+      recoveryMgr.recover();
+   }
+   
+   /**
+    * Pins the specified block.
+    * The transaction manages the buffer for the client.
+    * @param blk a reference to the disk block
+    */
+   public void pin(Block blk) {
+      myBuffers.pin(blk);
+   }
+   
+   /**
+    * Unpins the specified block.
+    * The transaction looks up the buffer pinned to this block,
+    * and unpins it.
+    * @param blk a reference to the disk block
+    */
+   public void unpin(Block blk) {
+      myBuffers.unpin(blk);
+   }
+   
+   /**
+    * Returns the integer value stored at the
+    * specified offset of the specified block.
+    * The method first obtains an SLock on the block,
+    * then it calls the buffer to retrieve the value.
+    * @param blk a reference to a disk block
+    * @param offset the byte offset within the block
+    * @return the integer stored at that offset
+    */
+   public int getInt(Block blk, int offset) {
+      concurMgr.sLock(blk);
+      Buffer buff = myBuffers.getBuffer(blk);
+      return buff.getInt(offset);
+   }
+   
+   /**
+    * Returns the string value stored at the
+    * specified offset of the specified block.
+    * The method first obtains an SLock on the block,
+    * then it calls the buffer to retrieve the value.
+    * @param blk a reference to a disk block
+    * @param offset the byte offset within the block
+    * @return the string stored at that offset
+    */
+   public String getString(Block blk, int offset) {
+      concurMgr.sLock(blk);
+      Buffer buff = myBuffers.getBuffer(blk);
+      return buff.getString(offset);
+   }
+   
+   /**
+    * Stores an integer at the specified offset 
+    * of the specified block.
+    * The method first obtains an XLock on the block.
+    * It then reads the current value at that offset,
+    * puts it into an update log record, and 
+    * writes that record to the log.
+    * Finally, it calls the buffer to store the value,
+    * passing in the LSN of the log record and the transaction's id. 
+    * @param blk a reference to the disk block
+    * @param offset a byte offset within that block
+    * @param val the value to be stored
+    */
+   public void setInt(Block blk, int offset, int val) {
+      concurMgr.xLock(blk);
+      Buffer buff = myBuffers.getBuffer(blk);
+      int lsn = recoveryMgr.setInt(buff, offset, val);
+      buff.setInt(offset, val, txnum, lsn);
+   }
+   
+   /**
+    * Stores a string at the specified offset 
+    * of the specified block.
+    * The method first obtains an XLock on the block.
+    * It then reads the current value at that offset,
+    * puts it into an update log record, and 
+    * writes that record to the log.
+    * Finally, it calls the buffer to store the value,
+    * passing in the LSN of the log record and the transaction's id. 
+    * @param blk a reference to the disk block
+    * @param offset a byte offset within that block
+    * @param val the value to be stored
+    */
+   public void setString(Block blk, int offset, String val) {
+      concurMgr.xLock(blk);
+      Buffer buff = myBuffers.getBuffer(blk);
+      int lsn = recoveryMgr.setString(buff, offset, val);
+      buff.setString(offset, val, txnum, lsn);
+   }
+   
+   /**
+    * Returns the number of blocks in the specified file.
+    * This method first obtains an SLock on the 
+    * "end of the file", before asking the file manager
+    * to return the file size.
+    * @param filename the name of the file
+    * @return the number of blocks in the file
+    */
+   public int size(String filename) {
+      Block dummyblk = new Block(filename, END_OF_FILE);
+      concurMgr.sLock(dummyblk);
+      return SimpleDB.fileMgr().size(filename);
+   }
+   
+   /**
+    * Appends a new block to the end of the specified file
+    * and returns a reference to it.
+    * This method first obtains an XLock on the
+    * "end of the file", before performing the append.
+    * @param filename the name of the file
+    * @param fmtr the formatter used to initialize the new page
+    * @return a reference to the newly-created disk block
+    */
+   public Block append(String filename, PageFormatter fmtr) {
+      Block dummyblk = new Block(filename, END_OF_FILE);
+      concurMgr.xLock(dummyblk);
+      Block blk = myBuffers.pinNew(filename, fmtr);
+      unpin(blk);
+      return blk;
+   }
+   
+   private static synchronized int nextTxNumber() {
+      nextTxNum++;
+      System.out.println("new transaction: " + nextTxNum);
+      return nextTxNum;
+   }
+}
diff --git a/simpledb/tx/concurrency/ConcurrencyMgr.class b/simpledb/tx/concurrency/ConcurrencyMgr.class
new file mode 100755
index 0000000..42830b7
Binary files /dev/null and b/simpledb/tx/concurrency/ConcurrencyMgr.class differ
diff --git a/simpledb/tx/concurrency/ConcurrencyMgr.java b/simpledb/tx/concurrency/ConcurrencyMgr.java
new file mode 100755
index 0000000..b49fab7
--- /dev/null
+++ b/simpledb/tx/concurrency/ConcurrencyMgr.java
@@ -0,0 +1,65 @@
+package simpledb.tx.concurrency;
+
+import simpledb.file.Block;
+import java.util.*;
+
+/**
+ * The concurrency manager for the transaction.
+ * Each transaction has its own concurrency manager. 
+ * The concurrency manager keeps track of which locks the 
+ * transaction currently has, and interacts with the
+ * global lock table as needed. 
+ * @author Edward Sciore
+ */
+public class ConcurrencyMgr {
+   
+   /**
+    * The global lock table.  This variable is static because all transactions
+    * share the same table.
+    */
+   private static LockTable locktbl = new LockTable();
+   private Map<Block,String> locks  = new HashMap<Block,String>();
+   
+   /**
+    * Obtains an SLock on the block, if necessary.
+    * The method will ask the lock table for an SLock
+    * if the transaction currently has no locks on that block.
+    * @param blk a reference to the disk block
+    */
+   public void sLock(Block blk) {
+      if (locks.get(blk) == null) {
+         locktbl.sLock(blk);
+         locks.put(blk, "S");
+      }
+   }
+   
+   /**
+    * Obtains an XLock on the block, if necessary.
+    * If the transaction does not have an XLock on that block,
+    * then the method first gets an SLock on that block
+    * (if necessary), and then upgrades it to an XLock.
+    * @param blk a refrence to the disk block
+    */
+   public void xLock(Block blk) {
+      if (!hasXLock(blk)) {
+         sLock(blk);
+         locktbl.xLock(blk);
+         locks.put(blk, "X");
+      }
+   }
+   
+   /**
+    * Releases all locks by asking the lock table to
+    * unlock each one.
+    */
+   public void release() {
+      for (Block blk : locks.keySet())
+         locktbl.unlock(blk);
+      locks.clear();
+   }
+   
+   private boolean hasXLock(Block blk) {
+      String locktype = locks.get(blk);
+      return locktype != null && locktype.equals("X");
+   }
+}
diff --git a/simpledb/tx/concurrency/LockAbortException.class b/simpledb/tx/concurrency/LockAbortException.class
new file mode 100755
index 0000000..c5e08a1
Binary files /dev/null and b/simpledb/tx/concurrency/LockAbortException.class differ
diff --git a/simpledb/tx/concurrency/LockAbortException.java b/simpledb/tx/concurrency/LockAbortException.java
new file mode 100755
index 0000000..8b54c7e
--- /dev/null
+++ b/simpledb/tx/concurrency/LockAbortException.java
@@ -0,0 +1,12 @@
+package simpledb.tx.concurrency;
+
+/**
+ * A runtime exception indicating that the transaction
+ * needs to abort because a lock could not be obtained.
+ * @author Edward Sciore
+ */
+@SuppressWarnings("serial")
+public class LockAbortException extends RuntimeException {
+   public LockAbortException() {
+   }
+}
diff --git a/simpledb/tx/concurrency/LockTable.class b/simpledb/tx/concurrency/LockTable.class
new file mode 100755
index 0000000..c020e4a
Binary files /dev/null and b/simpledb/tx/concurrency/LockTable.class differ
diff --git a/simpledb/tx/concurrency/LockTable.java b/simpledb/tx/concurrency/LockTable.java
new file mode 100755
index 0000000..84ecad2
--- /dev/null
+++ b/simpledb/tx/concurrency/LockTable.java
@@ -0,0 +1,103 @@
+package simpledb.tx.concurrency;
+
+import simpledb.file.Block;
+import java.util.*;
+
+/**
+ * The lock table, which provides methods to lock and unlock blocks.
+ * If a transaction requests a lock that causes a conflict with an
+ * existing lock, then that transaction is placed on a wait list.
+ * There is only one wait list for all blocks.
+ * When the last lock on a block is unlocked, then all transactions
+ * are removed from the wait list and rescheduled.
+ * If one of those transactions discovers that the lock it is waiting for
+ * is still locked, it will place itself back on the wait list.
+ * @author Edward Sciore
+ */
+class LockTable {
+   private static final long MAX_TIME = 10000; // 10 seconds
+   
+   private Map<Block,Integer> locks = new HashMap<Block,Integer>();
+   
+   /**
+    * Grants an SLock on the specified block.
+    * If an XLock exists when the method is called,
+    * then the calling thread will be placed on a wait list
+    * until the lock is released.
+    * If the thread remains on the wait list for a certain 
+    * amount of time (currently 10 seconds),
+    * then an exception is thrown.
+    * @param blk a reference to the disk block
+    */
+   public synchronized void sLock(Block blk) {
+      try {
+         long timestamp = System.currentTimeMillis();
+         while (hasXlock(blk) && !waitingTooLong(timestamp))
+            wait(MAX_TIME);
+         if (hasXlock(blk))
+            throw new LockAbortException();
+         int val = getLockVal(blk);  // will not be negative
+         locks.put(blk, val+1);
+      }
+      catch(InterruptedException e) {
+         throw new LockAbortException();
+      }
+   }
+   
+   /**
+    * Grants an XLock on the specified block.
+    * If a lock of any type exists when the method is called,
+    * then the calling thread will be placed on a wait list
+    * until the locks are released.
+    * If the thread remains on the wait list for a certain 
+    * amount of time (currently 10 seconds),
+    * then an exception is thrown.
+    * @param blk a reference to the disk block
+    */
+   synchronized void xLock(Block blk) {
+      try {
+         long timestamp = System.currentTimeMillis();
+         while (hasOtherSLocks(blk) && !waitingTooLong(timestamp))
+            wait(MAX_TIME);
+         if (hasOtherSLocks(blk))
+            throw new LockAbortException();
+         locks.put(blk, -1);
+      }
+      catch(InterruptedException e) {
+         throw new LockAbortException();
+      }
+   }
+   
+   /**
+    * Releases a lock on the specified block.
+    * If this lock is the last lock on that block,
+    * then the waiting transactions are notified.
+    * @param blk a reference to the disk block
+    */
+   synchronized void unlock(Block blk) {
+      int val = getLockVal(blk);
+      if (val > 1)
+         locks.put(blk, val-1);
+      else {
+         locks.remove(blk);
+         notifyAll();
+      }
+   }
+   
+   private boolean hasXlock(Block blk) {
+      return getLockVal(blk) < 0;
+   }
+   
+   private boolean hasOtherSLocks(Block blk) {
+      return getLockVal(blk) > 1;
+   }
+   
+   private boolean waitingTooLong(long starttime) {
+      return System.currentTimeMillis() - starttime > MAX_TIME;
+   }
+   
+   private int getLockVal(Block blk) {
+      Integer ival = locks.get(blk);
+      return (ival == null) ? 0 : ival.intValue();
+   }
+}
diff --git a/simpledb/tx/recovery/CheckpointRecord.class b/simpledb/tx/recovery/CheckpointRecord.class
new file mode 100755
index 0000000..931646c
Binary files /dev/null and b/simpledb/tx/recovery/CheckpointRecord.class differ
diff --git a/simpledb/tx/recovery/CheckpointRecord.java b/simpledb/tx/recovery/CheckpointRecord.java
new file mode 100755
index 0000000..632bacb
--- /dev/null
+++ b/simpledb/tx/recovery/CheckpointRecord.java
@@ -0,0 +1,55 @@
+package simpledb.tx.recovery;
+
+import simpledb.log.BasicLogRecord;
+
+/**
+ * The CHECKPOINT log record.
+ * @author Edward Sciore
+ */
+class CheckpointRecord implements LogRecord {
+   
+   /**
+    * Creates a quiescent checkpoint record.
+    */
+   public CheckpointRecord() {}
+   
+   /**
+    * Creates a log record by reading no other values 
+    * from the basic log record.
+    * @param rec the basic log record
+    */
+   public CheckpointRecord(BasicLogRecord rec) {}
+   
+   /** 
+    * Writes a checkpoint record to the log.
+    * This log record contains the CHECKPOINT operator,
+    * and nothing else.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {CHECKPOINT};
+      return logMgr.append(rec);
+   }
+   
+   public int op() {
+      return CHECKPOINT;
+   }
+   
+   /**
+    * Checkpoint records have no associated transaction,
+    * and so the method returns a "dummy", negative txid.
+    */
+   public int txNumber() {
+      return -1; // dummy value
+   }
+   
+   /**
+    * Does nothing, because a checkpoint record
+    * contains no undo information.
+    */
+   public void undo(int txnum) {}
+   
+   public String toString() {
+      return "<CHECKPOINT>";
+   }
+}
diff --git a/simpledb/tx/recovery/CommitRecord.class b/simpledb/tx/recovery/CommitRecord.class
new file mode 100755
index 0000000..33ea1fd
Binary files /dev/null and b/simpledb/tx/recovery/CommitRecord.class differ
diff --git a/simpledb/tx/recovery/CommitRecord.java b/simpledb/tx/recovery/CommitRecord.java
new file mode 100755
index 0000000..d62f993
--- /dev/null
+++ b/simpledb/tx/recovery/CommitRecord.java
@@ -0,0 +1,56 @@
+package simpledb.tx.recovery;
+
+import simpledb.log.BasicLogRecord;
+
+/**
+ * The COMMIT log record
+ * @author Edward Sciore
+ */
+class CommitRecord implements LogRecord {
+   private int txnum;
+   
+   /**
+    * Creates a new commit log record for the specified transaction.
+    * @param txnum the ID of the specified transaction
+    */
+   public CommitRecord(int txnum) {
+      this.txnum = txnum;
+   }
+   
+   /**
+    * Creates a log record by reading one other value from the log.
+    * @param rec the basic log record
+    */
+   public CommitRecord(BasicLogRecord rec) {
+      txnum = rec.nextInt();
+   }
+   
+   /** 
+    * Writes a commit record to the log.
+    * This log record contains the COMMIT operator,
+    * followed by the transaction id.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {COMMIT, txnum};
+      return logMgr.append(rec);
+   }
+   
+   public int op() {
+      return COMMIT;
+   }
+   
+   public int txNumber() {
+      return txnum;
+   }
+   
+   /**
+    * Does nothing, because a commit record
+    * contains no undo information.
+    */
+   public void undo(int txnum) {}
+   
+   public String toString() {
+      return "<COMMIT " + txnum + ">";
+   }
+}
diff --git a/simpledb/tx/recovery/LogRecord.class b/simpledb/tx/recovery/LogRecord.class
new file mode 100755
index 0000000..90cbdc5
Binary files /dev/null and b/simpledb/tx/recovery/LogRecord.class differ
diff --git a/simpledb/tx/recovery/LogRecord.java b/simpledb/tx/recovery/LogRecord.java
new file mode 100755
index 0000000..8987b1f
--- /dev/null
+++ b/simpledb/tx/recovery/LogRecord.java
@@ -0,0 +1,46 @@
+package simpledb.tx.recovery;
+
+import simpledb.log.LogMgr;
+import simpledb.server.SimpleDB;
+
+/**
+ * The interface implemented by each type of log record.
+ * @author Edward Sciore
+ */
+public interface LogRecord {
+   /**
+    * The six different types of log record
+    */
+   static final int CHECKPOINT = 0, START = 1,
+      COMMIT = 2, ROLLBACK  = 3,
+      SETINT = 4, SETSTRING = 5;
+   
+   static final LogMgr logMgr = SimpleDB.logMgr();
+   
+   /**
+    * Writes the record to the log and returns its LSN.
+    * @return the LSN of the record in the log
+    */
+   int writeToLog();
+   
+   /**
+    * Returns the log record's type. 
+    * @return the log record's type
+    */
+   int op();
+   
+   /**
+    * Returns the transaction id stored with
+    * the log record.
+    * @return the log record's transaction id
+    */
+   int txNumber();
+   
+   /**
+    * Undoes the operation encoded by this log record.
+    * The only log record types for which this method
+    * does anything interesting are SETINT and SETSTRING.
+    * @param txnum the id of the transaction that is performing the undo.
+    */
+   void undo(int txnum);
+}
\ No newline at end of file
diff --git a/simpledb/tx/recovery/LogRecordIterator.class b/simpledb/tx/recovery/LogRecordIterator.class
new file mode 100755
index 0000000..bf9e847
Binary files /dev/null and b/simpledb/tx/recovery/LogRecordIterator.class differ
diff --git a/simpledb/tx/recovery/LogRecordIterator.java b/simpledb/tx/recovery/LogRecordIterator.java
new file mode 100755
index 0000000..a9a3051
--- /dev/null
+++ b/simpledb/tx/recovery/LogRecordIterator.java
@@ -0,0 +1,56 @@
+package simpledb.tx.recovery;
+
+import static simpledb.tx.recovery.LogRecord.*;
+import java.util.Iterator;
+import simpledb.log.BasicLogRecord;
+import simpledb.server.SimpleDB;
+
+/**
+ * A class that provides the ability to read records
+ * from the log in reverse order.
+ * Unlike the similar class 
+ * {@link simpledb.log.LogIterator LogIterator},  
+ * this class understands the meaning of the log records.
+ * @author Edward Sciore
+ */
+class LogRecordIterator implements Iterator<LogRecord> {
+   private Iterator<BasicLogRecord> iter = SimpleDB.logMgr().iterator();
+   
+   public boolean hasNext() {
+      return iter.hasNext();
+   }
+   
+   /**
+    * Constructs a log record from the values in the 
+    * current basic log record.
+    * The method first reads an integer, which denotes
+    * the type of the log record.  Based on that type,
+    * the method calls the appropriate LogRecord constructor
+    * to read the remaining values.
+    * @return the next log record, or null if no more records
+    */
+   public LogRecord next() {
+      BasicLogRecord rec = iter.next();
+      int op = rec.nextInt();
+      switch (op) {
+         case CHECKPOINT:
+            return new CheckpointRecord(rec);
+         case START:
+            return new StartRecord(rec);
+         case COMMIT:
+            return new CommitRecord(rec);
+         case ROLLBACK:
+            return new RollbackRecord(rec);
+         case SETINT:
+            return new SetIntRecord(rec);
+         case SETSTRING:
+            return new SetStringRecord(rec);
+         default:
+            return null;
+      }
+   } 
+   
+   public void remove() {
+      throw new UnsupportedOperationException();
+   }
+}
diff --git a/simpledb/tx/recovery/RecoveryMgr.class b/simpledb/tx/recovery/RecoveryMgr.class
new file mode 100755
index 0000000..a4a92f4
Binary files /dev/null and b/simpledb/tx/recovery/RecoveryMgr.class differ
diff --git a/simpledb/tx/recovery/RecoveryMgr.java b/simpledb/tx/recovery/RecoveryMgr.java
new file mode 100755
index 0000000..ce42691
--- /dev/null
+++ b/simpledb/tx/recovery/RecoveryMgr.java
@@ -0,0 +1,137 @@
+package simpledb.tx.recovery;
+
+import static simpledb.tx.recovery.LogRecord.*;
+import simpledb.file.Block;
+import simpledb.buffer.Buffer;
+import simpledb.server.SimpleDB;
+import java.util.*;
+
+/**
+ * The recovery manager.  Each transaction has its own recovery manager.
+ * @author Edward Sciore
+ */
+public class RecoveryMgr {
+   private int txnum;
+
+   /**
+    * Creates a recovery manager for the specified transaction.
+    * @param txnum the ID of the specified transaction
+    */
+   public RecoveryMgr(int txnum) {
+      this.txnum = txnum;
+      new StartRecord(txnum).writeToLog();
+   }
+
+   /**
+    * Writes a commit record to the log, and flushes it to disk.
+    */
+   public void commit() {
+      SimpleDB.bufferMgr().flushAll(txnum);
+      int lsn = new CommitRecord(txnum).writeToLog();
+      SimpleDB.logMgr().flush(lsn);
+   }
+
+   /**
+    * Writes a rollback record to the log, and flushes it to disk.
+    */
+   public void rollback() {
+      doRollback();
+      SimpleDB.bufferMgr().flushAll(txnum);
+      int lsn = new RollbackRecord(txnum).writeToLog();
+      SimpleDB.logMgr().flush(lsn);
+   }
+
+   /**
+    * Recovers uncompleted transactions from the log,
+    * then writes a quiescent checkpoint record to the log and flushes it.
+    */
+   public void recover() {
+      doRecover();
+      SimpleDB.bufferMgr().flushAll(txnum);
+      int lsn = new CheckpointRecord().writeToLog();
+      SimpleDB.logMgr().flush(lsn);
+
+   }
+
+   /**
+    * Writes a setint record to the log, and returns its lsn.
+    * Updates to temporary files are not logged; instead, a
+    * "dummy" negative lsn is returned.
+    * @param buff the buffer containing the page
+    * @param offset the offset of the value in the page
+    * @param newval the value to be written
+    */
+   public int setInt(Buffer buff, int offset, int newval) {
+      int oldval = buff.getInt(offset);
+      Block blk = buff.block();
+      if (isTempBlock(blk))
+         return -1;
+      else
+         return new SetIntRecord(txnum, blk, offset, oldval).writeToLog();
+   }
+
+   /**
+    * Writes a setstring record to the log, and returns its lsn.
+    * Updates to temporary files are not logged; instead, a
+    * "dummy" negative lsn is returned.
+    * @param buff the buffer containing the page
+    * @param offset the offset of the value in the page
+    * @param newval the value to be written
+    */
+   public int setString(Buffer buff, int offset, String newval) {
+      String oldval = buff.getString(offset);
+      Block blk = buff.block();
+      if (isTempBlock(blk))
+         return -1;
+      else
+         return new SetStringRecord(txnum, blk, offset, oldval).writeToLog();
+   }
+
+   /**
+    * Rolls back the transaction.
+    * The method iterates through the log records,
+    * calling undo() for each log record it finds
+    * for the transaction,
+    * until it finds the transaction's START record.
+    */
+   private void doRollback() {
+      Iterator<LogRecord> iter = new LogRecordIterator();
+      while (iter.hasNext()) {
+         LogRecord rec = iter.next();
+         if (rec.txNumber() == txnum) {
+            if (rec.op() == START)
+               return;
+            rec.undo(txnum);
+         }
+      }
+   }
+
+   /**
+    * Does a complete database recovery.
+    * The method iterates through the log records.
+    * Whenever it finds a log record for an unfinished
+    * transaction, it calls undo() on that record.
+    * The method stops when it encounters a CHECKPOINT record
+    * or the end of the log.
+    */
+   private void doRecover() {
+      Collection<Integer> finishedTxs = new ArrayList<Integer>();
+      Iterator<LogRecord> iter = new LogRecordIterator();
+      while (iter.hasNext()) {
+         LogRecord rec = iter.next();
+         if (rec.op() == CHECKPOINT)
+            return;
+         if (rec.op() == COMMIT || rec.op() == ROLLBACK)
+            finishedTxs.add(rec.txNumber());
+         else if (!finishedTxs.contains(rec.txNumber()))
+            rec.undo(txnum);
+      }
+   }
+
+   /**
+    * Determines whether a block comes from a temporary file or not.
+    */
+   private boolean isTempBlock(Block blk) {
+      return blk.fileName().startsWith("temp");
+   }
+}
diff --git a/simpledb/tx/recovery/RollbackRecord.class b/simpledb/tx/recovery/RollbackRecord.class
new file mode 100755
index 0000000..17eb468
Binary files /dev/null and b/simpledb/tx/recovery/RollbackRecord.class differ
diff --git a/simpledb/tx/recovery/RollbackRecord.java b/simpledb/tx/recovery/RollbackRecord.java
new file mode 100755
index 0000000..f47a24d
--- /dev/null
+++ b/simpledb/tx/recovery/RollbackRecord.java
@@ -0,0 +1,56 @@
+package simpledb.tx.recovery;
+
+import simpledb.log.BasicLogRecord;
+
+/**
+ * The ROLLBACK log record.
+ * @author Edward Sciore
+ */
+class RollbackRecord implements LogRecord {
+   private int txnum;
+   
+   /**
+    * Creates a new rollback log record for the specified transaction.
+    * @param txnum the ID of the specified transaction
+    */
+   public RollbackRecord(int txnum) {
+      this.txnum = txnum;
+   }
+   
+   /**
+    * Creates a log record by reading one other value from the log.
+    * @param rec the basic log record
+    */
+   public RollbackRecord(BasicLogRecord rec) {
+      txnum = rec.nextInt();
+   }
+   
+   /** 
+    * Writes a rollback record to the log.
+    * This log record contains the ROLLBACK operator,
+    * followed by the transaction id.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {ROLLBACK, txnum};
+      return logMgr.append(rec);
+   }
+   
+   public int op() {
+      return ROLLBACK;
+   }
+   
+   public int txNumber() {
+      return txnum;
+   }
+   
+   /**
+    * Does nothing, because a rollback record
+    * contains no undo information.
+    */
+   public void undo(int txnum) {}
+   
+   public String toString() {
+      return "<ROLLBACK " + txnum + ">";
+   }
+}
diff --git a/simpledb/tx/recovery/SetIntRecord.class b/simpledb/tx/recovery/SetIntRecord.class
new file mode 100755
index 0000000..d01dc8f
Binary files /dev/null and b/simpledb/tx/recovery/SetIntRecord.class differ
diff --git a/simpledb/tx/recovery/SetIntRecord.java b/simpledb/tx/recovery/SetIntRecord.java
new file mode 100755
index 0000000..3305655
--- /dev/null
+++ b/simpledb/tx/recovery/SetIntRecord.java
@@ -0,0 +1,78 @@
+package simpledb.tx.recovery;
+
+import simpledb.server.SimpleDB;
+import simpledb.buffer.*;
+import simpledb.file.Block;
+import simpledb.log.BasicLogRecord;
+
+class SetIntRecord implements LogRecord {
+   private int txnum, offset, val;
+   private Block blk;
+
+   /**
+    * Creates a new setint log record.
+    * @param txnum the ID of the specified transaction
+    * @param blk the block containing the value
+    * @param offset the offset of the value in the block
+    * @param val the new value
+    */
+   public SetIntRecord(int txnum, Block blk, int offset, int val) {
+      this.txnum = txnum;
+      this.blk = blk;
+      this.offset = offset;
+      this.val = val;
+   }
+
+   /**
+    * Creates a log record by reading five other values from the log.
+    * @param rec the basic log record
+    */
+   public SetIntRecord(BasicLogRecord rec) {
+      txnum = rec.nextInt();
+      String filename = rec.nextString();
+      int blknum = rec.nextInt();
+      blk = new Block(filename, blknum);
+      offset = rec.nextInt();
+      val = rec.nextInt();
+   }
+
+   /**
+    * Writes a setInt record to the log.
+    * This log record contains the SETINT operator,
+    * followed by the transaction id, the filename, number,
+    * and offset of the modified block, and the previous
+    * integer value at that offset.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {SETINT, txnum, blk.fileName(),
+         blk.number(), offset, val};
+      return logMgr.append(rec);
+   }
+
+   public int op() {
+      return SETINT;
+   }
+
+   public int txNumber() {
+      return txnum;
+   }
+
+   public String toString() {
+      return "<SETINT " + txnum + " " + blk + " " + offset + " " + val + ">";
+   }
+
+   /**
+    * Replaces the specified data value with the value saved in the log record.
+    * The method pins a buffer to the specified block,
+    * calls setInt to restore the saved value
+    * (using a dummy LSN), and unpins the buffer.
+    * @see simpledb.tx.recovery.LogRecord#undo(int)
+    */
+   public void undo(int txnum) {
+      BufferMgr buffMgr = SimpleDB.bufferMgr();
+      Buffer buff = buffMgr.pin(blk);
+      buff.setInt(offset, val, txnum, -1);
+      buffMgr.unpin(buff);
+   }
+}
diff --git a/simpledb/tx/recovery/SetStringRecord.class b/simpledb/tx/recovery/SetStringRecord.class
new file mode 100755
index 0000000..96658bf
Binary files /dev/null and b/simpledb/tx/recovery/SetStringRecord.class differ
diff --git a/simpledb/tx/recovery/SetStringRecord.java b/simpledb/tx/recovery/SetStringRecord.java
new file mode 100755
index 0000000..b22a2ec
--- /dev/null
+++ b/simpledb/tx/recovery/SetStringRecord.java
@@ -0,0 +1,79 @@
+package simpledb.tx.recovery;
+
+import simpledb.server.SimpleDB;
+import simpledb.buffer.*;
+import simpledb.file.Block;
+import simpledb.log.BasicLogRecord;
+
+class SetStringRecord implements LogRecord {
+   private int txnum, offset;
+   private String val;
+   private Block blk;
+   
+   /**
+    * Creates a new setstring log record.
+    * @param txnum the ID of the specified transaction
+    * @param blk the block containing the value
+    * @param offset the offset of the value in the block
+    * @param val the new value
+    */
+   public SetStringRecord(int txnum, Block blk, int offset, String val) {
+      this.txnum = txnum;
+      this.blk = blk;
+      this.offset = offset;
+      this.val = val;
+   }
+   
+   /**
+    * Creates a log record by reading five other values from the log.
+    * @param rec the basic log record
+    */
+   public SetStringRecord(BasicLogRecord rec) {
+      txnum = rec.nextInt();
+      String filename = rec.nextString();
+      int blknum = rec.nextInt();
+      blk = new Block(filename, blknum);
+      offset = rec.nextInt();
+      val = rec.nextString();
+   }
+   
+   /** 
+    * Writes a setString record to the log.
+    * This log record contains the SETSTRING operator,
+    * followed by the transaction id, the filename, number,
+    * and offset of the modified block, and the previous
+    * string value at that offset.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {SETSTRING, txnum, blk.fileName(),
+         blk.number(), offset, val};
+      return logMgr.append(rec);
+   }
+   
+   public int op() {
+      return SETSTRING;
+   }
+   
+   public int txNumber() {
+      return txnum;
+   }
+   
+   public String toString() {
+      return "<SETSTRING " + txnum + " " + blk + " " + offset + " " + val + ">";
+   }
+   
+   /** 
+    * Replaces the specified data value with the value saved in the log record.
+    * The method pins a buffer to the specified block,
+    * calls setString to restore the saved value
+    * (using a dummy LSN), and unpins the buffer.
+    * @see simpledb.tx.recovery.LogRecord#undo(int)
+    */
+   public void undo(int txnum) {
+      BufferMgr buffMgr = SimpleDB.bufferMgr();
+      Buffer buff = buffMgr.pin(blk);
+      buff.setString(offset, val, txnum, -1);
+      buffMgr.unpin(buff);
+   }
+}
diff --git a/simpledb/tx/recovery/StartRecord.class b/simpledb/tx/recovery/StartRecord.class
new file mode 100755
index 0000000..af64ed6
Binary files /dev/null and b/simpledb/tx/recovery/StartRecord.class differ
diff --git a/simpledb/tx/recovery/StartRecord.java b/simpledb/tx/recovery/StartRecord.java
new file mode 100755
index 0000000..38ea028
--- /dev/null
+++ b/simpledb/tx/recovery/StartRecord.java
@@ -0,0 +1,52 @@
+package simpledb.tx.recovery;
+
+import simpledb.log.BasicLogRecord;
+
+class StartRecord implements LogRecord {
+   private int txnum;
+   
+   /**
+    * Creates a new start log record for the specified transaction.
+    * @param txnum the ID of the specified transaction
+    */
+   public StartRecord(int txnum) {
+      this.txnum = txnum;
+   }
+   
+   /**
+    * Creates a log record by reading one other value from the log.
+    * @param rec the basic log record
+    */
+   public StartRecord(BasicLogRecord rec) {
+      txnum = rec.nextInt();
+   }
+   
+   /** 
+    * Writes a start record to the log.
+    * This log record contains the START operator,
+    * followed by the transaction id.
+    * @return the LSN of the last log value
+    */
+   public int writeToLog() {
+      Object[] rec = new Object[] {START, txnum};
+      return logMgr.append(rec);
+   }
+   
+   public int op() {
+      return START;
+   }
+   
+   public int txNumber() {
+      return txnum;
+   }
+   
+   /**
+    * Does nothing, because a start record
+    * contains no undo information.
+    */
+   public void undo(int txnum) {}
+   
+   public String toString() {
+      return "<START " + txnum + ">";
+   }
+}
diff --git a/src/README.txt b/src/README.txt
deleted file mode 100644
index 00ebd03..0000000
--- a/src/README.txt
+++ /dev/null
@@ -1,318 +0,0 @@
-                      THE SIMPLEDB DATABASE SYSTEM
-                  General Information and Instructions
-
-
-This document contains the following sections:
-    * Release Notes
-    * Server Installation
-    * Running the Server
-    * Running Client Programs
-    * SimpleDB Limitations
-    * The Organization of the Server Code
-
-
-I. Release Notes:
-
-  This release of the SimpleDB system is Version 2.9, which was
-  uploaded on August 1, 2011.  This release provides the following
-  bug fixes to Version 2.8:
-
-    * In SortScan.java, the method beforeFirst now sets the variable
-      currentscan to null.
-    * In SortScan.java, the methods savePosition and restorePosition
-      now handle the possibility that s2 is null.
-    * In SelectPlan.java, the method distinctValues now works for
-      predicates of the form A=B as well as A=c.
-    * In IndexInfo.java, the method blocksAccessed now uses the size
-      of the index record instead of the size of the data record.
-
-  SimpleDB is distributed in a WinZip-formatted file. This file contains
-  four items:
-
-    * The folder simpledb, which contains the server-side Java code.
-    * The folder javadoc, which contains the JavaDoc documentation 
-      of the above code.
-    * The folder studentClient, which contains some client-side code 
-      for an example database.
-    * This document.
-
-  The author welcomes all comments, including bug reports, suggestions
-  for improvement, and anectodal experiences.  His email address is: 
-  sciore@bc.edu
-  
-
-II. Installation Instructions:
-
-  1)  Install the Java 1.6 or 1.5 SDK. Java 1.6 is obviously preferable.
-
-  2)  If you do install Java 1.5, you need to make some minor changes 
-      to the package simpledb.remote:
-    
-      * The classes named xxxAdapter provide default implementations of 
-        the interfaces in java.sql. Java 1.6 added several extra methods 
-        to these interfaces. If you are using Java 1.5, just comment out 
-        those methods. (You can tell which ones they are because you'll 
-        get an error when you try to compile them.)
-      
-      * The classes named SimpleXXX call the SQLException constructor 
-        with a Throwable argument.  This constructor is new to version
-        1.6. To use in 1.5, rewrite the code "throw new SQLException(e)"
-        to be "throw new SQLException(e.getMessage())".
-
-  3)  Decide where you want the server-side software to go. Let’s assume 
-      that the code will go in the folder C:\javalib in Windows, or the 
-      folder ~/javalib in UNIX or MacOS.
-
-  4)  Add that folder to your classpath. In other words, the javalib 
-      folder must be mentioned in your CLASSPATH environment variable.
-    
-      * In UNIX, your home directory has an initialization file, 
-        typically called .bashrc.  If the file does not set CLASSPATH,
-        add the following line to the file:  
-               CLASSPATH =.:~/javalib     
-               
-        Here, the ‘:’ character separates folder names.  The command 
-        therefore says that the folder "." (i.e., your current diretory) 
-        and "~/javalib" are to be searched whenever Java needs to find a 
-        class.  If the file already contains a CLASSPATH setting, modify 
-        it to include the javalib directory.
- 
-      * In Windows, you must set the CLASSPATH variable via the System 
-        control panel.  From that control panel, choose the advanced tab 
-        and click on the environment variables button.  You want to have 
-        a user variable named CLASSPATH that looks like this:
-               .;C:\javalib
-               
-        Here, the ‘;’ character separates the two folder names.
-
-  5)  Copy the simpledb folder from the distribution file to that
-      folder. Within the simpledb folder should be subfolders 
-      containing all of the code for SimpleDB.
-
-
-III. Running the Server:
-
-  SimpleDB has a client-server architecture. You run the server code on 
-  a host machine, where it will sit and wait for connections from clients.
-  It is able to handle multiple simultaneous requests from clients, 
-  each on possibly different machines. You can then run a client program
-  from any machine that is able to connect to the host machine.
-
-  To run the SimpleDB server, you need to execute two programs:
-
-  1)  Run the rmiregistry program (which is part of your Java SDK 
-      distribution) as a separate process.  In UNIX, this means executing
-      the command:
-             > rmiregistry & 
-             
-      In Windows, this means executing the command:
-             > start rmiregistry
-
-  2)  Run Java on the simpledb.server.Startup class.  You must pass in
-      the name of a folder that SimpleDB will use to hold the database.
-      For example in Windows, if you execute the command:
-      
-             > start java simpledb.server.Startup studentdb
-             
-      then the server will run in a new window, using studentdb as the
-      database folder.  You can execute this command from any directory;
-      the server will always use the studentdb folder that exists in your
-      home directory.  If a folder with that name does not exist, then
-      one will be created automatically.
- 
-  If everything is working correctly, when you run the server with a
-  new database folder the following will be printed in the server’s 
-  window:
-
-      creating new database
-      new transaction: 1
-      transaction 1 committed
-      database server ready
-
-  If you run the server with an existing database folder, the following
-  will be printed instead:
-
-      recovering existing database
-      database server ready
-
-  In either case, the server will then sit awaiting connections from
-  clients.  As connections arrive, the server will print additional
-  messages in its window.
-
-
-IV. Running Client Programs 
-
-  The SimpleDB server accepts connections from any JDBC client. The client
-  program makes its connection via the following code:
-            Driver d = new SimpleDriver();
-            String host = "mymachine.com"; //any DNS name or IP address
-            String url = "jdbc:simpledb://" + host;
-            Connection conn = d.connect(url, null);
-
-  Note that SimpleDB does not require a username and password, although
-  it is easy enough to modify the server code to do so.
-
-  The driver class SimpleDriver is contained in the package 
-  simpledb.remote, along with the other classes that it needs. A client
-  program will not run unless this package in its classpath. Note that
-  you could install the entire SimpleDB server code on a client machine,
-  but that is overkill.  All you need is simpledb.remote.
-
-  The studentClient folder contains client code for a simple university
-  student-course database.  The folder contains two subfolders, named 
-  simpledb and derby.  The simpledb subfolder contains programs that 
-  run with the SimpleDB database server. The derby subfolder is not
-  relevant here. (It contains programs for the Derby database server,
-  which can be downloaded from db.apache.org. That code is used to
-  illustrate some examples from my text "Database Design and
-  Implementation", published by John WIley.) 
-
-  The following list briefly describes the SimpleDB clients.
-
-    * CreateStudentDB creates and populates the student database used
-      by the other clients.  It therefore must be the first client run 
-      on a new database. 
-    * StudentMajors prints a table listing the names of students and 
-      their majors.
-    * FindMajors requires a command-line argument denoting the name of 
-      a department.  The program then prints the name and graduation
-      year of all students having that major.
-    * SQLInterpreter repeatedly prints a prompt asking you to enter a 
-      single line of text containing an SQL statement.  The program then 
-      executes that statement.  If the statement is a query, the output 
-      table is displayed.  If the statement is an update command, then
-      the number of affected records is printed.  If the statement is ill
-      formed, and error message will be printed.  SimpleDB understands 
-      only a limited subset of SQL, which is described below.
-    * ChangeMajor changes the student named Amy to be a drama major.  
-      It is the only client that updates the database (although you can 
-      use SQLInterpreter to run update commands).
-
-  These clients connect to the server at "localhost".  If the client is  
-  to be run from a different machine than the server, then its source code 
-  must be modified so that localhost is replaced by the domain name (or IP 
-  address) of the server machine. 
-  
-  Unlike the server classes, the client classes are not part of an 
-  explicit package, and thus they need to be run from the directory that
-  they are stored in. For example, suppose we copy the studentClient 
-  folder from the distribution file to our home directory.  In Windows
-  we could execute the client programs as follows:
-
-             > cd C:\studentClient\simpledb
-             > java CreateStudentDB
-
-
-
-V. SimpleDB Limitations
-
-  SimpleDB is a teaching tool. It deliberately implements a tiny subset
-  of SQL and JDBC, and (for simplicity) imposes restrictions not present
-  in the SQL standard.  Here we briefly indicate these restrictions.
-
-
-  SimpleDB SQL
-  
-  A query in SimpleDB consists only of select-from-where clauses in which
-  the select clause contains a list of fieldnames (without the AS 
-  keyword), and the from clause contains a list of tablenames (without
-  range variables).
- 
-  The where clause is optional.  The only Boolean operator is and.  The
-  only comparison operator is equality.  Unlike standard SQL, there are
-  no other comparison operators, no other Boolean operators, no arithmetic
-  operators or built-in functions, and no parentheses.  Consequently,
-  nested queries, aggregation, and computed values are not supported.
-
-  Views can be created, but a view definition can be at most 100 
-  characters.
- 
-  Because there are no range variables and no renaming, all field names in
-  a query must be disjoint.  And because there are no group by or order by
-  clauses, grouping and sorting are not supported.  Other restrictions:
-
-    * The "*" abbreviation in the select clause is not supported.
-    * There are no null values.
-    * There are no explicit joins or outer joins in the from clause.
-    * The union and except keywords are not supported.
-    * Insert statements take explicit values only, not queries.
-    * Update statements can have only one assignment in the set clause.
-
-
-  SimpleDB JDBC
-  
-  SimpleDB implements only the following JDBC methods:
-
-   Driver
-
-      public Connection connect(String url, Properties prop);
-      // The method ignores the contents of variable prop.
-
-   Connection
-
-      public Statement createStatement();
-      public void      close();
-
-   Statement
-
-      public ResultSet executeQuery(String qry);
-      public int       executeUpdate(String cmd);
-
-   ResultSet
-
-      public boolean   next();
-      public int       getInt();
-      public String    getString();
-      public void      close();
-      public ResultSetMetaData getMetaData();
-
-   ResultSetMetaData
-
-      public int        getColumnCount();
-      public String     getColumnName(int column);
-      public int        getColumnType(int column);
-      public int getColumnDisplaySize(int column);
-
-
-
-VI. The Organization of the Server Code
-
-  SimpleDB is usable without knowing anything about what the code looks
-  like. However, the entire point of the system is to make the code
-  easy to read and modify.  The basic packages in SimpleDB are structured
-  hierarchically, in the following order:
-
-    * file (Manages OS files as a virtual disk.)
-    * log (Manages the log.)
-    * buffer (Manages a buffer pool of pages in memory that acts as a
-              cache of disk blocks.)
-    * tx (Implements transactions at the page level.  Does locking
-          and logging.)
-    * record (Implements fixed-length records inside of pages.)
-    * metadata (Maintains metadata in the system catalog.)
-    * query (Implements relational algebra operations.  Each operation 
-             has a plan class, used by the planner, and a scan class,
-             used at runtime.)
-    * parse (Implements the parser.)
-    * planner (Implements a naive planner for SQL statements.)
-    * remote (Implements the server using RMI.)
-    * server (The place where the startup and initialization code live. 
-              The class Startup contains the main method.)
-
-  The basic server is exceptionally inefficient.  The following packages
-  enable more efficient query processing:
-
-    * index (Implements static hash and btree indexes, as well as 
-             extensions to the parser and planner to take advantage
-             of them.)
-    * materialize (Implements implementations of the relational 
-                   operators materialize, sort, groupby, and mergejoin.)
-    * multibuffer (Implements modifications to the sort and product 
-                   operators, in order to make optimum use of available
-                   buffers.)
-    * opt (Implements a heuristic query optimizer)
- 
-   The textbook "Database Design and Implementation" describes these
-   packages in considerably more detail. For further information, go
-   to the URL www.wiley.com/college/sciore
-   
\ No newline at end of file
diff --git a/src/simpledb/application/SimpleDBConnect.java b/src/simpledb/application/SimpleDBConnect.java
deleted file mode 100644
index 969ab06..0000000
--- a/src/simpledb/application/SimpleDBConnect.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * 
- */
-package simpledb.application;
-
-import java.sql.Connection;
-import java.sql.Driver;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import simpledb.remote.ConnectionAdapter;
-import simpledb.remote.DriverAdapter;
-import simpledb.remote.SimpleDriver;
-
-/**
- * @author Jeff
- *
- */
-public class SimpleDBConnect {
-
-	/**
-	 * @param args
-	 */
-	public static void main(String[] args) {
-		// TODO Auto-generated method stub
-		Connection conn = null;
-		Driver d = new SimpleDriver();
-		String host = "localhost"; //my ip
-		//String host = "csta096.cs.wpi.edu";
-		String url = "jdbc:simpledb://" + host;
-		String qry ="Create table test1" + 
-					"( a1 int," +
-					" a2 int"+
-					");";
-		Statement s=null;
-		try {
-			conn = d.connect(url, null);
-			s=conn.createStatement();
-			System.out.println("Create table: "+s.executeUpdate(qry));
-			qry="insert into test1(a1, a2) values (432, 957);";
-			System.out.println("Insert table: "+s.executeUpdate(qry));
-			qry="select a1,a2 from test1;";
-			ResultSet rs=s.executeQuery(qry);
-			while(rs.next())
-			{
-				System.out.println(qry+"\n Query result: "+"a1="+rs.getInt("a1")+ " a2="+rs.getInt("a2"));
-				
-			}
-		} catch (SQLException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		System.out.println(conn.toString());
-	}
-
-}
diff --git a/src/simpledb/buffer/AbstractBasicBufferMgr.java b/src/simpledb/buffer/AbstractBasicBufferMgr.java
deleted file mode 100644
index 719e87b..0000000
--- a/src/simpledb/buffer/AbstractBasicBufferMgr.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/**
- * 
- */
-package simpledb.buffer;
-
-import simpledb.file.Block;
-
-/**
- * Abstract class for a buffer manager, which handles functions like pinning and allocating buffers.
- * @author directxman12
- *
- */
-public abstract class AbstractBasicBufferMgr
-{
-	protected int numAvailable;
-	protected int _ioCount = 0;
-	
-	public AbstractBasicBufferMgr(int numbuffs)
-	{
-		numAvailable = numbuffs;
-	}
-	   
-	/**
-	* Flushes the dirty buffers modified by the specified transaction.
-	* @param txnum the transaction's id number
-	*/
-	abstract void flushAll(int txnum);
-	   
-	/**
-	* Pins a buffer to the specified block. 
-	* If there is already a buffer assigned to that block
-	* then that buffer is used;  
-	* otherwise, an unpinned buffer from the pool is chosen.
-	* Returns a null value if there are no available buffers.
-	* @param blk a reference to a disk block
-	* @return the pinned buffer
-	*/
-	synchronized Buffer pin(Block blk)
-	{
-		Buffer buff = findExistingBuffer(blk);
-		if (buff == null) {
-			buff = chooseUnpinnedBuffer();
-		    if (buff == null) return null;
-		    buff.assignToBlock(blk);
-		    _ioCount++;
-		}
-		if (!buff.isPinned()) numAvailable--;
-		buff.pin();
-		return buff;
-	}
-	   
-	/**
-	* Allocates a new block in the specified file, and
-	* pins a buffer to it. 
-	* Returns null (without allocating the block) if 
-	* there are no available buffers.
-	* @param filename the name of the file
-	* @param fmtr a pageformatter object, used to format the new block
-	* @return the pinned buffer
-	*/
-	synchronized Buffer pinNew(String filename, PageFormatter fmtr)
-	{
-		Buffer buff = chooseUnpinnedBuffer();
-	    if (buff == null) return null;
-	    buff.assignToNew(filename, fmtr);
-	    numAvailable--;
-	    buff.pin();
-	    return buff;
-	}
-	   
-	/**
-	* Unpins the specified buffer.
-	* @param buff the buffer to be unpinned
-	*/
-	protected synchronized void unpin(Buffer buff)
-	{
-		buff.unpin();
-		if (!buff.isPinned()) numAvailable++;
-	}
-	   
-	/**
-	* Returns the number of available (i.e. unpinned) buffers.
-	* @return the number of available buffers
-	*/
-	public int available()
-	{
-		return numAvailable;
-	}
-	
-	/**
-	 * Returns the current number of IOs that have occured.
-	 * @return the current number of IOs that have occured.
-	 */
-	synchronized int getIOCount()
-	{
-		return _ioCount;
-	}
-	
-	/**
-	 * 
-	 * @param blk
-	 * @return
-	 */
-	protected abstract Buffer findExistingBuffer(Block blk);
-	
-	/**
-	 * Returns a buffer that is available for use (i.e. not pinned), or null if there are no 
-	 * unpinned buffers.
-	 * @return a buffer that is available for use, or null if none available.
-	 */
-	protected abstract Buffer chooseUnpinnedBuffer();	
-	
-	/**
-	 * A string representation of the Buffer.
-	 */
-	public abstract String toString();
-
-}
diff --git a/src/simpledb/buffer/BasicBufferMgr.class b/src/simpledb/buffer/BasicBufferMgr.class
deleted file mode 100644
index 2cef7b7..0000000
Binary files a/src/simpledb/buffer/BasicBufferMgr.class and /dev/null differ
diff --git a/src/simpledb/buffer/BasicBufferMgr.java b/src/simpledb/buffer/BasicBufferMgr.java
deleted file mode 100644
index cafd615..0000000
--- a/src/simpledb/buffer/BasicBufferMgr.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package simpledb.buffer;
-
-import simpledb.file.*;
-
-/**
- * Manages the pinning and unpinning of buffers to blocks.
- * @author Edward Sciore
- *
- */
-public class BasicBufferMgr extends AbstractBasicBufferMgr
-{
-   protected Buffer[] bufferpool;
-   
-   /**
-    * Creates a buffer manager having the specified number 
-    * of buffer slots.
-    * This constructor depends on both the {@link FileMgr} and
-    * {@link simpledb.log.LogMgr LogMgr} objects 
-    * that it gets from the class
-    * {@link simpledb.server.SimpleDB}.
-    * Those objects are created during system initialization.
-    * Thus this constructor cannot be called until 
-    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
-    * is called first.
-    * @param numbuffs the number of buffer slots to allocate
-    */
-   public BasicBufferMgr(int numbuffs)
-   {
-	  super(numbuffs);
-      bufferpool = new Buffer[numbuffs];
-      for (int i=0; i<numbuffs; i++)
-         bufferpool[i] = new Buffer();
-   }
-   
-   /**
-    * {@inheritDoc}
-    */
-   synchronized void flushAll(int txnum)
-   {
-      for (Buffer buff : bufferpool)
-         if (buff.isModifiedBy(txnum))
-         buff.flush();
-   }
-   
-   /**
-    * {@inheritDoc}
-    */
-   protected Buffer findExistingBuffer(Block blk) {
-      for (Buffer buff : bufferpool) {
-         Block b = buff.block();
-         if (b != null && b.equals(blk))
-            return buff;
-      }
-      return null;
-   }
-   
-   /**
-    * {@inheritDoc}
-    */
-   protected Buffer chooseUnpinnedBuffer() {
-      for (Buffer buff : bufferpool)
-         if (!buff.isPinned())
-         return buff;
-      return null;
-   }
-   
-   /**
-    * {@inheritDoc}
-    */
-   public String toString()
-   {
-	   return "{alg: \"basic\", totalpool: "+bufferpool+"}";
-   }
-}
diff --git a/src/simpledb/buffer/Buffer.class b/src/simpledb/buffer/Buffer.class
deleted file mode 100644
index 3597254..0000000
Binary files a/src/simpledb/buffer/Buffer.class and /dev/null differ
diff --git a/src/simpledb/buffer/Buffer.java b/src/simpledb/buffer/Buffer.java
deleted file mode 100644
index 181fa48..0000000
--- a/src/simpledb/buffer/Buffer.java
+++ /dev/null
@@ -1,202 +0,0 @@
-package simpledb.buffer;
-
-import simpledb.server.SimpleDB;
-import simpledb.file.*;
-
-/**
- * An individual buffer.
- * A buffer wraps a page and stores information about its status,
- * such as the disk block associated with the page,
- * the number of times the block has been pinned,
- * whether the contents of the page have been modified,
- * and if so, the id of the modifying transaction and
- * the LSN of the corresponding log record.
- * @author Edward Sciore
- */
-public class Buffer {
-   private Page contents = new Page();
-   private int logSequenceNumber = -1; // negative means no corresponding log record
-   
-   protected Block blk = null;
-   protected int pins = 0;
-   protected int modifiedBy = -1;  // negative means not modified
-
-   /**
-    * Creates a new buffer, wrapping a new 
-    * {@link simpledb.file.Page page}.  
-    * This constructor is called exclusively by the 
-    * class {@link AbstractBasicBufferMgr}.   
-    * It depends on  the 
-    * {@link simpledb.log.LogMgr LogMgr} object 
-    * that it gets from the class
-    * {@link simpledb.server.SimpleDB}.
-    * That object is created during system initialization.
-    * Thus this constructor cannot be called until 
-    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
-    * is called first.
-    */
-   public Buffer() {}
-   
-   /**
-    * Returns the integer value at the specified offset of the
-    * buffer's page.
-    * If an integer was not stored at that location,
-    * the behavior of the method is unpredictable.
-    * @param offset the byte offset of the page
-    * @return the integer value at that offset
-    */
-   public int getInt(int offset) {
-      return contents.getInt(offset);
-   }
-
-   /**
-    * Returns the string value at the specified offset of the
-    * buffer's page.
-    * If a string was not stored at that location,
-    * the behavior of the method is unpredictable.
-    * @param offset the byte offset of the page
-    * @return the string value at that offset
-    */
-   public String getString(int offset) {
-      return contents.getString(offset);
-   }
-
-   /**
-    * Writes an integer to the specified offset of the
-    * buffer's page.
-    * This method assumes that the transaction has already
-    * written an appropriate log record.
-    * The buffer saves the id of the transaction
-    * and the LSN of the log record.
-    * A negative lsn value indicates that a log record
-    * was not necessary.
-    * @param offset the byte offset within the page
-    * @param val the new integer value to be written
-    * @param txnum the id of the transaction performing the modification
-    * @param lsn the LSN of the corresponding log record
-    */
-   public void setInt(int offset, int val, int txnum, int lsn) {
-      modifiedBy = txnum;
-      if (lsn >= 0)
-	      logSequenceNumber = lsn;
-      contents.setInt(offset, val);
-   }
-
-   /**
-    * Writes a string to the specified offset of the
-    * buffer's page.
-    * This method assumes that the transaction has already
-    * written an appropriate log record.
-    * A negative lsn value indicates that a log record
-    * was not necessary.
-    * The buffer saves the id of the transaction
-    * and the LSN of the log record.
-    * @param offset the byte offset within the page
-    * @param val the new string value to be written
-    * @param txnum the id of the transaction performing the modification
-    * @param lsn the LSN of the corresponding log record
-    */
-   public void setString(int offset, String val, int txnum, int lsn) {
-      modifiedBy = txnum;
-      if (lsn >= 0)
-	      logSequenceNumber = lsn;
-      contents.setString(offset, val);
-   }
-
-   /**
-    * Writes the page to its disk block if the
-    * page is dirty.
-    * The method ensures that the corresponding log
-    * record has been written to disk prior to writing
-    * the page to disk.
-    */
-   protected void flush() {
-      if (modifiedBy >= 0) {
-         SimpleDB.logMgr().flush(logSequenceNumber);
-         contents.write(blk);
-         modifiedBy = -1;
-      }
-   }
-
-   /**
-    * Reads the contents of the specified block into
-    * the buffer's page.
-    * If the buffer was dirty, then the contents
-    * of the previous page are first written to disk.
-    * @param b a reference to the data block
-    */
-   protected void assignToBlock(Block b) {
-      flush();
-      blk = b;
-      contents.read(blk);
-      pins = 0;
-   }
-
-   /**
-    * Initializes the buffer's page according to the specified formatter,
-    * and appends the page to the specified file.
-    * If the buffer was dirty, then the contents
-    * of the previous page are first written to disk.
-    * @param filename the name of the file
-    * @param fmtr a page formatter, used to initialize the page
-    */
-   protected void assignToNew(String filename, PageFormatter fmtr) {
-      flush();
-      fmtr.format(contents);
-      blk = contents.append(filename);
-      pins = 0;
-   }
-
-   /**
-    * Returns a reference to the disk block
-    * that the buffer is pinned to.
-    * @return a reference to a disk block
-    */
-   public Block block() {
-      return blk;
-   }
-
-   /**
-    * Increases the buffer's pin count.
-    */
-   void pin() {
-      pins++;
-   }
-
-   /**
-    * Decreases the buffer's pin count.
-    */
-   void unpin() {
-      pins--;
-   }
-
-   /**
-    * Returns true if the buffer is currently pinned
-    * (that is, if it has a nonzero pin count).
-    * @return true if the buffer is pinned
-    */
-   boolean isPinned() {
-      return pins > 0;
-   }
-
-   /**
-    * Returns true if the buffer is dirty
-    * due to a modification by the specified transaction.
-    * @param txnum the id of the transaction
-    * @return true if the transaction modified the buffer
-    */
-   boolean isModifiedBy(int txnum) {
-      return txnum == modifiedBy;
-   }
-   
-   /**
-    * Returns a string representation of the buffer.
-    * (TODO: Add sting format)
-    */
-   public String toString()
-   {
-	   String blkVal = "null";
-	   if (this.blk != null) blkVal = this.blk.toString();
-	   return "{blk: "+blkVal+", pins: " + Integer.toString(pins) +"}";
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/buffer/BufferAbortException.class b/src/simpledb/buffer/BufferAbortException.class
deleted file mode 100644
index c559dd0..0000000
Binary files a/src/simpledb/buffer/BufferAbortException.class and /dev/null differ
diff --git a/src/simpledb/buffer/BufferAbortException.java b/src/simpledb/buffer/BufferAbortException.java
deleted file mode 100644
index e983522..0000000
--- a/src/simpledb/buffer/BufferAbortException.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package simpledb.buffer;
-
-/**
- * A runtime exception indicating that the transaction
- * needs to abort because a buffer request could not be satisfied.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-public class BufferAbortException extends RuntimeException {}
diff --git a/src/simpledb/buffer/BufferMgr.class b/src/simpledb/buffer/BufferMgr.class
deleted file mode 100644
index d49c69f..0000000
Binary files a/src/simpledb/buffer/BufferMgr.class and /dev/null differ
diff --git a/src/simpledb/buffer/BufferMgr.java b/src/simpledb/buffer/BufferMgr.java
deleted file mode 100644
index 78efa0a..0000000
--- a/src/simpledb/buffer/BufferMgr.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package simpledb.buffer;
-
-import simpledb.file.Block;
-import simpledb.file.FileMgr;
-
-/**
- * The publicly-accessible buffer manager.
- * A buffer manager wraps a basic buffer manager, and
- * provides the same methods. The difference is that
- * the methods {@link #pin(Block) pin} and 
- * {@link #pinNew(String, PageFormatter) pinNew}
- * will never return null.
- * If no buffers are currently available, then the
- * calling thread will be placed on a waiting list.
- * The waiting threads are removed from the list when 
- * a buffer becomes available.
- * If a thread has been waiting for a buffer for an
- * excessive amount of time (currently, 10 seconds)
- * then a {@link BufferAbortException} is thrown.
- * @author Edward Sciore
- */
-public class BufferMgr {
-   protected static final long MAX_TIME = 10000; // 10 seconds
-   protected AbstractBasicBufferMgr bufferMgr;
-   
-   protected static Class _buffMgrType;
-   
-   /**
-    * Sets the class to use for the buffer manager. (Note: the parameter MUST be a subclass of
-    * AbstractBasicBufferMgr.)
-    * @param cls the buffer manager class
-    * @see AbstractBasicBufferMgr
-    */
-   public static void setBasicBuffMgrType(Class cls)
-   {
-	   if(!AbstractBasicBufferMgr.class.isAssignableFrom(cls)) throw new RuntimeException("BasicBufferManagers need to extend AbstractBasicBufferMgr!");
-	   _buffMgrType = cls;
-   }
-   
-   /**
-    * Returns the number of IOs that have occured.
-    * @return the number of IOs that have occured
-    */
-   public int getIOCount()
-   {
-	   return bufferMgr.getIOCount();
-   }
-    
-   int _numbuffers;
-
-   /**
-    * Creates and assigns a new instance of the buffer manager blahh blahh blahh (:?)
-    */
-   public void resetBasicBufferMgr()
-   {
-	   if (_buffMgrType == null) _buffMgrType = LRUBasicBufferMgr.class;
-	   try
-	   {
-		   bufferMgr = (AbstractBasicBufferMgr) _buffMgrType.getConstructor(Integer.TYPE).newInstance(_numbuffers);
-	   }
-	   catch (Exception e)
-	   {
-		   throw new RuntimeException("Error instantiating the buffer manager");
-	   } 
-   }
-  
-   /**
-    * Creates a new buffer manager having the specified 
-    * number of buffers.
-    * This constructor depends on both the {@link FileMgr} and
-    * {@link simpledb.log.LogMgr LogMgr} objects 
-    * that it gets from the class
-    * {@link simpledb.server.SimpleDB}.
-    * Those objects are created during system initialization.
-    * Thus this constructor cannot be called until 
-    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
-    * is called first.
-    * @param numbuffers the number of buffer slots to allocate
-    */
-   public BufferMgr(int numbuffers)
-   {
-	   _numbuffers = numbuffers;
-	   if (_buffMgrType == null) _buffMgrType = LRUBasicBufferMgr.class;
-	   try
-	   {
-		   bufferMgr = (AbstractBasicBufferMgr) _buffMgrType.getConstructor(Integer.TYPE).newInstance(numbuffers);
-	   }
-	   catch (Exception e)
-	   {
-		   throw new RuntimeException("Error instantiating the buffer manager");
-	   } 
-   }
-   
-   /**
-    * Pins a buffer to the specified block, potentially
-    * waiting until a buffer becomes available.
-    * If no buffer becomes available within a fixed 
-    * time period, then a {@link BufferAbortException} is thrown.
-    * @param blk a reference to a disk block
-    * @return the buffer pinned to that block
-    */
-   public synchronized Buffer pin(Block blk) {
-      try {
-         long timestamp = System.currentTimeMillis();
-         Buffer buff = bufferMgr.pin(blk);
-         while (buff == null && !waitingTooLong(timestamp)) {
-            wait(MAX_TIME);
-            buff = bufferMgr.pin(blk);
-         }
-         if (buff == null)
-            throw new BufferAbortException();
-         return buff;
-      }
-      catch(InterruptedException e) {
-         throw new BufferAbortException();
-      }
-   }
-   
-   /**
-    * Pins a buffer to a new block in the specified file, 
-    * potentially waiting until a buffer becomes available.
-    * If no buffer becomes available within a fixed 
-    * time period, then a {@link BufferAbortException} is thrown.
-    * @param filename the name of the file
-    * @param fmtr the formatter used to initialize the page
-    * @return the buffer pinned to that block
-    */
-   public synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
-      try {
-         long timestamp = System.currentTimeMillis();
-         Buffer buff = bufferMgr.pinNew(filename, fmtr);
-         while (buff == null && !waitingTooLong(timestamp)) {
-            wait(MAX_TIME);
-            buff = bufferMgr.pinNew(filename, fmtr);
-         }
-         if (buff == null)
-            throw new BufferAbortException();
-         return buff;
-      }
-      catch(InterruptedException e) {
-         throw new BufferAbortException();
-      }
-   }
-   
-   /**
-    * Unpins the specified buffer. 
-    * If the buffer's pin count becomes 0,
-    * then the threads on the wait list are notified.
-    * @param buff the buffer to be unpinned
-    */
-   public synchronized void unpin(Buffer buff) {
-      bufferMgr.unpin(buff);
-      if (!buff.isPinned())
-         notifyAll();
-   }
-   
-   /**
-    * Flushes the dirty buffers modified by the specified transaction.
-    * @param txnum the transaction's id number
-    */
-   public void flushAll(int txnum) {
-      bufferMgr.flushAll(txnum);
-   }
-   
-   /**
-    * Returns the number of available (ie unpinned) buffers.
-    * @return the number of available buffers
-    */
-   public int available() {
-      return bufferMgr.available();
-   }
-   
-   /**
-    * Returns true if the time elapsed from a specified starting time exceeds the max allowed time
-    * for waiting for a buffer.
-    * @param starttime the starting time
-    * @return true if waited too long for a buffer
-    */
-   protected boolean waitingTooLong(long starttime) {
-      return System.currentTimeMillis() - starttime > MAX_TIME;
-   }
-   
-   /**
-    * Returns a string representation of the buffer manager.
-    * (TODO: String format)
-    */
-   @Override
-   public String toString()
-   {
-	   return "{basicClass: \""+_buffMgrType.toString()+"\", basicmgr: " + bufferMgr.toString()+"}";
-   }
-}
diff --git a/src/simpledb/buffer/LRUBasicBufferMgr.java b/src/simpledb/buffer/LRUBasicBufferMgr.java
deleted file mode 100644
index d5e00bd..0000000
--- a/src/simpledb/buffer/LRUBasicBufferMgr.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * 
- */
-package simpledb.buffer;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import simpledb.file.Block;
-
-/**
- * Basic Buffer Manager implementation that uses an LRU (Least Recently Used) algorithm to manage
- * buffer usage.
- * @author directxman12
- */
-public class LRUBasicBufferMgr extends AbstractBasicBufferMgr
-{
-	protected LinkedBlockingQueue<Buffer> _availBufPool; // preforms differently if linked vs array
-	protected HashMap<Block, Buffer> _allocatedBufMap;
-	protected int _queueSize;
-
-	/**
-	 * Creates an instance of a LRUBasicBufferMgr with a specified number of buffers. 
-	 * @param numbuffs the number of buffers
-	 */
-	public LRUBasicBufferMgr(int numbuffs)
-	{
-		super(numbuffs);
-		_queueSize = numbuffs;
-		numAvailable = numbuffs;
-		_availBufPool = new LinkedBlockingQueue<Buffer>(numbuffs);
-		_allocatedBufMap = new HashMap<Block, Buffer>(numbuffs);
-		for(int i = 0; i < numbuffs; i++) _availBufPool.add(new Buffer());
-		
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	synchronized Buffer pin(Block blk)
-	{
-		Buffer buff = findExistingBuffer(blk); // try to find if the block is in an existing buffer
-		if (buff == null) // if not ...
-		{
-			buff = chooseUnpinnedBuffer(); // grab an unpinned buffer
-		    if (buff == null) return null; // (if there's no unpinned, die)
-		    _allocatedBufMap.remove(buff.block()); // remove the old mapping
-		    buff.assignToBlock(blk); // assign the new block to the old buffer
-		    _ioCount++; // increase the I/O count (slow!)
-		}
-		if (!buff.isPinned()) // if the buffer was from the available pool
-		{
-			_availBufPool.remove(buff); // remove it from said pool
-		}
-		buff.pin(); // pin it
-		_allocatedBufMap.put(blk, buff); // put the new mapping into the map
-		return buff;
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	protected synchronized void unpin(Buffer buff)
-	{
-		super.unpin(buff);
-		if(buff.pins < 1) // add to the pool if there's nothing left using it
-		{
-			_availBufPool.add(buff);
-		}
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	synchronized Buffer pinNew(String filename, PageFormatter fmtr)
-	{
-		Buffer buff = super.pinNew(filename, fmtr);
-		if (buff == null) return null;
-		_allocatedBufMap.put(buff.block(), buff);
-		return buff;
-	}
-	
-	/**
-    * {@inheritDoc}
-    */	
-	@Override
-	protected synchronized Buffer findExistingBuffer(Block blk)
-	{
-		return _allocatedBufMap.get(blk); // yay hashes
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	protected synchronized Buffer chooseUnpinnedBuffer()
-	{
-		Buffer b = _availBufPool.poll(); // FIFO queue functionality -- gets the head
-		/*if (_availBufPool.contains(b))
-		{
-			System.out.println("WTF2!?!");
-		}*/
-		return b;
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	public int available()
-	{
-		return _availBufPool.size();
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	void flushAll(int txnum)
-	{
-      for (Buffer buff : _availBufPool) if (buff.isModifiedBy(txnum)) buff.flush();
-      for (Buffer buff : _allocatedBufMap.values()) if (buff.isModifiedBy(txnum)) buff.flush();
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	public String toString()
-	{
-		return "{alg: \"LRU\", allocated: "+toJSON(_allocatedBufMap)+", available: " + _availBufPool.toString()+"}";
-	}
-	
-	/**
-	 * Converts a HashMap to a suitable JSON string representation.
-	 * @param m the HashMap
-	 * @return JSON string representation
-	 */
-	protected <V> String toJSON(HashMap<Block, V> m)
-	{
-		StringBuilder sb = new StringBuilder("{");
-		Set<Block> ks = m.keySet();
-		Iterator<Block> iter = ks.iterator();
-		
-		for (int i = 0; i < ks.size(); i++)
-		{
-			Block key = iter.next();
-			sb.append(key.toIDString());
-			sb.append(": ");
-			sb.append(m.get(key).toString());
-			if (i < ks.size() - 1) sb.append(",");
-		}
-		
-		sb.append("}");
-		return sb.toString();
-	}
-}
diff --git a/src/simpledb/buffer/MRUBasicBufferMgr.java b/src/simpledb/buffer/MRUBasicBufferMgr.java
deleted file mode 100644
index 5f58777..0000000
--- a/src/simpledb/buffer/MRUBasicBufferMgr.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * 
- */
-package simpledb.buffer;
-
-import java.util.HashMap;
-import java.util.concurrent.LinkedBlockingDeque;
-
-import simpledb.file.Block;
-
-/**
- * Basic Buffer Manager implementation that uses an MRU (Most Recently Used) algorithm to manage
- * buffer usage.
- * @author jeffnamias
- */
-public class MRUBasicBufferMgr extends AbstractBasicBufferMgr
-{
-	protected LinkedBlockingDeque<Buffer> _availBufPool; // preforms differently if linked vs array
-	protected HashMap<Block, Buffer> _allocatedBufMap;
-	protected int _queueSize;
-
-	/**
-	 * Creates an instance of a MRUBasicBufferMgr with a specified number of buffers. 
-	 * @param numbuffs the number of buffers
-	 */
-	public MRUBasicBufferMgr(int numbuffs)
-	{
-		super(numbuffs);
-		_queueSize = numbuffs;
-		numAvailable = numbuffs;
-		_availBufPool = new LinkedBlockingDeque<Buffer>(numbuffs);
-		_allocatedBufMap = new HashMap<Block, Buffer>(numbuffs);
-		for(int i = 0; i < numbuffs; i++) _availBufPool.add(new Buffer());
-		
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	synchronized Buffer pin(Block blk)
-	{
-		// for inline docs, see the LRU pin method -- this once works the same way
-		Buffer buff = findExistingBuffer(blk);
-		if (buff == null) {
-			buff = chooseUnpinnedBuffer();
-		    if (buff == null) return null;
-		    _allocatedBufMap.remove(buff.block());
-		    buff.assignToBlock(blk);
-		    _ioCount++;
-		}
-		if (!buff.isPinned())
-		{
-			_availBufPool.remove(buff);
-		}
-		buff.pin();
-		_allocatedBufMap.put(blk, buff);
-		return buff;
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	protected synchronized void unpin(Buffer buff)
-	{
-		super.unpin(buff);
-		if(buff.pins < 1 /* && !_availBufPool.contains(buff) */)
-		{
-			_availBufPool.addFirst(buff); // adds to the head, not the tail like LRU
-		}
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	synchronized Buffer pinNew(String filename, PageFormatter fmtr)
-	{
-		Buffer buff = super.pinNew(filename, fmtr);
-		if (buff == null) return null;
-		_allocatedBufMap.put(buff.block(), buff);
-		return buff;
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	protected synchronized Buffer findExistingBuffer(Block blk)
-	{
-		return _allocatedBufMap.get(blk);
-	}
-	
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	protected synchronized Buffer chooseUnpinnedBuffer()
-	{
-		Buffer b = _availBufPool.poll();
-		if (_availBufPool.contains(b))
-		{
-			System.out.println("WTF2!?!");
-		}
-		return b;
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	public int available()
-	{
-		return _availBufPool.size();
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	void flushAll(int txnum)
-	{
-      for (Buffer buff : _availBufPool) if (buff.isModifiedBy(txnum)) buff.flush();
-      for (Buffer buff : _allocatedBufMap.values()) if (buff.isModifiedBy(txnum)) buff.flush();
-	}
-
-	/**
-    * {@inheritDoc}
-    */
-	@Override
-	public String toString()
-	{
-		return "{alg: \"MRU\", allocated: "+_allocatedBufMap.toString()+", available: " + _availBufPool.toString()+"}";
-	}
-}
diff --git a/src/simpledb/buffer/PageFormatter.class b/src/simpledb/buffer/PageFormatter.class
deleted file mode 100644
index 44d94e9..0000000
Binary files a/src/simpledb/buffer/PageFormatter.class and /dev/null differ
diff --git a/src/simpledb/buffer/PageFormatter.java b/src/simpledb/buffer/PageFormatter.java
deleted file mode 100644
index 2041d17..0000000
--- a/src/simpledb/buffer/PageFormatter.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package simpledb.buffer;
-
-import simpledb.file.Page;
-
-/**
- * An interface used to initialize a new block on disk.
- * There will be an implementing class for each "type" of
- * disk block.
- * @author Edward Sciore
- */
-public interface PageFormatter {
-   /**
-    * Initializes a page, whose contents will be
-    * written to a new disk block.
-    * This method is called only during the method
-    * {@link Buffer#assignToNew}.
-    * @param p a buffer page
-    */
-   public void format(Page p);
-}
diff --git a/src/simpledb/file/Block.class b/src/simpledb/file/Block.class
deleted file mode 100644
index 33babac..0000000
Binary files a/src/simpledb/file/Block.class and /dev/null differ
diff --git a/src/simpledb/file/Block.java b/src/simpledb/file/Block.java
deleted file mode 100644
index 453b7a7..0000000
--- a/src/simpledb/file/Block.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package simpledb.file;
-
-/**
- * A reference to a disk block.
- * A Block object consists of a filename and a block number.
- * It does not hold the contents of the block;
- * instead, that is the job of a {@link Page} object.
- * @author Edward Sciore
- */
-public class Block {
-   private String filename;
-   private int blknum;
-   
-   /**
-    * Constructs a block reference 
-    * for the specified filename and block number.
-    * @param filename the name of the file
-    * @param blknum the block number
-    */
-   public Block(String filename, int blknum) {
-      this.filename = filename;
-      this.blknum   = blknum;
-   }
-   
-   /**
-    * Returns the name of the file where the block lives.
-    * @return the filename
-    */
-   public String fileName() {
-      return filename;
-   }
-   
-   /**
-    * Returns the location of the block within the file.
-    * @return the block number
-    */
-   public int number() {
-      return blknum;
-   }
-   
-   public boolean equals(Object obj) {
-      Block blk = (Block) obj;
-      return filename.equals(blk.filename) && blknum == blk.blknum;
-   }
-   
-   public String toString() {
-      return "{file: \"" + filename + "\", block: \"" + blknum + "\"}";
-   }
-   
-   public String toIDString()
-   {
-	   return "\"{file:" + filename + ", block:" + blknum + "}\"";
-   }
-   
-   public int hashCode() {
-      return toString().hashCode();
-   }
-}
diff --git a/src/simpledb/file/FileMgr.class b/src/simpledb/file/FileMgr.class
deleted file mode 100644
index 01e5103..0000000
Binary files a/src/simpledb/file/FileMgr.class and /dev/null differ
diff --git a/src/simpledb/file/FileMgr.java b/src/simpledb/file/FileMgr.java
deleted file mode 100644
index 0ba7b70..0000000
--- a/src/simpledb/file/FileMgr.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package simpledb.file;
-
-import static simpledb.file.Page.BLOCK_SIZE;
-import java.io.*;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.*;
-
-/**
- * The SimpleDB file manager.
- * The database system stores its data as files within a specified directory.
- * The file manager provides methods for reading the contents of
- * a file block to a Java byte buffer,
- * writing the contents of a byte buffer to a file block,
- * and appending the contents of a byte buffer to the end of a file.
- * These methods are called exclusively by the class {@link simpledb.file.Page Page},
- * and are thus package-private.
- * The class also contains two public methods:
- * Method {@link #isNew() isNew} is called during system initialization by {@link simpledb.server.SimpleDB#init}.
- * Method {@link #size(String) size} is called by the log manager and transaction manager to
- * determine the end of the file.
- * @author Edward Sciore
- */
-public class FileMgr {
-   private File dbDirectory;
-   private boolean isNew;
-   private Map<String,FileChannel> openFiles = new HashMap<String,FileChannel>();
-
-   /**
-    * Creates a file manager for the specified database.
-    * The database will be stored in a folder of that name
-    * in the user's home directory.
-    * If the folder does not exist, then a folder containing
-    * an empty database is created automatically.
-    * Files for all temporary tables (i.e. tables beginning with "temp") are deleted.
-    * @param dbname the name of the directory that holds the database
-    */
-   public FileMgr(String dbname) {
-      String homedir = System.getProperty("user.home");
-      dbDirectory = new File(homedir, dbname);
-      isNew = !dbDirectory.exists();
-
-      // create the directory if the database is new
-      if (isNew && !dbDirectory.mkdir())
-         throw new RuntimeException("cannot create " + dbname);
-
-      // remove any leftover temporary tables
-      for (String filename : dbDirectory.list())
-         if (filename.startsWith("temp"))
-         new File(dbDirectory, filename).delete();
-   }
-
-   /**
-    * Reads the contents of a disk block into a bytebuffer.
-    * @param blk a reference to a disk block
-    * @param bb  the bytebuffer
-    */
-   synchronized void read(Block blk, ByteBuffer bb) {
-      try {
-         bb.clear();
-         FileChannel fc = getFile(blk.fileName());
-         fc.read(bb, blk.number() * BLOCK_SIZE);
-      }
-      catch (IOException e) {
-         throw new RuntimeException("cannot read block " + blk);
-      }
-   }
-
-   /**
-    * Writes the contents of a bytebuffer into a disk block.
-    * @param blk a reference to a disk block
-    * @param bb  the bytebuffer
-    */
-   synchronized void write(Block blk, ByteBuffer bb) {
-      try {
-         bb.rewind();
-         FileChannel fc = getFile(blk.fileName());
-         fc.write(bb, blk.number() * BLOCK_SIZE);
-      }
-      catch (IOException e) {
-         throw new RuntimeException("cannot write block" + blk);
-      }
-   }
-
-   /**
-    * Appends the contents of a bytebuffer to the end
-    * of the specified file.
-    * @param filename the name of the file
-    * @param bb  the bytebuffer
-    * @return a reference to the newly-created block.
-    */
-   synchronized Block append(String filename, ByteBuffer bb) {
-      int newblknum = size(filename);
-      Block blk = new Block(filename, newblknum);
-      write(blk, bb);
-      return blk;
-   }
-
-   /**
-    * Returns the number of blocks in the specified file.
-    * @param filename the name of the file
-    * @return the number of blocks in the file
-    */
-   public synchronized int size(String filename) {
-      try {
-         FileChannel fc = getFile(filename);
-         return (int)(fc.size() / BLOCK_SIZE);
-      }
-      catch (IOException e) {
-         throw new RuntimeException("cannot access " + filename);
-      }
-   }
-
-   /**
-    * Returns a boolean indicating whether the file manager
-    * had to create a new database directory.
-    * @return true if the database is new
-    */
-   public boolean isNew() {
-      return isNew;
-   }
-
-   /**
-    * Returns the file channel for the specified filename.
-    * The file channel is stored in a map keyed on the filename.
-    * If the file is not open, then it is opened and the file channel
-    * is added to the map.
-    * @param filename the specified filename
-    * @return the file channel associated with the open file.
-    * @throws IOException
-    */
-   private FileChannel getFile(String filename) throws IOException {
-      FileChannel fc = openFiles.get(filename);
-      if (fc == null) {
-         File dbTable = new File(dbDirectory, filename);
-         RandomAccessFile f = new RandomAccessFile(dbTable, "rws");
-         fc = f.getChannel();
-         openFiles.put(filename, fc);
-      }
-      return fc;
-   }
-}
diff --git a/src/simpledb/file/Page.class b/src/simpledb/file/Page.class
deleted file mode 100644
index 472e9b4..0000000
Binary files a/src/simpledb/file/Page.class and /dev/null differ
diff --git a/src/simpledb/file/Page.java b/src/simpledb/file/Page.java
deleted file mode 100644
index d0e3c3e..0000000
--- a/src/simpledb/file/Page.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package simpledb.file;
-
-import simpledb.server.SimpleDB;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-
-/**
- * The contents of a disk block in memory.
- * A page is treated as an array of BLOCK_SIZE bytes.
- * There are methods to get/set values into this array,
- * and to read/write the contents of this array to a disk block.
- * 
- * For an example of how to use Page and 
- * {@link Block} objects, 
- * consider the following code fragment.  
- * The first portion increments the integer at offset 792 of block 6 of file junk.  
- * The second portion stores the string "hello" at offset 20 of a page, 
- * and then appends it to a new block of the file.  
- * It then reads that block into another page 
- * and extracts the value "hello" into variable s.
- * <pre>
- * Page p1 = new Page();
- * Block blk = new Block("junk", 6);
- * p1.read(blk);
- * int n = p1.getInt(792);
- * p1.setInt(792, n+1);
- * p1.write(blk);
- *
- * Page p2 = new Page();
- * p2.setString(20, "hello");
- * blk = p2.append("junk");
- * Page p3 = new Page();
- * p3.read(blk);
- * String s = p3.getString(20);
- * </pre>
- * @author Edward Sciore
- */
-public class Page {
-   /**
-    * The number of bytes in a block.
-    * This value is set unreasonably low, so that it is easier
-    * to create and test databases having a lot of blocks.
-    * A more realistic value would be 4K.
-    */
-   public static final int BLOCK_SIZE = 400;
-   
-   /**
-    * The size of an integer in bytes.
-    * This value is almost certainly 4, but it is
-    * a good idea to encode this value as a constant. 
-    */
-   public static final int INT_SIZE = Integer.SIZE / Byte.SIZE;
-   
-   /**
-    * The maximum size, in bytes, of a string of length n.
-    * A string is represented as the encoding of its characters,
-    * preceded by an integer denoting the number of bytes in this encoding.
-    * If the JVM uses the US-ASCII encoding, then each char
-    * is stored in one byte, so a string of n characters
-    * has a size of 4+n bytes.
-    * @param n the size of the string
-    * @return the maximum number of bytes required to store a string of size n
-    */
-   public static final int STR_SIZE(int n) {
-      float bytesPerChar = Charset.defaultCharset().newEncoder().maxBytesPerChar();
-      return INT_SIZE + (n * (int)bytesPerChar);
-   }
-   
-   private ByteBuffer contents = ByteBuffer.allocateDirect(BLOCK_SIZE);
-   private FileMgr filemgr = SimpleDB.fileMgr();
-   
-   /**
-    * Creates a new page.  Although the constructor takes no arguments,
-    * it depends on a {@link FileMgr} object that it gets from the
-    * method {@link simpledb.server.SimpleDB#fileMgr()}.
-    * That object is created during system initialization.
-    * Thus this constructor cannot be called until either
-    * {@link simpledb.server.SimpleDB#init(String)} or
-    * {@link simpledb.server.SimpleDB#initFileMgr(String)} or
-    * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
-    * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)}
-    * is called first.
-    */
-   public Page() {}
-   
-   /**
-    * Populates the page with the contents of the specified disk block. 
-    * @param blk a reference to a disk block
-    */
-   public synchronized void read(Block blk) {
-      filemgr.read(blk, contents);
-   }
-   
-   /**
-    * Writes the contents of the page to the specified disk block.
-    * @param blk a reference to a disk block
-    */
-   public synchronized void write(Block blk) {
-      filemgr.write(blk, contents);
-   }
-   
-   /**
-    * Appends the contents of the page to the specified file.
-    * @param filename the name of the file
-    * @return the reference to the newly-created disk block
-    */
-   public synchronized Block append(String filename) {
-      return filemgr.append(filename, contents);
-   }
-   
-   /**
-    * Returns the integer value at a specified offset of the page.
-    * If an integer was not stored at that location, 
-    * the behavior of the method is unpredictable.
-    * @param offset the byte offset within the page
-    * @return the integer value at that offset
-    */
-   public synchronized int getInt(int offset) {
-      contents.position(offset);
-      return contents.getInt();
-   }
-   
-   /**
-    * Writes an integer to the specified offset on the page.
-    * @param offset the byte offset within the page
-    * @param val the integer to be written to the page
-    */
-   public synchronized void setInt(int offset, int val) {
-      contents.position(offset);
-      contents.putInt(val);
-   }
-   
-   /**
-    * Returns the string value at the specified offset of the page.
-    * If a string was not stored at that location,
-    * the behavior of the method is unpredictable.
-    * @param offset the byte offset within the page
-    * @return the string value at that offset
-    */
-   public synchronized String getString(int offset) {
-      contents.position(offset);
-      int len = contents.getInt();
-	  byte[] byteval = new byte[len];
-      contents.get(byteval);
-      return new String(byteval);
-   }
-   
-   /**
-    * Writes a string to the specified offset on the page.
-    * @param offset the byte offset within the page
-    * @param val the string to be written to the page
-    */
-   public synchronized void setString(int offset, String val) {
-      contents.position(offset);
-      byte[] byteval = val.getBytes();
-      contents.putInt(byteval.length);
-      contents.put(byteval);
-   }
-}
diff --git a/src/simpledb/index/Index.class b/src/simpledb/index/Index.class
deleted file mode 100644
index c6f6b63..0000000
Binary files a/src/simpledb/index/Index.class and /dev/null differ
diff --git a/src/simpledb/index/Index.java b/src/simpledb/index/Index.java
deleted file mode 100644
index 07d27c1..0000000
--- a/src/simpledb/index/Index.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package simpledb.index;
-
-import simpledb.record.RID;
-import simpledb.query.Constant;
-
-/**
- * This interface contains methods to traverse an index.
- * @author Edward Sciore
- *
- */
-public interface Index {
-   
-   /**
-    * Positions the index before the first record
-    * having the specified search key.
-    * @param searchkey the search key value.
-    */
-   public void    beforeFirst(Constant searchkey);
-   
-   /**
-    * Moves the index to the next record having the
-    * search key specified in the beforeFirst method. 
-    * Returns false if there are no more such index records.
-    * @return false if no other index records have the search key.
-    */
-   public boolean next();
-   
-   /**
-    * Returns the dataRID value stored in the current index record. 
-    * @return the dataRID stored in the current index record.
-    */
-   public RID     getDataRid();
-   
-   /**
-    * Inserts an index record having the specified
-    * dataval and dataRID values.
-    * @param dataval the dataval in the new index record.
-    * @param datarid the dataRID in the new index record.
-    */
-   public void    insert(Constant dataval, RID datarid);
-   
-   /**
-    * Deletes the index record having the specified
-    * dataval and dataRID values.
-    * @param dataval the dataval of the deleted index record
-    * @param datarid the dataRID of the deleted index record
-    */
-   public void    delete(Constant dataval, RID datarid);
-   
-   /**
-    * Closes the index.
-    */
-   public void    close();
-}
diff --git a/src/simpledb/index/btree/BTPageFormatter.class b/src/simpledb/index/btree/BTPageFormatter.class
deleted file mode 100644
index c3b2e77..0000000
Binary files a/src/simpledb/index/btree/BTPageFormatter.class and /dev/null differ
diff --git a/src/simpledb/index/btree/BTPageFormatter.java b/src/simpledb/index/btree/BTPageFormatter.java
deleted file mode 100644
index bf4fb2f..0000000
--- a/src/simpledb/index/btree/BTPageFormatter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package simpledb.index.btree;
-
-import static simpledb.file.Page.*;
-import static java.sql.Types.INTEGER;
-import simpledb.file.Page;
-import simpledb.buffer.PageFormatter;
-import simpledb.record.TableInfo;
-
-/**
- * An object that can format a page to look like an
- * empty B-tree block.
- * @author Edward Sciore
- */
-public class BTPageFormatter implements PageFormatter {
-   private TableInfo ti;
-   private int flag;
-   
-   /**
-    * Creates a formatter for a new page of the
-    * specified B-tree index.
-    * @param ti the index's metadata
-    * @param flag the page's initial flag value
-    */
-   public BTPageFormatter(TableInfo ti, int flag) {
-      this.ti = ti;
-      this.flag = flag;
-   }
-   
-   /** 
-    * Formats the page by initializing as many index-record slots
-    * as possible to have default values.
-    * Each integer field is given a value of 0, and
-    * each string field is given a value of "".
-    * The location that indicates the number of records
-    * in the page is also set to 0.
-    * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
-    */
-   public void format(Page page) {
-      page.setInt(0, flag);
-      page.setInt(INT_SIZE, 0);  // #records = 0
-      int recsize = ti.recordLength();
-      for (int pos=2*INT_SIZE; pos+recsize<=BLOCK_SIZE; pos += recsize)
-         makeDefaultRecord(page, pos);
-   }
-   
-   private void makeDefaultRecord(Page page, int pos) {
-      for (String fldname : ti.schema().fields()) {
-         int offset = ti.offset(fldname);
-         if (ti.schema().type(fldname) == INTEGER)
-            page.setInt(pos + offset, 0);
-         else
-            page.setString(pos + offset, "");
-      }
-   }
-}
diff --git a/src/simpledb/index/btree/BTreeDir.class b/src/simpledb/index/btree/BTreeDir.class
deleted file mode 100644
index 71a16e8..0000000
Binary files a/src/simpledb/index/btree/BTreeDir.class and /dev/null differ
diff --git a/src/simpledb/index/btree/BTreeDir.java b/src/simpledb/index/btree/BTreeDir.java
deleted file mode 100644
index 3e15606..0000000
--- a/src/simpledb/index/btree/BTreeDir.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package simpledb.index.btree;
-
-import simpledb.file.Block;
-import simpledb.tx.Transaction;
-import simpledb.record.TableInfo;
-import simpledb.query.Constant;
-
-/**
- * A B-tree directory block.
- * @author Edward Sciore
- */
-public class BTreeDir {
-   private TableInfo ti;
-   private Transaction tx;
-   private String filename;
-   private BTreePage contents;
-
-   /**
-    * Creates an object to hold the contents of the specified
-    * B-tree block.
-    * @param blk a reference to the specified B-tree block
-    * @param ti the metadata of the B-tree directory file
-    * @param tx the calling transaction
-    */
-   BTreeDir(Block blk, TableInfo ti, Transaction tx) {
-      this.ti = ti;
-      this.tx = tx;
-      filename = blk.fileName();
-      contents = new BTreePage(blk, ti, tx);
-   }
-
-   /**
-    * Closes the directory page.
-    */
-   public void close() {
-      contents.close();
-   }
-
-   /**
-    * Returns the block number of the B-tree leaf block
-    * that contains the specified search key.
-    * @param searchkey the search key value
-    * @return the block number of the leaf block containing that search key
-    */
-   public int search(Constant searchkey) {
-      Block childblk = findChildBlock(searchkey);
-      while (contents.getFlag() > 0) {
-         contents.close();
-         contents = new BTreePage(childblk, ti, tx);
-         childblk = findChildBlock(searchkey);
-      }
-      return childblk.number();
-   }
-
-   /**
-    * Creates a new root block for the B-tree.
-    * The new root will have two children:
-    * the old root, and the specified block.
-    * Since the root must always be in block 0 of the file,
-    * the contents of the old root will get transferred to a new block.
-    * @param e the directory entry to be added as a child of the new root
-    */
-   public void makeNewRoot(DirEntry e) {
-      Constant firstval = contents.getDataVal(0);
-      int level = contents.getFlag();
-      Block newblk = contents.split(0, level); //ie, transfer all the records
-      DirEntry oldroot = new DirEntry(firstval, newblk.number());
-      insertEntry(oldroot);
-      insertEntry(e);
-      contents.setFlag(level+1);
-   }
-
-   /**
-    * Inserts a new directory entry into the B-tree block.
-    * If the block is at level 0, then the entry is inserted there.
-    * Otherwise, the entry is inserted into the appropriate
-    * child node, and the return value is examined.
-    * A non-null return value indicates that the child node
-    * split, and so the returned entry is inserted into
-    * this block.
-    * If this block splits, then the method similarly returns
-    * the entry information of the new block to its caller;
-    * otherwise, the method returns null.
-    * @param e the directory entry to be inserted
-    * @return the directory entry of the newly-split block, if one exists; otherwise, null
-    */
-   public DirEntry insert(DirEntry e) {
-      if (contents.getFlag() == 0)
-         return insertEntry(e);
-      Block childblk = findChildBlock(e.dataVal());
-      BTreeDir child = new BTreeDir(childblk, ti, tx);
-      DirEntry myentry = child.insert(e);
-      child.close();
-      return (myentry != null) ? insertEntry(myentry) : null;
-   }
-
-   private DirEntry insertEntry(DirEntry e) {
-      int newslot = 1 + contents.findSlotBefore(e.dataVal());
-      contents.insertDir(newslot, e.dataVal(), e.blockNumber());
-      if (!contents.isFull())
-         return null;
-      // else page is full, so split it
-      int level = contents.getFlag();
-      int splitpos = contents.getNumRecs() / 2;
-      Constant splitval = contents.getDataVal(splitpos);
-      Block newblk = contents.split(splitpos, level);
-      return new DirEntry(splitval, newblk.number());
-   }
-
-   private Block findChildBlock(Constant searchkey) {
-      int slot = contents.findSlotBefore(searchkey);
-      if (contents.getDataVal(slot+1).equals(searchkey))
-         slot++;
-      int blknum = contents.getChildNum(slot);
-      return new Block(filename, blknum);
-   }
-}
diff --git a/src/simpledb/index/btree/BTreeIndex.class b/src/simpledb/index/btree/BTreeIndex.class
deleted file mode 100644
index 850c890..0000000
Binary files a/src/simpledb/index/btree/BTreeIndex.class and /dev/null differ
diff --git a/src/simpledb/index/btree/BTreeIndex.java b/src/simpledb/index/btree/BTreeIndex.java
deleted file mode 100644
index f11112f..0000000
--- a/src/simpledb/index/btree/BTreeIndex.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package simpledb.index.btree;
-
-import static java.sql.Types.INTEGER;
-import simpledb.file.Block;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/**
- * A B-tree implementation of the Index interface.
- * @author Edward Sciore
- */
-public class BTreeIndex implements Index {
-   private Transaction tx;
-   private TableInfo dirTi, leafTi;
-   private BTreeLeaf leaf = null;
-   private Block rootblk;
-
-   /**
-    * Opens a B-tree index for the specified index.
-    * The method determines the appropriate files
-    * for the leaf and directory records,
-    * creating them if they did not exist.
-    * @param idxname the name of the index
-    * @param leafsch the schema of the leaf index records
-    * @param tx the calling transaction
-    */
-   public BTreeIndex(String idxname, Schema leafsch, Transaction tx) {
-      this.tx = tx;
-      // deal with the leaves
-      String leaftbl = idxname + "leaf";
-      leafTi = new TableInfo(leaftbl, leafsch);
-      if (tx.size(leafTi.fileName()) == 0)
-         tx.append(leafTi.fileName(), new BTPageFormatter(leafTi, -1));
-
-      // deal with the directory
-      Schema dirsch = new Schema();
-      dirsch.add("block",   leafsch);
-      dirsch.add("dataval", leafsch);
-      String dirtbl = idxname + "dir";
-      dirTi = new TableInfo(dirtbl, dirsch);
-      rootblk = new Block(dirTi.fileName(), 0);
-      if (tx.size(dirTi.fileName()) == 0)
-         // create new root block
-         tx.append(dirTi.fileName(), new BTPageFormatter(dirTi, 0));
-      BTreePage page = new BTreePage(rootblk, dirTi, tx);
-      if (page.getNumRecs() == 0) {
-			// insert initial directory entry
-         int fldtype = dirsch.type("dataval");
-         Constant minval = (fldtype == INTEGER) ?
-            new IntConstant(Integer.MIN_VALUE) :
-            new StringConstant("");
-         page.insertDir(0, minval, 0);
-		}
-      page.close();
-   }
-
-   /**
-    * Traverses the directory to find the leaf block corresponding
-    * to the specified search key.
-    * The method then opens a page for that leaf block, and
-    * positions the page before the first record (if any)
-    * having that search key.
-    * The leaf page is kept open, for use by the methods next
-    * and getDataRid.
-    * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
-    */
-   public void beforeFirst(Constant searchkey) {
-      close();
-      BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
-      int blknum = root.search(searchkey);
-      root.close();
-      Block leafblk = new Block(leafTi.fileName(), blknum);
-      leaf = new BTreeLeaf(leafblk, leafTi, searchkey, tx);
-   }
-
-   /**
-    * Moves to the next leaf record having the
-    * previously-specified search key.
-    * Returns false if there are no more such leaf records.
-    * @see simpledb.index.Index#next()
-    */
-   public boolean next() {
-      return leaf.next();
-   }
-
-   /**
-    * Returns the dataRID value from the current leaf record.
-    * @see simpledb.index.Index#getDataRid()
-    */
-   public RID getDataRid() {
-      return leaf.getDataRid();
-   }
-
-   /**
-    * Inserts the specified record into the index.
-    * The method first traverses the directory to find
-    * the appropriate leaf page; then it inserts
-    * the record into the leaf.
-    * If the insertion causes the leaf to split, then
-    * the method calls insert on the root,
-    * passing it the directory entry of the new leaf page.
-    * If the root node splits, then makeNewRoot is called.
-    * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
-    */
-   public void insert(Constant dataval, RID datarid) {
-      beforeFirst(dataval);
-      DirEntry e = leaf.insert(datarid);
-      leaf.close();
-      if (e == null)
-         return;
-      BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
-      DirEntry e2 = root.insert(e);
-      if (e2 != null)
-         root.makeNewRoot(e2);
-      root.close();
-   }
-
-   /**
-    * Deletes the specified index record.
-    * The method first traverses the directory to find
-    * the leaf page containing that record; then it
-    * deletes the record from the page.
-    * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
-    */
-   public void delete(Constant dataval, RID datarid) {
-      beforeFirst(dataval);
-      leaf.delete(datarid);
-      leaf.close();
-   }
-
-   /**
-    * Closes the index by closing its open leaf page,
-    * if necessary.
-    * @see simpledb.index.Index#close()
-    */
-   public void close() {
-      if (leaf != null)
-         leaf.close();
-   }
-
-   /**
-    * Estimates the number of block accesses
-    * required to find all index records having
-    * a particular search key.
-    * @param numblocks the number of blocks in the B-tree directory
-    * @param rpb the number of index entries per block
-    * @return the estimated traversal cost
-    */
-   public static int searchCost(int numblocks, int rpb) {
-      return 1 + (int)(Math.log(numblocks) / Math.log(rpb));
-   }
-}
diff --git a/src/simpledb/index/btree/BTreeLeaf.class b/src/simpledb/index/btree/BTreeLeaf.class
deleted file mode 100644
index aeee0c2..0000000
Binary files a/src/simpledb/index/btree/BTreeLeaf.class and /dev/null differ
diff --git a/src/simpledb/index/btree/BTreeLeaf.java b/src/simpledb/index/btree/BTreeLeaf.java
deleted file mode 100644
index 5647bfc..0000000
--- a/src/simpledb/index/btree/BTreeLeaf.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package simpledb.index.btree;
-
-import simpledb.file.Block;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.Constant;
-
-/**
- * An object that holds the contents of a B-tree leaf block.
- * @author Edward Sciore
- */
-public class BTreeLeaf {
-   private TableInfo ti;
-   private Transaction tx;
-   private Constant searchkey;
-   private BTreePage contents;
-   private int currentslot;
-   
-   /**
-    * Opens a page to hold the specified leaf block.
-    * The page is positioned immediately before the first record
-    * having the specified search key (if any).
-    * @param blk a reference to the disk block
-    * @param ti the metadata of the B-tree leaf file
-    * @param searchkey the search key value
-    * @param tx the calling transaction
-    */
-   public BTreeLeaf(Block blk, TableInfo ti, Constant searchkey, Transaction tx) {
-      this.ti = ti;
-      this.tx = tx;
-      this.searchkey = searchkey;
-      contents = new BTreePage(blk, ti, tx);
-      currentslot = contents.findSlotBefore(searchkey);
-   }
-   
-   /**
-    * Closes the leaf page.
-    */
-   public void close() {
-      contents.close();
-   }
-   
-   /**
-    * Moves to the next leaf record having the 
-    * previously-specified search key.
-    * Returns false if there is no more such records.
-    * @return false if there are no more leaf records for the search key
-    */
-   public boolean next() {
-      currentslot++;
-      if (currentslot >= contents.getNumRecs()) 
-         return tryOverflow();
-      else if (contents.getDataVal(currentslot).equals(searchkey))
-         return true;
-      else 
-         return tryOverflow();
-   }
-   
-   /**
-    * Returns the dataRID value of the current leaf record.
-    * @return the dataRID of the current record
-    */
-   public RID getDataRid() {
-      return contents.getDataRid(currentslot);
-   }
-   
-   /**
-    * Deletes the leaf record having the specified dataRID
-    * @param datarid the dataRId whose record is to be deleted
-    */
-   public void delete(RID datarid) {
-      while(next())
-         if(getDataRid().equals(datarid)) {
-         contents.delete(currentslot);
-         return;
-      }
-   }
-   
-   /**
-    * Inserts a new leaf record having the specified dataRID
-    * and the previously-specified search key.
-    * If the record does not fit in the page, then 
-    * the page splits and the method returns the
-    * directory entry for the new page;
-    * otherwise, the method returns null.  
-    * If all of the records in the page have the same dataval,
-    * then the block does not split; instead, all but one of the
-    * records are placed into an overflow block.
-    * @param datarid the dataRID value of the new record
-    * @return the directory entry of the newly-split page, if one exists.
-    */
-   public DirEntry insert(RID datarid) {
-      currentslot++;
-      contents.insertLeaf(currentslot, searchkey, datarid);
-      if (!contents.isFull())
-         return null;
-      // else page is full, so split it
-      Constant firstkey = contents.getDataVal(0);
-      Constant lastkey  = contents.getDataVal(contents.getNumRecs()-1);
-      if (lastkey.equals(firstkey)) {
-         // create an overflow block to hold all but the first record
-         Block newblk = contents.split(1, contents.getFlag());
-         contents.setFlag(newblk.number());
-         return null;
-      }
-      else {
-         int splitpos = contents.getNumRecs() / 2;
-         Constant splitkey = contents.getDataVal(splitpos);
-         if (splitkey.equals(firstkey)) {
-            // move right, looking for the next key
-            while (contents.getDataVal(splitpos).equals(splitkey))
-               splitpos++;
-            splitkey = contents.getDataVal(splitpos);
-         }
-         else {
-            // move left, looking for first entry having that key
-            while (contents.getDataVal(splitpos-1).equals(splitkey))
-               splitpos--;
-         }
-         Block newblk = contents.split(splitpos, -1);
-         return new DirEntry(splitkey, newblk.number());
-      }
-   }
-   
-   private boolean tryOverflow() {
-      Constant firstkey = contents.getDataVal(0);
-      int flag = contents.getFlag();
-      if (!searchkey.equals(firstkey) || flag < 0)
-         return false;
-      contents.close();
-      Block nextblk = new Block(ti.fileName(), flag);
-      contents = new BTreePage(nextblk, ti, tx);
-      currentslot = 0;
-      return true;
-   }
-}
diff --git a/src/simpledb/index/btree/BTreePage.class b/src/simpledb/index/btree/BTreePage.class
deleted file mode 100644
index 6c1956c..0000000
Binary files a/src/simpledb/index/btree/BTreePage.class and /dev/null differ
diff --git a/src/simpledb/index/btree/BTreePage.java b/src/simpledb/index/btree/BTreePage.java
deleted file mode 100644
index be7c4e0..0000000
--- a/src/simpledb/index/btree/BTreePage.java
+++ /dev/null
@@ -1,261 +0,0 @@
-package simpledb.index.btree;
-
-import static java.sql.Types.INTEGER;
-import static simpledb.file.Page.*;
-import simpledb.file.Block;
-import simpledb.record.*;
-import simpledb.query.*;
-import simpledb.tx.Transaction;
-
-/**
- * B-tree directory and leaf pages have many commonalities:
- * in particular, their records are stored in sorted order, 
- * and pages split when full.
- * A BTreePage object contains this common functionality.
- * @author Edward Sciore
- */
-public class BTreePage {
-   private Block currentblk;
-   private TableInfo ti;
-   private Transaction tx;
-   private int slotsize;
-   
-   /**
-    * Opens a page for the specified B-tree block.
-    * @param currentblk a reference to the B-tree block
-    * @param ti the metadata for the particular B-tree file
-    * @param tx the calling transaction
-    */
-   public BTreePage(Block currentblk, TableInfo ti, Transaction tx) {
-      this.currentblk = currentblk;
-      this.ti = ti;
-      this.tx = tx;
-      slotsize = ti.recordLength();
-      tx.pin(currentblk);
-   }
-   
-   /**
-    * Calculates the position where the first record having
-    * the specified search key should be, then returns
-    * the position before it.
-    * @param searchkey the search key
-    * @return the position before where the search key goes
-    */
-   public int findSlotBefore(Constant searchkey) {
-      int slot = 0;
-      while (slot < getNumRecs() && getDataVal(slot).compareTo(searchkey) < 0)
-         slot++;
-      return slot-1;
-   }
-   
-   /**
-    * Closes the page by unpinning its buffer.
-    */
-   public void close() {
-      if (currentblk != null)
-         tx.unpin(currentblk);
-      currentblk = null;
-   }
-   
-   /**
-    * Returns true if the block is full.
-    * @return true if the block is full
-    */
-   public boolean isFull() {
-      return slotpos(getNumRecs()+1) >= BLOCK_SIZE;
-   }
-   
-   /**
-    * Splits the page at the specified position.
-    * A new page is created, and the records of the page
-    * starting at the split position are transferred to the new page.
-    * @param splitpos the split position
-    * @param flag the initial value of the flag field
-    * @return the reference to the new block
-    */
-   public Block split(int splitpos, int flag) {
-      Block newblk = appendNew(flag);
-      BTreePage newpage = new BTreePage(newblk, ti, tx);
-      transferRecs(splitpos, newpage);
-      newpage.setFlag(flag);
-      newpage.close();
-      return newblk;
-   }
-   
-   /**
-    * Returns the dataval of the record at the specified slot.
-    * @param slot the integer slot of an index record
-    * @return the dataval of the record at that slot
-    */
-   public Constant getDataVal(int slot) {
-      return getVal(slot, "dataval");
-   }
-   
-   /**
-    * Returns the value of the page's flag field
-    * @return the value of the page's flag field
-    */
-   public int getFlag() {
-      return tx.getInt(currentblk, 0);
-   }
-   
-   /**
-    * Sets the page's flag field to the specified value
-    * @param val the new value of the page flag
-    */
-   public void setFlag(int val) {
-      tx.setInt(currentblk, 0, val);
-   }
-   
-   /**
-    * Appends a new block to the end of the specified B-tree file,
-    * having the specified flag value.
-    * @param flag the initial value of the flag
-    * @return a reference to the newly-created block
-    */
-   public Block appendNew(int flag) {
-      return tx.append(ti.fileName(), new BTPageFormatter(ti, flag));
-   }
-   
-   // Methods called only by BTreeDir
-   
-   /**
-    * Returns the block number stored in the index record 
-    * at the specified slot.
-    * @param slot the slot of an index record
-    * @return the block number stored in that record
-    */
-   public int getChildNum(int slot) {
-      return getInt(slot, "block");
-   }
-   
-   /**
-    * Inserts a directory entry at the specified slot.
-    * @param slot the slot of an index record
-    * @param val the dataval to be stored
-    * @param blknum the block number to be stored
-    */
-   public void insertDir(int slot, Constant val, int blknum) {
-      insert(slot);
-      setVal(slot, "dataval", val);
-      setInt(slot, "block", blknum);
-   }
-   
-   // Methods called only by BTreeLeaf
-   
-   /**
-    * Returns the dataRID value stored in the specified leaf index record.
-    * @param slot the slot of the desired index record
-    * @return the dataRID value store at that slot
-    */
-   public RID getDataRid(int slot) {
-      return new RID(getInt(slot, "block"), getInt(slot, "id"));
-   }
-   
-   /**
-    * Inserts a leaf index record at the specified slot.
-    * @param slot the slot of the desired index record
-    * @param val the new dataval
-    * @param rid the new dataRID
-    */
-   public void insertLeaf(int slot, Constant val, RID rid) {
-      insert(slot);
-      setVal(slot, "dataval", val);
-      setInt(slot, "block", rid.blockNumber());
-      setInt(slot, "id", rid.id());
-   }
-   
-   /**
-    * Deletes the index record at the specified slot.
-    * @param slot the slot of the deleted index record
-    */
-   public void delete(int slot) {
-      for (int i=slot+1; i<getNumRecs(); i++)
-         copyRecord(i, i-1);
-      setNumRecs(getNumRecs()-1);
-      return;
-   }
-   
-   /**
-    * Returns the number of index records in this page.
-    * @return the number of index records in this page
-    */
-   public int getNumRecs() {
-      return tx.getInt(currentblk, INT_SIZE);
-   }
-   
-   // Private methods
-   
-   private int getInt(int slot, String fldname) {
-      int pos = fldpos(slot, fldname);
-      return tx.getInt(currentblk, pos);
-   }
-   
-   private String getString(int slot, String fldname) {
-      int pos = fldpos(slot, fldname);
-      return tx.getString(currentblk, pos);
-   }
-   
-   private Constant getVal(int slot, String fldname) {
-      int type = ti.schema().type(fldname);
-      if (type == INTEGER)
-         return new IntConstant(getInt(slot, fldname));
-      else
-         return new StringConstant(getString(slot, fldname));
-   }
-   
-   private void setInt(int slot, String fldname, int val) {
-      int pos = fldpos(slot, fldname);
-      tx.setInt(currentblk, pos, val);
-   }
-   
-   private void setString(int slot, String fldname, String val) {
-      int pos = fldpos(slot, fldname);
-      tx.setString(currentblk, pos, val);
-   }
-   
-   private void setVal(int slot, String fldname, Constant val) {
-      int type = ti.schema().type(fldname);
-      if (type == INTEGER)
-         setInt(slot, fldname, (Integer)val.asJavaVal());
-      else
-         setString(slot, fldname, (String)val.asJavaVal());
-   }
-   
-   private void setNumRecs(int n) {
-      tx.setInt(currentblk, INT_SIZE, n);
-   }
-   
-   private void insert(int slot) {
-      for (int i=getNumRecs(); i>slot; i--)
-         copyRecord(i-1, i);
-      setNumRecs(getNumRecs()+1);
-   }
-   
-   private void copyRecord(int from, int to) {
-      Schema sch = ti.schema();
-      for (String fldname : sch.fields())
-         setVal(to, fldname, getVal(from, fldname));
-   }
-   
-   private void transferRecs(int slot, BTreePage dest) {
-      int destslot = 0;
-      while (slot < getNumRecs()) {
-         dest.insert(destslot);
-         Schema sch = ti.schema();
-         for (String fldname : sch.fields())
-            dest.setVal(destslot, fldname, getVal(slot, fldname));
-         delete(slot);
-         destslot++;
-      }
-   }
-   
-   private int fldpos(int slot, String fldname) {
-      int offset = ti.offset(fldname);
-      return slotpos(slot) + offset;
-   }
-   
-   private int slotpos(int slot) {
-      return INT_SIZE + INT_SIZE + (slot * slotsize);
-   }
-}
diff --git a/src/simpledb/index/btree/DirEntry.class b/src/simpledb/index/btree/DirEntry.class
deleted file mode 100644
index e65f2ce..0000000
Binary files a/src/simpledb/index/btree/DirEntry.class and /dev/null differ
diff --git a/src/simpledb/index/btree/DirEntry.java b/src/simpledb/index/btree/DirEntry.java
deleted file mode 100644
index 006fcfe..0000000
--- a/src/simpledb/index/btree/DirEntry.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package simpledb.index.btree;
-
-import simpledb.query.Constant;
-
-/**
- * A directory entry has two components: the number of the child block,
- * and the dataval of the first record in that block.
- * @author Edward Sciore
- */
-public class DirEntry {
-   private Constant dataval;
-   private int blocknum;
-   
-   /**
-    * Creates a new entry for the specified dataval and block number.
-    * @param dataval the dataval
-    * @param blocknum the block number
-    */
-   public DirEntry(Constant dataval, int blocknum) {
-      this.dataval  = dataval;
-      this.blocknum = blocknum;
-   }
-   
-   /**
-    * Returns the dataval component of the entry
-    * @return the dataval component of the entry
-    */
-   public Constant dataVal() {
-      return dataval;
-   }
-   
-   /**
-    * Returns the block number component of the entry
-    * @return the block number component of the entry
-    */
-   public int blockNumber() {
-      return blocknum;
-   }
-}
-
diff --git a/src/simpledb/index/hash/HashIndex.class b/src/simpledb/index/hash/HashIndex.class
deleted file mode 100644
index 937acf6..0000000
Binary files a/src/simpledb/index/hash/HashIndex.class and /dev/null differ
diff --git a/src/simpledb/index/hash/HashIndex.java b/src/simpledb/index/hash/HashIndex.java
deleted file mode 100644
index 7804a3e..0000000
--- a/src/simpledb/index/hash/HashIndex.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package simpledb.index.hash;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/**
- * A static hash implementation of the Index interface.
- * A fixed number of buckets is allocated (currently, 100),
- * and each bucket is implemented as a file of index records.
- * @author Edward Sciore
- */
-public class HashIndex implements Index {
-	public static int NUM_BUCKETS = 100;
-	private String idxname;
-	private Schema sch;
-	private Transaction tx;
-	private Constant searchkey = null;
-	private TableScan ts = null;
-
-	/**
-	 * Opens a hash index for the specified index.
-	 * @param idxname the name of the index
-	 * @param sch the schema of the index records
-	 * @param tx the calling transaction
-	 */
-	public HashIndex(String idxname, Schema sch, Transaction tx) {
-		this.idxname = idxname;
-		this.sch = sch;
-		this.tx = tx;
-	}
-
-	/**
-	 * Positions the index before the first index record
-	 * having the specified search key.
-	 * The method hashes the search key to determine the bucket,
-	 * and then opens a table scan on the file
-	 * corresponding to the bucket.
-	 * The table scan for the previous bucket (if any) is closed.
-	 * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
-	 */
-	public void beforeFirst(Constant searchkey) {
-		close();
-		this.searchkey = searchkey;
-		int bucket = searchkey.hashCode() % NUM_BUCKETS;
-		String tblname = idxname + bucket;
-		TableInfo ti = new TableInfo(tblname, sch);
-		ts = new TableScan(ti, tx);
-	}
-
-	/**
-	 * Moves to the next record having the search key.
-	 * The method loops through the table scan for the bucket,
-	 * looking for a matching record, and returning false
-	 * if there are no more such records.
-	 * @see simpledb.index.Index#next()
-	 */
-	public boolean next() {
-		while (ts.next())
-			if (ts.getVal("dataval").equals(searchkey))
-				return true;
-		return false;
-	}
-
-	/**
-	 * Retrieves the dataRID from the current record
-	 * in the table scan for the bucket.
-	 * @see simpledb.index.Index#getDataRid()
-	 */
-	public RID getDataRid() {
-		int blknum = ts.getInt("block");
-		int id = ts.getInt("id");
-		return new RID(blknum, id);
-	}
-
-	/**
-	 * Inserts a new record into the table scan for the bucket.
-	 * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
-	 */
-	public void insert(Constant val, RID rid) {
-		beforeFirst(val);
-		ts.insert();
-		ts.setInt("block", rid.blockNumber());
-		ts.setInt("id", rid.id());
-		ts.setVal("dataval", val);
-	}
-
-	/**
-	 * Deletes the specified record from the table scan for
-	 * the bucket.  The method starts at the beginning of the
-	 * scan, and loops through the records until the
-	 * specified record is found.
-	 * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
-	 */
-	public void delete(Constant val, RID rid) {
-		beforeFirst(val);
-		while(next())
-			if (getDataRid().equals(rid)) {
-				ts.delete();
-				return;
-			}
-	}
-
-	/**
-	 * Closes the index by closing the current table scan.
-	 * @see simpledb.index.Index#close()
-	 */
-	public void close() {
-		if (ts != null)
-			ts.close();
-	}
-
-	/**
-	 * Returns the cost of searching an index file having the
-	 * specified number of blocks.
-	 * The method assumes that all buckets are about the
-	 * same size, and so the cost is simply the size of
-	 * the bucket.
-	 * @param numblocks the number of blocks of index records
-	 * @param rpb the number of records per block (not used here)
-	 * @return the cost of traversing the index
-	 */
-	public static int searchCost(int numblocks, int rpb){
-		return numblocks / HashIndex.NUM_BUCKETS;
-	}
-}
diff --git a/src/simpledb/index/planner/IndexUpdatePlanner.class b/src/simpledb/index/planner/IndexUpdatePlanner.class
deleted file mode 100644
index cb04e05..0000000
Binary files a/src/simpledb/index/planner/IndexUpdatePlanner.class and /dev/null differ
diff --git a/src/simpledb/index/planner/IndexUpdatePlanner.java b/src/simpledb/index/planner/IndexUpdatePlanner.java
deleted file mode 100644
index bf7e146..0000000
--- a/src/simpledb/index/planner/IndexUpdatePlanner.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package simpledb.index.planner;
-
-import java.util.Iterator;
-import java.util.Map;
-
-import simpledb.record.RID;
-import simpledb.server.SimpleDB;
-import simpledb.tx.Transaction;
-import simpledb.index.Index;
-import simpledb.metadata.IndexInfo;
-import simpledb.parse.*;
-import simpledb.planner.*;
-import simpledb.query.*;
-
-/**
- * A modification of the basic update planner.
- * It dispatches each update statement to the corresponding
- * index planner.
- * @author Edward Sciore
- */
-public class IndexUpdatePlanner implements UpdatePlanner {
-   
-   public int executeInsert(InsertData data, Transaction tx) {
-      String tblname = data.tableName();
-      Plan p = new TablePlan(tblname, tx);
-      
-      // first, insert the record
-      UpdateScan s = (UpdateScan) p.open();
-      s.insert();
-      RID rid = s.getRid();
-      
-      // then modify each field, inserting an index record if appropriate
-      Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
-      Iterator<Constant> valIter = data.vals().iterator();
-      for (String fldname : data.fields()) {
-         Constant val = valIter.next();
-         s.setVal(fldname, val);
-         
-         IndexInfo ii = indexes.get(fldname);
-         if (ii != null) {
-            Index idx = ii.open();
-            idx.insert(val, rid);
-            idx.close();
-         }
-      }
-      s.close();
-      return 1;
-   }
-   
-   public int executeDelete(DeleteData data, Transaction tx) {
-      String tblname = data.tableName();
-      Plan p = new TablePlan(tblname, tx);
-      p = new SelectPlan(p, data.pred());
-      Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
-      
-      UpdateScan s = (UpdateScan) p.open();
-      int count = 0;
-      while(s.next()) {
-         // first, delete the record's RID from every index
-         RID rid = s.getRid();
-         for (String fldname : indexes.keySet()) {
-            Constant val = s.getVal(fldname);
-            Index idx = indexes.get(fldname).open();
-            idx.delete(val, rid);
-            idx.close();
-         }
-         // then delete the record
-         s.delete();
-         count++;
-      }
-      s.close();
-      return count;
-   }
-   
-   public int executeModify(ModifyData data, Transaction tx) {
-      String tblname = data.tableName();
-      String fldname = data.targetField();
-      Plan p = new TablePlan(tblname, tx);
-      p = new SelectPlan(p, data.pred());
-      
-      IndexInfo ii = SimpleDB.mdMgr().getIndexInfo(tblname, tx).get(fldname);
-      Index idx = (ii == null) ? null : ii.open();
-      
-      UpdateScan s = (UpdateScan) p.open();
-      int count = 0;
-      while(s.next()) {
-         // first, update the record
-         Constant newval = data.newValue().evaluate(s);
-         Constant oldval = s.getVal(fldname);
-         s.setVal(data.targetField(), newval);
-         
-         // then update the appropriate index, if it exists
-         if (idx != null) {
-            RID rid = s.getRid();
-            idx.delete(oldval, rid);
-            idx.insert(newval, rid);
-         }
-         count++;
-      }
-      if (idx != null) idx.close();
-      s.close();
-      return count;
-   }
-   
-   public int executeCreateTable(CreateTableData data, Transaction tx) {
-      SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
-      return 0;
-   }
-   
-   public int executeCreateView(CreateViewData data, Transaction tx) {
-      SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
-      return 0;
-   }
-   
-   public int executeCreateIndex(CreateIndexData data, Transaction tx) {
-      SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
-      return 0;
-   }
-}
diff --git a/src/simpledb/index/query/IndexJoinPlan.class b/src/simpledb/index/query/IndexJoinPlan.class
deleted file mode 100644
index 9e4e515..0000000
Binary files a/src/simpledb/index/query/IndexJoinPlan.class and /dev/null differ
diff --git a/src/simpledb/index/query/IndexJoinPlan.java b/src/simpledb/index/query/IndexJoinPlan.java
deleted file mode 100644
index 50d76ce..0000000
--- a/src/simpledb/index/query/IndexJoinPlan.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package simpledb.index.query;
-
-import simpledb.tx.Transaction;
-import simpledb.record.Schema;
-import simpledb.metadata.IndexInfo;
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/** The Plan class corresponding to the <i>indexjoin</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class IndexJoinPlan implements Plan {
-   private Plan p1, p2;
-   private IndexInfo ii;
-   private String joinfield;
-   private Schema sch = new Schema();
-   
-   /**
-    * Implements the join operator,
-    * using the specified LHS and RHS plans.
-    * @param p1 the left-hand plan
-    * @param p2 the right-hand plan
-    * @param ii information about the right-hand index
-    * @param joinfield the left-hand field used for joining
-    * @param tx the calling transaction
-    */
-   public IndexJoinPlan(Plan p1, Plan p2, IndexInfo ii, String joinfield, Transaction tx) {
-      this.p1 = p1;
-      this.p2 = p2;
-      this.ii = ii;
-      this.joinfield = joinfield;
-      sch.addAll(p1.schema());
-      sch.addAll(p2.schema());
-   }
-   
-   /**
-    * Opens an indexjoin scan for this query
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s = p1.open();
-      // throws an exception if p2 is not a tableplan
-      TableScan ts = (TableScan) p2.open();
-      Index idx = ii.open();
-      return new IndexJoinScan(s, idx, joinfield, ts);
-   }
-   
-   /**
-    * Estimates the number of block accesses to compute the join.
-    * The formula is:
-    * <pre> B(indexjoin(p1,p2,idx)) = B(p1) + R(p1)*B(idx)
-    *       + R(indexjoin(p1,p2,idx) </pre>
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p1.blocksAccessed() 
-         + (p1.recordsOutput() * ii.blocksAccessed())
-         + recordsOutput();
-   }
-   
-   /**
-    * Estimates the number of output records in the join.
-    * The formula is:
-    * <pre> R(indexjoin(p1,p2,idx)) = R(p1)*R(idx) </pre>
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p1.recordsOutput() * ii.recordsOutput();
-   }
-   
-   /**
-    * Estimates the number of distinct values for the 
-    * specified field.  
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (p1.schema().hasField(fldname))
-         return p1.distinctValues(fldname);
-      else
-         return p2.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the index join.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return sch;
-   }
-}
diff --git a/src/simpledb/index/query/IndexJoinScan.class b/src/simpledb/index/query/IndexJoinScan.class
deleted file mode 100644
index ec13642..0000000
Binary files a/src/simpledb/index/query/IndexJoinScan.class and /dev/null differ
diff --git a/src/simpledb/index/query/IndexJoinScan.java b/src/simpledb/index/query/IndexJoinScan.java
deleted file mode 100644
index 7d04a66..0000000
--- a/src/simpledb/index/query/IndexJoinScan.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package simpledb.index.query;
-
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/**
- * The scan class corresponding to the indexjoin relational
- * algebra operator.
- * The code is very similar to that of ProductScan, 
- * which makes sense because an index join is essentially
- * the product of each LHS record with the matching RHS index records.
- * @author Edward Sciore
- */
-public class IndexJoinScan implements Scan {
-   private Scan s;
-   private TableScan ts;  // the data table
-   private Index idx;
-   private String joinfield;
-   
-   /**
-    * Creates an index join scan for the specified LHS scan and 
-    * RHS index.
-    * @param s the LHS scan
-    * @param idx the RHS index
-    * @param joinfield the LHS field used for joining
-    */
-   public IndexJoinScan(Scan s, Index idx, String joinfield, TableScan ts) {
-      this.s = s;
-      this.idx  = idx;
-      this.joinfield = joinfield;
-      this.ts = ts;
-      beforeFirst();
-   }
-   
-   /**
-    * Positions the scan before the first record.
-    * That is, the LHS scan will be positioned at its
-    * first record, and the index will be positioned
-    * before the first record for the join value.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      s.beforeFirst();
-      s.next();
-      resetIndex();
-   }
-   
-   /**
-    * Moves the scan to the next record.
-    * The method moves to the next index record, if possible.
-    * Otherwise, it moves to the next LHS record and the
-    * first index record.
-    * If there are no more LHS records, the method returns false.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      while (true) {
-         if (idx.next()) {
-            ts.moveToRid(idx.getDataRid());
-            return true;
-         }
-         if (!s.next())
-            return false;
-         resetIndex();
-      }
-   }
-   
-   /**
-    * Closes the scan by closing its LHS scan and its RHS index.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s.close();
-      idx.close();
-      ts.close();
-   }
-   
-   /**
-    * Returns the Constant value of the specified field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (ts.hasField(fldname))
-         return ts.getVal(fldname);
-      else
-         return s.getVal(fldname);
-   }
-   
-   /**
-    * Returns the integer value of the specified field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      if (ts.hasField(fldname))
-         return ts.getInt(fldname);
-      else  
-         return s.getInt(fldname);
-   }
-   
-   /**
-    * Returns the string value of the specified field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public String getString(String fldname) {
-      if (ts.hasField(fldname))
-         return ts.getString(fldname);
-      else
-         return s.getString(fldname);
-   }
-   
-   /** Returns true if the field is in the schema.
-     * @see simpledb.query.Scan#hasField(java.lang.String)
-     */
-   public boolean hasField(String fldname) {
-      return ts.hasField(fldname) || s.hasField(fldname);
-   }
-   
-   private void resetIndex() {
-      Constant searchkey = s.getVal(joinfield);
-      idx.beforeFirst(searchkey);
-   }
-}
diff --git a/src/simpledb/index/query/IndexSelectPlan.class b/src/simpledb/index/query/IndexSelectPlan.class
deleted file mode 100644
index 8ee81e8..0000000
Binary files a/src/simpledb/index/query/IndexSelectPlan.class and /dev/null differ
diff --git a/src/simpledb/index/query/IndexSelectPlan.java b/src/simpledb/index/query/IndexSelectPlan.java
deleted file mode 100644
index 505c184..0000000
--- a/src/simpledb/index/query/IndexSelectPlan.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package simpledb.index.query;
-
-import simpledb.tx.Transaction;
-import simpledb.record.Schema;
-import simpledb.metadata.IndexInfo;
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/** The Plan class corresponding to the <i>indexselect</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class IndexSelectPlan implements Plan {
-   private Plan p;
-   private IndexInfo ii;
-   private Constant val;
-   
-   /**
-    * Creates a new indexselect node in the query tree
-    * for the specified index and selection constant.
-    * @param p the input table
-    * @param ii information about the index
-    * @param val the selection constant
-    * @param tx the calling transaction 
-    */
-   public IndexSelectPlan(Plan p, IndexInfo ii, Constant val, Transaction tx) {
-      this.p = p;
-      this.ii = ii;
-      this.val = val;
-   }
-   
-   /** 
-    * Creates a new indexselect scan for this query
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      // throws an exception if p is not a tableplan.
-      TableScan ts = (TableScan) p.open();
-      Index idx = ii.open();
-      return new IndexSelectScan(idx, val, ts);
-   }
-   
-   /**
-    * Estimates the number of block accesses to compute the 
-    * index selection, which is the same as the 
-    * index traversal cost plus the number of matching data records.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return ii.blocksAccessed() + recordsOutput();
-   }
-   
-   /**
-    * Estimates the number of output records in the index selection,
-    * which is the same as the number of search key values
-    * for the index.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return ii.recordsOutput();
-   }
-   
-   /** 
-    * Returns the distinct values as defined by the index.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      return ii.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the data table.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return p.schema(); 
-   }
-}
diff --git a/src/simpledb/index/query/IndexSelectScan.class b/src/simpledb/index/query/IndexSelectScan.class
deleted file mode 100644
index 5aeb350..0000000
Binary files a/src/simpledb/index/query/IndexSelectScan.class and /dev/null differ
diff --git a/src/simpledb/index/query/IndexSelectScan.java b/src/simpledb/index/query/IndexSelectScan.java
deleted file mode 100644
index 9558546..0000000
--- a/src/simpledb/index/query/IndexSelectScan.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package simpledb.index.query;
-
-import simpledb.record.RID;
-import simpledb.query.*;
-import simpledb.index.Index;
-
-/**
- * The scan class corresponding to the select relational
- * algebra operator.
- * @author Edward Sciore
- */
-public class IndexSelectScan implements Scan {
-   private Index idx;
-   private Constant val;
-   private TableScan ts;
-   
-   /**
-    * Creates an index select scan for the specified
-    * index and selection constant.
-    * @param idx the index
-    * @param val the selection constant
-    */
-   public IndexSelectScan(Index idx, Constant val, TableScan ts) {
-      this.idx = idx;
-      this.val = val;
-      this.ts  = ts;
-      beforeFirst();
-   }
-   
-   /**
-    * Positions the scan before the first record,
-    * which in this case means positioning the index
-    * before the first instance of the selection constant.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      idx.beforeFirst(val);
-   }
-   
-   /**
-    * Moves to the next record, which in this case means
-    * moving the index to the next record satisfying the
-    * selection constant, and returning false if there are
-    * no more such index records.
-    * If there is a next record, the method moves the 
-    * tablescan to the corresponding data record.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      boolean ok = idx.next();
-      if (ok) {
-         RID rid = idx.getDataRid();
-         ts.moveToRid(rid);
-      }
-      return ok;
-   }
-   
-   /**
-    * Closes the scan by closing the index and the tablescan.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      idx.close();
-      ts.close();
-   }
-   
-   /**
-    * Returns the value of the field of the current data record.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      return ts.getVal(fldname);
-   }
-   
-   /**
-    * Returns the value of the field of the current data record.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return ts.getInt(fldname);
-   }
-   
-   /**
-    * Returns the value of the field of the current data record.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return ts.getString(fldname);
-   }
-   
-   /**
-    * Returns whether the data record has the specified field.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return ts.hasField(fldname);
-   }
-}
diff --git a/src/simpledb/log/BasicLogRecord.class b/src/simpledb/log/BasicLogRecord.class
deleted file mode 100644
index f3160fe..0000000
Binary files a/src/simpledb/log/BasicLogRecord.class and /dev/null differ
diff --git a/src/simpledb/log/BasicLogRecord.java b/src/simpledb/log/BasicLogRecord.java
deleted file mode 100644
index ac28793..0000000
--- a/src/simpledb/log/BasicLogRecord.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package simpledb.log;
-
-import static simpledb.file.Page.*;
-import simpledb.file.Page;
-
-/**
- * A class that provides the ability to read the values of
- * a log record.
- * The class has no idea what values are there.
- * Instead, the methods {@link #nextInt() nextInt}
- * and {@link #nextString() nextString} read the values 
- * sequentially.
- * Thus the client is responsible for knowing how many values
- * are in the log record, and what their types are.
- * @author Edward Sciore
- */
-public class BasicLogRecord {
-   private Page pg;
-   private int pos;
-   
-   /**
-    * A log record located at the specified position of the specified page.
-    * This constructor is called exclusively by
-    * {@link LogIterator#next()}.
-    * @param pg the page containing the log record
-    * @param pos the position of the log record 
-    */
-   public BasicLogRecord(Page pg, int pos) {
-      this.pg = pg;
-      this.pos = pos;
-   }
-   
-   /**
-    * Returns the next value of the current log record, 
-    * assuming it is an integer.
-    * @return the next value of the current log record
-    */
-   public int nextInt() {
-      int result = pg.getInt(pos);
-      pos += INT_SIZE;
-      return result;
-   }
-   
-   /**
-    * Returns the next value of the current log record, 
-    * assuming it is a string.
-    * @return the next value of the current log record
-    */
-   public String nextString() {
-      String result = pg.getString(pos);
-      pos += STR_SIZE(result.length());
-      return result;
-   }
-}
diff --git a/src/simpledb/log/LogIterator.class b/src/simpledb/log/LogIterator.class
deleted file mode 100644
index f329283..0000000
Binary files a/src/simpledb/log/LogIterator.class and /dev/null differ
diff --git a/src/simpledb/log/LogIterator.java b/src/simpledb/log/LogIterator.java
deleted file mode 100644
index 5207ec2..0000000
--- a/src/simpledb/log/LogIterator.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package simpledb.log;
-
-import static simpledb.file.Page.INT_SIZE;
-import simpledb.file.*;
-import java.util.Iterator;
-
-/**
- * A class that provides the ability to move through the
- * records of the log file in reverse order.
- * 
- * @author Edward Sciore
- */
-class LogIterator implements Iterator<BasicLogRecord> {
-   private Block blk;
-   private Page pg = new Page();
-   private int currentrec;
-   
-   /**
-    * Creates an iterator for the records in the log file,
-    * positioned after the last log record.
-    * This constructor is called exclusively by
-    * {@link LogMgr#iterator()}.
-    */
-   LogIterator(Block blk) {
-      this.blk = blk;
-      pg.read(blk);
-      currentrec = pg.getInt(LogMgr.LAST_POS);
-   }
-   
-   /**
-    * Determines if the current log record
-    * is the earliest record in the log file.
-    * @return true if there is an earlier record
-    */
-   public boolean hasNext() {
-      return currentrec>0 || blk.number()>0;
-   }
-   
-   /**
-    * Moves to the next log record in reverse order.
-    * If the current log record is the earliest in its block,
-    * then the method moves to the next oldest block,
-    * and returns the log record from there.
-    * @return the next earliest log record
-    */
-   public BasicLogRecord next() {
-      if (currentrec == 0) 
-         moveToNextBlock();
-      currentrec = pg.getInt(currentrec);
-      return new BasicLogRecord(pg, currentrec+INT_SIZE);
-   }
-   
-   public void remove() {
-      throw new UnsupportedOperationException();
-   }
-   
-   /**
-    * Moves to the next log block in reverse order,
-    * and positions it after the last record in that block.
-    */
-   private void moveToNextBlock() {
-      blk = new Block(blk.fileName(), blk.number()-1);
-      pg.read(blk);
-      currentrec = pg.getInt(LogMgr.LAST_POS);
-   }
-}
diff --git a/src/simpledb/log/LogMgr.class b/src/simpledb/log/LogMgr.class
deleted file mode 100644
index 99e1abc..0000000
Binary files a/src/simpledb/log/LogMgr.class and /dev/null differ
diff --git a/src/simpledb/log/LogMgr.java b/src/simpledb/log/LogMgr.java
deleted file mode 100644
index f4cf396..0000000
--- a/src/simpledb/log/LogMgr.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package simpledb.log;
-
-import simpledb.server.SimpleDB;
-import simpledb.file.*;
-import static simpledb.file.Page.*;
-import java.util.*;
-
-/**
- * The low-level log manager.
- * This log manager is responsible for writing log records
- * into a log file.
- * A log record can be any sequence of integer and string values.
- * The log manager does not understand the meaning of these
- * values, which are written and read by the
- * {@link simpledb.tx.recovery.RecoveryMgr recovery manager}.
- * @author Edward Sciore
- */
-public class LogMgr implements Iterable<BasicLogRecord> {
-   /**
-    * The location where the pointer to the last integer in the page is.
-    * A value of 0 means that the pointer is the first value in the page.
-    */
-   public static final int LAST_POS = 0;
-
-   private String logfile;
-   private Page mypage = new Page();
-   private Block currentblk;
-   private int currentpos;
-
-   /**
-    * Creates the manager for the specified log file.
-    * If the log file does not yet exist, it is created
-    * with an empty first block.
-    * This constructor depends on a {@link FileMgr} object
-    * that it gets from the method
-    * {@link simpledb.server.SimpleDB#fileMgr()}.
-    * That object is created during system initialization.
-    * Thus this constructor cannot be called until
-    * {@link simpledb.server.SimpleDB#initFileMgr(String)}
-    * is called first.
-    * @param logfile the name of the log file
-    */
-   public LogMgr(String logfile) {
-      this.logfile = logfile;
-      int logsize = SimpleDB.fileMgr().size(logfile);
-      if (logsize == 0)
-         appendNewBlock();
-      else {
-         currentblk = new Block(logfile, logsize-1);
-         mypage.read(currentblk);
-         currentpos = getLastRecordPosition() + INT_SIZE;
-      }
-   }
-
-   /**
-    * Ensures that the log records corresponding to the
-    * specified LSN has been written to disk.
-    * All earlier log records will also be written to disk.
-    * @param lsn the LSN of a log record
-    */
-   public void flush(int lsn) {
-      if (lsn >= currentLSN())
-         flush();
-   }
-
-   /**
-    * Returns an iterator for the log records,
-    * which will be returned in reverse order starting with the most recent.
-    * @see java.lang.Iterable#iterator()
-    */
-   public synchronized Iterator<BasicLogRecord> iterator() {
-      flush();
-      return new LogIterator(currentblk);
-   }
-
-   /**
-    * Appends a log record to the file.
-    * The record contains an arbitrary array of strings and integers.
-    * The method also writes an integer to the end of each log record whose value
-    * is the offset of the corresponding integer for the previous log record.
-    * These integers allow log records to be read in reverse order.
-    * @param rec the list of values
-    * @return the LSN of the final value
-    */
-   public synchronized int append(Object[] rec) {
-      int recsize = INT_SIZE;  // 4 bytes for the integer that points to the previous log record
-      for (Object obj : rec)
-         recsize += size(obj);
-      if (currentpos + recsize >= BLOCK_SIZE){ // the log record doesn't fit,
-         flush();        // so move to the next block.
-         appendNewBlock();
-      }
-      for (Object obj : rec)
-         appendVal(obj);
-      finalizeRecord();
-      return currentLSN();
-   }
-
-   /**
-    * Adds the specified value to the page at the position denoted by
-    * currentpos.  Then increments currentpos by the size of the value.
-    * @param val the integer or string to be added to the page
-    */
-   private void appendVal(Object val) {
-      if (val instanceof String)
-         mypage.setString(currentpos, (String)val);
-      else
-         mypage.setInt(currentpos, (Integer)val);
-      currentpos += size(val);
-   }
-
-   /**
-    * Calculates the size of the specified integer or string.
-    * @param val the value
-    * @return the size of the value, in bytes
-    */
-   private int size(Object val) {
-      if (val instanceof String) {
-         String sval = (String) val;
-         return STR_SIZE(sval.length());
-      }
-      else
-         return INT_SIZE;
-   }
-
-   /**
-    * Returns the LSN of the most recent log record.
-    * As implemented, the LSN is the block number where the record is stored.
-    * Thus every log record in a block has the same LSN.
-    * @return the LSN of the most recent log record
-    */
-   private int currentLSN() {
-      return currentblk.number();
-   }
-
-   /**
-    * Writes the current page to the log file.
-    */
-   private void flush() {
-      mypage.write(currentblk);
-   }
-
-   /**
-    * Clear the current page, and append it to the log file.
-    */
-   private void appendNewBlock() {
-      setLastRecordPosition(0);
-      currentpos = INT_SIZE;
-      currentblk = mypage.append(logfile);
-   }
-
-   /**
-    * Sets up a circular chain of pointers to the records in the page.
-    * There is an integer added to the end of each log record
-    * whose value is the offset of the previous log record.
-    * The first four bytes of the page contain an integer whose value
-    * is the offset of the integer for the last log record in the page.
-    */
-   private void finalizeRecord() {
-      mypage.setInt(currentpos, getLastRecordPosition());
-      setLastRecordPosition(currentpos);
-      currentpos += INT_SIZE;
-   }
-
-   private int getLastRecordPosition() {
-      return mypage.getInt(LAST_POS);
-   }
-
-   private void setLastRecordPosition(int pos) {
-      mypage.setInt(LAST_POS, pos);
-   }
-}
diff --git a/src/simpledb/materialize/AggregationFn.class b/src/simpledb/materialize/AggregationFn.class
deleted file mode 100644
index 5fb2ab8..0000000
Binary files a/src/simpledb/materialize/AggregationFn.class and /dev/null differ
diff --git a/src/simpledb/materialize/AggregationFn.java b/src/simpledb/materialize/AggregationFn.java
deleted file mode 100644
index 051f193..0000000
--- a/src/simpledb/materialize/AggregationFn.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-
-/**
- * The interface implemented by aggregation functions.
- * Aggregation functions are used by the <i>groupby</i> operator.
- * @author Edward Sciore
- */
-public interface AggregationFn {
-   
-   /**
-    * Uses the current record of the specified scan
-    * to be the first record in the group.
-    * @param s the scan to aggregate over.
-    */
-   void processFirst(Scan s);
-   
-   /**
-    * Uses the current record of the specified scan
-    * to be the next record in the group.
-    * @param s the scan to aggregate over.
-    */
-   void processNext(Scan s);
-   
-   /**
-    * Returns the name of the new aggregation field.
-    * @return the name of the new aggregation field
-    */
-   String fieldName();
-   
-   /**
-    * Returns the computed aggregation value.
-    * @return the computed aggregation value
-    */
-   Constant value();
-}
diff --git a/src/simpledb/materialize/CountFn.class b/src/simpledb/materialize/CountFn.class
deleted file mode 100644
index 5246ec5..0000000
Binary files a/src/simpledb/materialize/CountFn.class and /dev/null differ
diff --git a/src/simpledb/materialize/CountFn.java b/src/simpledb/materialize/CountFn.java
deleted file mode 100644
index 1dfd8ee..0000000
--- a/src/simpledb/materialize/CountFn.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-
-/**
- * The <i>count</i> aggregation function.
- * @author Edward Sciore
- */
-public class CountFn implements AggregationFn {
-   private String fldname;
-   private int count;
-   
-   /**
-    * Creates a count aggregation function for the specified field.
-    * @param fldname the name of the aggregated field
-    */
-   public CountFn(String fldname) {
-      this.fldname = fldname;
-   }
-   
-   /**
-    * Starts a new count.
-    * Since SimpleDB does not support null values,
-    * every record will be counted,
-    * regardless of the field.
-    * The current count is thus set to 1.
-    * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
-    */
-   public void processFirst(Scan s) {
-      count = 1;
-   }
-   
-   /**
-    * Since SimpleDB does not support null values,
-    * this method always increments the count,
-    * regardless of the field.
-    * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
-    */
-   public void processNext(Scan s) {
-      count++;
-   }
-   
-   /**
-    * Returns the field's name, prepended by "countof".
-    * @see simpledb.materialize.AggregationFn#fieldName()
-    */
-   public String fieldName() {
-      return "countof" + fldname;
-   }
-   
-   /**
-    * Returns the current count.
-    * @see simpledb.materialize.AggregationFn#value()
-    */
-   public Constant value() {
-      return new IntConstant(count);
-   }
-}
diff --git a/src/simpledb/materialize/GroupByPlan.class b/src/simpledb/materialize/GroupByPlan.class
deleted file mode 100644
index d5df929..0000000
Binary files a/src/simpledb/materialize/GroupByPlan.class and /dev/null differ
diff --git a/src/simpledb/materialize/GroupByPlan.java b/src/simpledb/materialize/GroupByPlan.java
deleted file mode 100644
index d0ff3bf..0000000
--- a/src/simpledb/materialize/GroupByPlan.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.tx.Transaction;
-import simpledb.record.Schema;
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * The Plan class for the <i>groupby</i> operator.
- * @author Edward Sciore
- */
-public class GroupByPlan implements Plan {
-   private Plan p;
-   private Collection<String> groupfields;
-   private Collection<AggregationFn> aggfns;
-   private Schema sch = new Schema();
-   
-   /**
-    * Creates a groupby plan for the underlying query.
-    * The grouping is determined by the specified
-    * collection of group fields,
-    * and the aggregation is computed by the
-    * specified collection of aggregation functions.
-    * @param p a plan for the underlying query
-    * @param groupfields the group fields
-    * @param aggfns the aggregation functions
-    * @param tx the calling transaction
-    */
-   public GroupByPlan(Plan p, Collection<String> groupfields, Collection<AggregationFn> aggfns, Transaction tx) {
-      List<String> grouplist = new ArrayList<String>();
-      grouplist.addAll(groupfields);
-      this.p = new SortPlan(p, grouplist, tx);
-      this.groupfields = groupfields;
-      this.aggfns = aggfns;
-      for (String fldname : groupfields)
-         sch.add(fldname, p.schema());
-      for (AggregationFn fn : aggfns)
-         sch.addIntField(fn.fieldName());
-   }
-   
-   /**
-    * This method opens a sort plan for the specified plan.
-    * The sort plan ensures that the underlying records
-    * will be appropriately grouped.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s = p.open();
-      return new GroupByScan(s, groupfields, aggfns);
-   }
-   
-   /**
-    * Returns the number of blocks required to
-    * compute the aggregation,
-    * which is one pass through the sorted table.
-    * It does <i>not</i> include the one-time cost
-    * of materializing and sorting the records.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p.blocksAccessed();
-   }
-   
-   /**
-    * Returns the number of groups.  Assuming equal distribution,
-    * this is the product of the distinct values
-    * for each grouping field.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      int numgroups = 1;
-      for (String fldname : groupfields)
-         numgroups *= p.distinctValues(fldname);
-      return numgroups;
-   }
-   
-   /**
-    * Returns the number of distinct values for the
-    * specified field.  If the field is a grouping field,
-    * then the number of distinct values is the same
-    * as in the underlying query.
-    * If the field is an aggregate field, then we
-    * assume that all values are distinct.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (p.schema().hasField(fldname))
-         return p.distinctValues(fldname);
-      else
-         return recordsOutput();
-   }
-   
-   /**
-    * Returns the schema of the output table.
-    * The schema consists of the group fields,
-    * plus one field for each aggregation function.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return sch;
-   }
-}
diff --git a/src/simpledb/materialize/GroupByScan.class b/src/simpledb/materialize/GroupByScan.class
deleted file mode 100644
index 4930281..0000000
Binary files a/src/simpledb/materialize/GroupByScan.class and /dev/null differ
diff --git a/src/simpledb/materialize/GroupByScan.java b/src/simpledb/materialize/GroupByScan.java
deleted file mode 100644
index 1efd539..0000000
--- a/src/simpledb/materialize/GroupByScan.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * The Scan class for the <i>groupby</i> operator.
- * @author Edward Sciore
- */
-public class GroupByScan implements Scan {
-   private Scan s;
-   private Collection<String> groupfields;
-   private Collection<AggregationFn> aggfns;
-   private GroupValue groupval;
-   private boolean moregroups;
-   
-   /**
-    * Creates a groupby scan, given a grouped table scan.
-    * @param s the grouped scan
-    * @param groupfields the group fields
-    * @param aggfns the aggregation functions
-    */
-   public GroupByScan(Scan s, Collection<String> groupfields, Collection<AggregationFn> aggfns) {
-      this.s = s;
-      this.groupfields = groupfields;
-      this.aggfns = aggfns;
-      beforeFirst();
-   }
-   
-   /**
-    * Positions the scan before the first group.
-    * Internally, the underlying scan is always 
-    * positioned at the first record of a group, which 
-    * means that this method moves to the
-    * first underlying record.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      s.beforeFirst();
-      moregroups = s.next();
-   }
-   
-   /**
-    * Moves to the next group.
-    * The key of the group is determined by the 
-    * group values at the current record.
-    * The method repeatedly reads underlying records until
-    * it encounters a record having a different key.
-    * The aggregation functions are called for each record
-    * in the group. 
-    * The values of the grouping fields for the group are saved.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      if (!moregroups)
-         return false;
-      for (AggregationFn fn : aggfns)
-         fn.processFirst(s);
-      groupval = new GroupValue(s, groupfields);
-      while(moregroups = s.next()) {
-         GroupValue gv = new GroupValue(s, groupfields);
-         if (!groupval.equals(gv))
-            break;
-         for (AggregationFn fn : aggfns)
-            fn.processNext(s);
-      }
-      return true;
-   }
-   
-   /**
-    * Closes the scan by closing the underlying scan.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s.close();
-   }
-   
-   /**
-    * Gets the Constant value of the specified field.
-    * If the field is a group field, then its value can
-    * be obtained from the saved group value.
-    * Otherwise, the value is obtained from the
-    * appropriate aggregation function.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (groupfields.contains(fldname))
-         return groupval.getVal(fldname);
-      for (AggregationFn fn : aggfns)
-         if (fn.fieldName().equals(fldname))
-         return fn.value();
-      throw new RuntimeException("field " + fldname + " not found.");
-   }
-   
-   /**
-    * Gets the integer value of the specified field.
-    * If the field is a group field, then its value can
-    * be obtained from the saved group value.
-    * Otherwise, the value is obtained from the
-    * appropriate aggregation function.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return (Integer)getVal(fldname).asJavaVal();
-   }
-   
-   /**
-    * Gets the string value of the specified field.
-    * If the field is a group field, then its value can
-    * be obtained from the saved group value.
-    * Otherwise, the value is obtained from the
-    * appropriate aggregation function.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return (String)getVal(fldname).asJavaVal();
-   }
-   
-   /* Returns true if the specified field is either a 
-    * grouping field or created by an aggregation function.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      if (groupfields.contains(fldname))
-         return true;
-      for (AggregationFn fn : aggfns)
-         if (fn.fieldName().equals(fldname))
-         return true;
-      return false;
-   }
-}
-
diff --git a/src/simpledb/materialize/GroupValue.class b/src/simpledb/materialize/GroupValue.class
deleted file mode 100644
index 9711208..0000000
Binary files a/src/simpledb/materialize/GroupValue.class and /dev/null differ
diff --git a/src/simpledb/materialize/GroupValue.java b/src/simpledb/materialize/GroupValue.java
deleted file mode 100644
index d3a9a98..0000000
--- a/src/simpledb/materialize/GroupValue.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-
-import java.util.*;
-
-/**
- * An object that holds the values of the grouping fields
- * for the current record of a scan.
- * @author Edward Sciore
- */
-public class GroupValue {
-   private Map<String,Constant> vals;
-   
-   /**
-    * Creates a new group value, given the specified scan
-    * and list of fields.
-    * The values in the current record of each field are 
-    * stored.
-    * @param s a scan
-    * @param fields the list of fields
-    */
-   public GroupValue(Scan s, Collection<String> fields) {
-      vals = new HashMap<String,Constant>();
-      for (String fldname : fields)
-         vals.put(fldname, s.getVal(fldname));
-   }
-   
-   /**
-    * Returns the Constant value of the specified field in the group.
-    * @param fldname the name of a field
-    * @return the value of the field in the group
-    */
-   public Constant getVal(String fldname) {
-      return vals.get(fldname);
-   }
-   
-   /** 
-    * Two GroupValue objects are equal if they have the same values
-    * for their grouping fields. 
-    * @see java.lang.Object#equals(java.lang.Object)
-    */
-   public boolean equals(Object obj) {
-      GroupValue gv = (GroupValue) obj;
-      for (String fldname : vals.keySet()) {
-         Constant v1 = vals.get(fldname);
-         Constant v2 = gv.getVal(fldname);
-         if (!v1.equals(v2))
-            return false;
-      }
-      return true;
-   }
-   
-   /**
-    * The hashcode of a GroupValue object is the sum of the
-    * hashcodes of its field values. 
-    * @see java.lang.Object#hashCode()
-    */
-   public int hashCode() {
-      int hashval = 0;
-      for (Constant c: vals.values())
-         hashval += c.hashCode();
-      return hashval;
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/materialize/MaterializePlan.class b/src/simpledb/materialize/MaterializePlan.class
deleted file mode 100644
index 003ab1c..0000000
Binary files a/src/simpledb/materialize/MaterializePlan.class and /dev/null differ
diff --git a/src/simpledb/materialize/MaterializePlan.java b/src/simpledb/materialize/MaterializePlan.java
deleted file mode 100644
index 5825af1..0000000
--- a/src/simpledb/materialize/MaterializePlan.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package simpledb.materialize;
-
-import static simpledb.file.Page.BLOCK_SIZE;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-
-/**
- * The Plan class for the <i>materialize</i> operator.
- * @author Edward Sciore
- */
-public class MaterializePlan implements Plan {
-   private Plan srcplan;
-   private Transaction tx;
-   
-   /**
-    * Creates a materialize plan for the specified query.
-    * @param srcplan the plan of the underlying query
-    * @param tx the calling transaction
-    */
-   public MaterializePlan(Plan srcplan, Transaction tx) {
-      this.srcplan = srcplan;
-      this.tx = tx;
-   }
-   
-   /**
-    * This method loops through the underlying query,
-    * copying its output records into a temporary table.
-    * It then returns a table scan for that table.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Schema sch = srcplan.schema();
-      TempTable temp = new TempTable(sch, tx);
-      Scan src = srcplan.open();
-      UpdateScan dest = temp.open();
-      while (src.next()) {
-         dest.insert();
-         for (String fldname : sch.fields())
-            dest.setVal(fldname, src.getVal(fldname));
-      }
-      src.close();
-      dest.beforeFirst();
-      return dest;
-   }
-   
-   /**
-    * Returns the estimated number of blocks in the 
-    * materialized table.
-    * It does <i>not</i> include the one-time cost
-    * of materializing the records.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      // create a dummy TableInfo object to calculate record length
-      TableInfo ti = new TableInfo("", srcplan.schema());
-      double rpb = (double) (BLOCK_SIZE / ti.recordLength());
-      return (int) Math.ceil(srcplan.recordsOutput() / rpb);
-   }
-   
-   /**
-    * Returns the number of records in the materialized table,
-    * which is the same as in the underlying plan.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return srcplan.recordsOutput();
-   }
-   
-   /**
-    * Returns the number of distinct field values,
-    * which is the same as in the underlying plan.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      return srcplan.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the materialized table,
-    * which is the same as in the underlying plan.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return srcplan.schema();
-   }
-}
diff --git a/src/simpledb/materialize/MaxFn.class b/src/simpledb/materialize/MaxFn.class
deleted file mode 100644
index f52298d..0000000
Binary files a/src/simpledb/materialize/MaxFn.class and /dev/null differ
diff --git a/src/simpledb/materialize/MaxFn.java b/src/simpledb/materialize/MaxFn.java
deleted file mode 100644
index f1e443c..0000000
--- a/src/simpledb/materialize/MaxFn.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-
-/**
- * The <i>max</i> aggregation function.
- * @author Edward Sciore
- */
-public class MaxFn implements AggregationFn {
-   private String fldname;
-   private Constant val;
-   
-   /**
-    * Creates a max aggregation function for the specified field.
-    * @param fldname the name of the aggregated field
-    */
-   public MaxFn(String fldname) {
-      this.fldname = fldname;
-   }
-   
-   /**
-    * Starts a new maximum to be the 
-    * field value in the current record.
-    * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
-    */
-   public void processFirst(Scan s) {
-      val = s.getVal(fldname);
-   }
-   
-   /**
-    * Replaces the current maximum by the field value
-    * in the current record, if it is higher.
-    * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
-    */
-   public void processNext(Scan s) {
-      Constant newval = s.getVal(fldname);
-      if (newval.compareTo(val) > 0)
-         val = newval;
-   }
-   
-   /**
-    * Returns the field's name, prepended by "maxof".
-    * @see simpledb.materialize.AggregationFn#fieldName()
-    */
-   public String fieldName() {
-      return "maxof" + fldname;
-   }
-   
-   /**
-    * Returns the current maximum.
-    * @see simpledb.materialize.AggregationFn#value()
-    */
-   public Constant value() {
-      return val;
-   }
-}
diff --git a/src/simpledb/materialize/MergeJoinPlan.class b/src/simpledb/materialize/MergeJoinPlan.class
deleted file mode 100644
index 9800061..0000000
Binary files a/src/simpledb/materialize/MergeJoinPlan.class and /dev/null differ
diff --git a/src/simpledb/materialize/MergeJoinPlan.java b/src/simpledb/materialize/MergeJoinPlan.java
deleted file mode 100644
index 1ea69d4..0000000
--- a/src/simpledb/materialize/MergeJoinPlan.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * The Plan class for the <i>mergejoin</i> operator.
- * @author Edward Sciore
- */
-public class MergeJoinPlan implements Plan {
-   private Plan p1, p2;
-   private String fldname1, fldname2;
-   private Schema sch = new Schema();
-   
-   /**
-    * Creates a mergejoin plan for the two specified queries.
-    * The RHS must be materialized after it is sorted, 
-    * in order to deal with possible duplicates.
-    * @param p1 the LHS query plan
-    * @param p2 the RHS query plan
-    * @param fldname1 the LHS join field
-    * @param fldname2 the RHS join field
-    * @param tx the calling transaction
-    */
-   public MergeJoinPlan(Plan p1, Plan p2, String fldname1, String fldname2, Transaction tx) {
-      this.fldname1 = fldname1;
-      List<String> sortlist1 = Arrays.asList(fldname1);
-      this.p1 = new SortPlan(p1, sortlist1, tx);
-      
-      this.fldname2 = fldname2;
-      List<String> sortlist2 = Arrays.asList(fldname2);
-      this.p2 = new SortPlan(p2, sortlist2, tx);
-      
-      sch.addAll(p1.schema());
-      sch.addAll(p2.schema());
-   }
-   
-   /** The method first sorts its two underlying scans
-     * on their join field. It then returns a mergejoin scan
-     * of the two sorted table scans.
-     * @see simpledb.query.Plan#open()
-     */
-   public Scan open() {
-      Scan s1 = p1.open();
-      SortScan s2 = (SortScan) p2.open();
-      return new MergeJoinScan(s1, s2, fldname1, fldname2);
-   }
-   
-   /**
-    * Returns the number of block acceses required to
-    * mergejoin the sorted tables.
-    * Since a mergejoin can be preformed with a single
-    * pass through each table, the method returns
-    * the sum of the block accesses of the 
-    * materialized sorted tables.
-    * It does <i>not</i> include the one-time cost
-    * of materializing and sorting the records.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p1.blocksAccessed() + p2.blocksAccessed();
-   }
-   
-   /**
-    * Returns the number of records in the join.
-    * Assuming uniform distribution, the formula is:
-    * <pre> R(join(p1,p2)) = R(p1)*R(p2)/max{V(p1,F1),V(p2,F2)}</pre>
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      int maxvals = Math.max(p1.distinctValues(fldname1),
-                             p2.distinctValues(fldname2));
-      return (p1.recordsOutput() * p2.recordsOutput()) / maxvals;
-   }
-   
-   /**
-    * Estimates the distinct number of field values in the join.
-    * Since the join does not increase or decrease field values,
-    * the estimate is the same as in the appropriate underlying query.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (p1.schema().hasField(fldname))
-         return p1.distinctValues(fldname);
-      else
-         return p2.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the join,
-    * which is the union of the schemas of the underlying queries.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return sch;
-   }
-}
-
diff --git a/src/simpledb/materialize/MergeJoinScan.class b/src/simpledb/materialize/MergeJoinScan.class
deleted file mode 100644
index e168641..0000000
Binary files a/src/simpledb/materialize/MergeJoinScan.class and /dev/null differ
diff --git a/src/simpledb/materialize/MergeJoinScan.java b/src/simpledb/materialize/MergeJoinScan.java
deleted file mode 100644
index bc04e9b..0000000
--- a/src/simpledb/materialize/MergeJoinScan.java
+++ /dev/null
@@ -1,138 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-
-/**
- * The Scan class for the <i>mergejoin</i> operator.
- * @author Edward Sciore
- */
-public class MergeJoinScan implements Scan {
-   private Scan s1;
-   private SortScan s2;
-   private String fldname1, fldname2;
-   private Constant joinval = null;
-   
-   /**
-    * Creates a mergejoin scan for the two underlying sorted scans.
-    * @param s1 the LHS sorted scan
-    * @param s2 the RHS sorted scan
-    * @param fldname1 the LHS join field
-    * @param fldname2 the RHS join field
-    */
-   public MergeJoinScan(Scan s1, SortScan s2, String fldname1, String fldname2) {
-      this.s1 = s1;
-      this.s2 = s2;
-      this.fldname1 = fldname1;
-      this.fldname2 = fldname2;
-      beforeFirst();
-   }
-   
-   /**
-    * Positions the scan before the first record,
-    * by positioning each underlying scan before
-    * their first records.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      s1.beforeFirst();
-      s2.beforeFirst();
-   }
-   
-   /**
-    * Closes the scan by closing the two underlying scans.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s1.close();
-      s2.close();
-   }
-   
-   /**
-    * Moves to the next record.  This is where the action is.
-    * <P>
-    * If the next RHS record has the same join value,
-    * then move to it.
-    * Otherwise, if the next LHS record has the same join value,
-    * then reposition the RHS scan back to the first record
-    * having that join value.
-    * Otherwise, repeatedly move the scan having the smallest
-    * value until a common join value is found.
-    * When one of the scans runs out of records, return false.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      boolean hasmore2 = s2.next();
-      if (hasmore2 && s2.getVal(fldname2).equals(joinval))
-         return true;
-      
-      boolean hasmore1 = s1.next();
-      if (hasmore1 && s1.getVal(fldname1).equals(joinval)) {
-         s2.restorePosition();
-         return true;
-      }
-      
-      while (hasmore1 && hasmore2) {
-         Constant v1 = s1.getVal(fldname1);
-         Constant v2 = s2.getVal(fldname2);
-         if (v1.compareTo(v2) < 0)
-            hasmore1 = s1.next();
-         else if (v1.compareTo(v2) > 0)
-            hasmore2 = s2.next();
-         else {
-            s2.savePosition();
-            joinval  = s2.getVal(fldname2);
-            return true;
-         }
-      }
-      return false;
-   }
-   
-   /** 
-    * Returns the value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getVal(fldname);
-      else
-         return s2.getVal(fldname);
-   }
-   
-   /** 
-    * Returns the integer value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getInt(fldname);
-      else
-         return s2.getInt(fldname);
-   }
-   
-   /** 
-    * Returns the string value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getString(fldname);
-      else
-         return s2.getString(fldname);
-   }
-   
-   /**
-    * Returns true if the specified field is in
-    * either of the underlying scans.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return s1.hasField(fldname) || s2.hasField(fldname);
-   }
-}
-
diff --git a/src/simpledb/materialize/RecordComparator.class b/src/simpledb/materialize/RecordComparator.class
deleted file mode 100644
index 8188cb7..0000000
Binary files a/src/simpledb/materialize/RecordComparator.class and /dev/null differ
diff --git a/src/simpledb/materialize/RecordComparator.java b/src/simpledb/materialize/RecordComparator.java
deleted file mode 100644
index f992440..0000000
--- a/src/simpledb/materialize/RecordComparator.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * A comparator for scans.
- * @author Edward Sciore
- */
-public class RecordComparator implements Comparator<Scan> {
-   private List<String> fields;
-   
-   /**
-    * Creates a comparator using the specified fields,
-    * using the ordering implied by its iterator.
-    * @param fields a list of field names
-    */
-   public RecordComparator(List<String> fields) {
-      this.fields = fields;
-   }
-   
-   /**
-    * Compares the current records of the two specified scans.
-    * The sort fields are considered in turn.
-    * When a field is encountered for which the records have
-    * different values, those values are used as the result
-    * of the comparison.
-    * If the two records have the same values for all
-    * sort fields, then the method returns 0.
-    * @param s1 the first scan
-    * @param s2 the second scan
-    * @return the result of comparing each scan's current record according to the field list
-    */
-   public int compare(Scan s1, Scan s2) {
-      for (String fldname : fields) {
-         Constant val1 = s1.getVal(fldname);
-         Constant val2 = s2.getVal(fldname);
-         int result = val1.compareTo(val2);
-         if (result != 0)
-            return result;
-      }
-      return 0;
-   }
-}
diff --git a/src/simpledb/materialize/SortPlan.class b/src/simpledb/materialize/SortPlan.class
deleted file mode 100644
index 1af8009..0000000
Binary files a/src/simpledb/materialize/SortPlan.class and /dev/null differ
diff --git a/src/simpledb/materialize/SortPlan.java b/src/simpledb/materialize/SortPlan.java
deleted file mode 100644
index 6be8204..0000000
--- a/src/simpledb/materialize/SortPlan.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-
-import java.util.*;
-
-/**
- * The Plan class for the <i>sort</i> operator.
- * @author Edward Sciore
- */
-public class SortPlan implements Plan {
-   private Plan p;
-   private Transaction tx;
-   private Schema sch;
-   private RecordComparator comp;
-   
-   /**
-    * Creates a sort plan for the specified query.
-    * @param p the plan for the underlying query
-    * @param sortfields the fields to sort by
-    * @param tx the calling transaction
-    */
-   public SortPlan(Plan p, List<String> sortfields, Transaction tx) {
-      this.p = p;
-      this.tx = tx;
-      sch = p.schema();
-      comp = new RecordComparator(sortfields);
-   }
-   
-   /**
-    * This method is where most of the action is.
-    * Up to 2 sorted temporary tables are created,
-    * and are passed into SortScan for final merging.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan src = p.open();
-      List<TempTable> runs = splitIntoRuns(src);
-      src.close();
-      while (runs.size() > 2)
-         runs = doAMergeIteration(runs);
-      return new SortScan(runs, comp);
-   }
-   
-   /**
-    * Returns the number of blocks in the sorted table,
-    * which is the same as it would be in a
-    * materialized table.
-    * It does <i>not</i> include the one-time cost
-    * of materializing and sorting the records.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      // does not include the one-time cost of sorting
-      Plan mp = new MaterializePlan(p, tx); // not opened; just for analysis
-      return mp.blocksAccessed();
-   }
-   
-   /**
-    * Returns the number of records in the sorted table,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p.recordsOutput();
-   }
-   
-   /**
-    * Returns the number of distinct field values in
-    * the sorted table, which is the same as in
-    * the underlying query.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      return p.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the sorted table, which
-    * is the same as in the underlying query.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return sch;
-   }
-   
-   private List<TempTable> splitIntoRuns(Scan src) {
-      List<TempTable> temps = new ArrayList<TempTable>();
-      src.beforeFirst();
-      if (!src.next())
-         return temps;
-      TempTable currenttemp = new TempTable(sch, tx);
-      temps.add(currenttemp);
-      UpdateScan currentscan = currenttemp.open();
-      while (copy(src, currentscan))
-         if (comp.compare(src, currentscan) < 0) {
-         // start a new run
-         currentscan.close();
-         currenttemp = new TempTable(sch, tx);
-         temps.add(currenttemp);
-         currentscan = (UpdateScan) currenttemp.open();
-      }
-      currentscan.close();
-      return temps;
-   }
-   
-   private List<TempTable> doAMergeIteration(List<TempTable> runs) {
-      List<TempTable> result = new ArrayList<TempTable>();
-      while (runs.size() > 1) {
-         TempTable p1 = runs.remove(0);
-         TempTable p2 = runs.remove(0);
-         result.add(mergeTwoRuns(p1, p2));
-      }
-      if (runs.size() == 1)
-         result.add(runs.get(0));
-      return result;
-   }
-   
-   private TempTable mergeTwoRuns(TempTable p1, TempTable p2) {
-      Scan src1 = p1.open();
-      Scan src2 = p2.open();
-      TempTable result = new TempTable(sch, tx);
-      UpdateScan dest = result.open();
-      
-      boolean hasmore1 = src1.next();
-      boolean hasmore2 = src2.next();
-      while (hasmore1 && hasmore2)
-         if (comp.compare(src1, src2) < 0)
-         hasmore1 = copy(src1, dest);
-      else
-         hasmore2 = copy(src2, dest);
-      
-      if (hasmore1)
-         while (hasmore1)
-         hasmore1 = copy(src1, dest);
-      else
-         while (hasmore2)
-         hasmore2 = copy(src2, dest);
-      src1.close();
-      src2.close();
-      dest.close();
-      return result;
-   }
-   
-   private boolean copy(Scan src, UpdateScan dest) {
-      dest.insert();
-      for (String fldname : sch.fields())
-         dest.setVal(fldname, src.getVal(fldname));
-      return src.next();
-   }
-}
diff --git a/src/simpledb/materialize/SortScan.class b/src/simpledb/materialize/SortScan.class
deleted file mode 100644
index de54d78..0000000
Binary files a/src/simpledb/materialize/SortScan.class and /dev/null differ
diff --git a/src/simpledb/materialize/SortScan.java b/src/simpledb/materialize/SortScan.java
deleted file mode 100644
index dcf8692..0000000
--- a/src/simpledb/materialize/SortScan.java
+++ /dev/null
@@ -1,150 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.record.RID;
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * The Scan class for the <i>sort</i> operator.
- * @author Edward Sciore
- */
-/**
- * @author sciore
- *
- */
-public class SortScan implements Scan {
-   private UpdateScan s1, s2=null, currentscan=null;
-   private RecordComparator comp;
-   private boolean hasmore1, hasmore2=false;
-   private List<RID> savedposition;
-   
-   /**
-    * Creates a sort scan, given a list of 1 or 2 runs.
-    * If there is only 1 run, then s2 will be null and
-    * hasmore2 will be false.
-    * @param runs the list of runs
-    * @param comp the record comparator
-    */
-   public SortScan(List<TempTable> runs, RecordComparator comp) {
-      this.comp = comp;
-      s1 = (UpdateScan) runs.get(0).open();
-      hasmore1 = s1.next();
-      if (runs.size() > 1) {
-         s2 = (UpdateScan) runs.get(1).open();
-         hasmore2 = s2.next();
-      }
-   }
-   
-   /**
-    * Positions the scan before the first record in sorted order.
-    * Internally, it moves to the first record of each underlying scan.
-    * The variable currentscan is set to null, indicating that there is
-    * no current scan.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      currentscan = null;
-      s1.beforeFirst();
-      hasmore1 = s1.next();
-      if (s2 != null) {
-         s2.beforeFirst();
-         hasmore2 = s2.next();
-      }
-   }
-   
-   /**
-    * Moves to the next record in sorted order.
-    * First, the current scan is moved to the next record.
-    * Then the lowest record of the two scans is found, and that
-    * scan is chosen to be the new current scan.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      if (currentscan != null) {
-         if (currentscan == s1)
-            hasmore1 = s1.next();
-         else if (currentscan == s2)
-            hasmore2 = s2.next();
-      }
-      
-      if (!hasmore1 && !hasmore2)
-         return false;
-      else if (hasmore1 && hasmore2) {
-         if (comp.compare(s1, s2) < 0)
-            currentscan = s1;
-         else
-            currentscan = s2;
-      }
-      else if (hasmore1)
-         currentscan = s1;
-      else if (hasmore2)
-         currentscan = s2;
-      return true;
-   }
-   
-   /**
-    * Closes the two underlying scans.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s1.close();
-      if (s2 != null)
-         s2.close();
-   }
-   
-   /**
-    * Gets the Constant value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      return currentscan.getVal(fldname);
-   }
-   
-   /**
-    * Gets the integer value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return currentscan.getInt(fldname);
-   }
-   
-   /**
-    * Gets the string value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return currentscan.getString(fldname);
-   }
-   
-   /**
-    * Returns true if the specified field is in the current scan.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return currentscan.hasField(fldname);
-   }
-   
-   /**
-    * Saves the position of the current record,
-    * so that it can be restored at a later time.
-    */
-   public void savePosition() {
-      RID rid1 = s1.getRid();
-      RID rid2 = (s2 == null) ? null : s2.getRid();
-      savedposition = Arrays.asList(rid1,rid2);
-   }
-   
-   /**
-    * Moves the scan to its previously-saved position.
-    */
-   public void restorePosition() {
-      RID rid1 = savedposition.get(0);
-      RID rid2 = savedposition.get(1);
-      s1.moveToRid(rid1);
-      if (rid2 != null)
-         s2.moveToRid(rid2);
-   }
-}
diff --git a/src/simpledb/materialize/SortScan.java~ b/src/simpledb/materialize/SortScan.java~
deleted file mode 100644
index 48e2dfe..0000000
--- a/src/simpledb/materialize/SortScan.java~
+++ /dev/null
@@ -1,155 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.record.RID;
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * The Scan class for the <i>sort</i> operator.
- * @author Edward Sciore
- */
-/**
- * @author sciore
- *
- */
-public class SortScan implements Scan {
-   private UpdateScan s1, s2=null, currentscan=null;
-   private RecordComparator comp;
-   private boolean hasmore1, hasmore2=false;
-   private List<RID> savedposition;
-   
-   /**
-    * Creates a sort scan, given a list of 1 or 2 runs.
-    * If there is only 1 run, then s2 will be null and
-    * hasmore2 will be false.
-    * @param runs the list of runs
-    * @param comp the record comparator
-    */
-   public SortScan(List<TempTable> runs, RecordComparator comp) {
-      this.comp = comp;
-      s1 = (UpdateScan) runs.get(0).open();
-      hasmore1 = s1.next();
-      if (runs.size() > 1) {
-         s2 = (UpdateScan) runs.get(1).open();
-         hasmore2 = s2.next();
-      }
-   }
-   
-   /**
-    * Positions the scan before the first record in sorted order.
-    * Internally, it moves to the first record of each underlying scan.
-    * The variable currentscan is set to null, indicating that there is
-    * no current scan.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      currentscan = null;
-      s1.beforeFirst();
-      hasmore1 = s1.next();
-      if (s2 != null) {
-         s2.beforeFirst();
-         hasmore2 = s2.next();
-      }
-   }
-   
-   /**
-    * Moves to the next record in sorted order.
-    * First, the current scan is moved to the next record.
-    * Then the lowest record of the two scans is found, and that
-    * scan is chosen to be the new current scan.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      if (currentscan != null) {
-         if (currentscan == s1)
-            hasmore1 = s1.next();
-         else if (currentscan == s2)
-            hasmore2 = s2.next();
-      }
-      
-      if (!hasmore1 && !hasmore2)
-         return false;
-      else if (hasmore1 && hasmore2) {
-         if (comp.compare(s1, s2) < 0)
-            currentscan = s1;
-         else
-            currentscan = s2;
-      }
-      else if (hasmore1)
-         currentscan = s1;
-      else if (hasmore2)
-         currentscan = s2;
-      return true;
-   }
-   
-   /**
-    * Closes the two underlying scans.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s1.close();
-      if (s2 != null)
-         s2.close();
-   }
-   
-   /**
-    * Gets the Constant value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      return currentscan.getVal(fldname);
-   }
-   
-   /**
-    * Gets the integer value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return currentscan.getInt(fldname);
-   }
-   
-   /**
-    * Gets the string value of the specified field
-    * of the current scan.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return currentscan.getString(fldname);
-   }
-   
-   /**
-    * Returns true if the specified field is in the current scan.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return currentscan.hasField(fldname);
-   }
-   
-   /**
-    * Saves the position of the current record,
-    * so that it can be restored at a later time.
-    */
-   public void savePosition() {
-      if (currentscan == null)
-        savedposition = null;
-      else {
-        RID rid1 = s1.getRid();
-        RID rid2 = s2.getRid();
-        savedposition = Arrays.asList(rid1,rid2);
-      }
-   }
-   
-   /**
-    * Moves the scan to its previously-saved position.
-    */
-   public void restorePosition() {
-     if (currentscan != null) {
-       RID rid1 = savedposition.get(0);
-       RID rid2 = savedposition.get(1);
-       s1.moveToRid(rid1);
-       s2.moveToRid(rid2);
-     }
-   }
-}
diff --git a/src/simpledb/materialize/TempTable.class b/src/simpledb/materialize/TempTable.class
deleted file mode 100644
index 05623f7..0000000
Binary files a/src/simpledb/materialize/TempTable.class and /dev/null differ
diff --git a/src/simpledb/materialize/TempTable.java b/src/simpledb/materialize/TempTable.java
deleted file mode 100644
index 4107ea9..0000000
--- a/src/simpledb/materialize/TempTable.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package simpledb.materialize;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.query.*;
-
-/**
- * A class that creates temporary tables.
- * A temporary table is not registered in the catalog.
- * The class therefore has a method getTableInfo to return the 
- * table's metadata. 
- * @author Edward Sciore
- */
-public class TempTable {
-   private static int nextTableNum = 0;
-   private TableInfo ti;
-   private Transaction tx;
-   
-   /**
-    * Allocates a name for for a new temporary table
-    * having the specified schema.
-    * @param sch the new table's schema
-    * @param tx the calling transaction
-    */
-   public TempTable(Schema sch, Transaction tx) {
-      String tblname = nextTableName();
-      ti = new TableInfo(tblname, sch);
-      this.tx = tx;
-   }
-   
-   /**
-    * Opens a table scan for the temporary table.
-    */
-   public UpdateScan open() {
-      return new TableScan(ti, tx);
-   }
-   
-   /**
-    * Return the table's metadata.
-    * @return the table's metadata
-    */
-   public TableInfo getTableInfo() {
-      return ti;
-   }
-   
-   private static synchronized String nextTableName() {
-      nextTableNum++;
-      return "temp" + nextTableNum;
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/metadata/.DS_Store b/src/simpledb/metadata/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/src/simpledb/metadata/.DS_Store and /dev/null differ
diff --git a/src/simpledb/metadata/IndexInfo.class b/src/simpledb/metadata/IndexInfo.class
deleted file mode 100644
index 7421f00..0000000
Binary files a/src/simpledb/metadata/IndexInfo.class and /dev/null differ
diff --git a/src/simpledb/metadata/IndexInfo.java b/src/simpledb/metadata/IndexInfo.java
deleted file mode 100644
index 53f558c..0000000
--- a/src/simpledb/metadata/IndexInfo.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package simpledb.metadata;
-
-import static java.sql.Types.INTEGER;
-import static simpledb.file.Page.BLOCK_SIZE;
-import simpledb.server.SimpleDB;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.index.Index;
-import simpledb.index.hash.HashIndex;
-
-
-/**
- * The information about an index.
- * This information is used by the query planner in order to
- * estimate the costs of using the index,
- * and to obtain the schema of the index records.
- * Its methods are essentially the same as those of Plan.
- * @author Edward Sciore
- */
-public class IndexInfo {
-   private String idxname, fldname;
-   private Transaction tx;
-   private TableInfo ti;
-   private StatInfo si;
-   
-   /**
-    * Creates an IndexInfo object for the specified index.
-    * @param idxname the name of the index
-    * @param tblname the name of the table
-    * @param fldname the name of the indexed field
-    * @param tx the calling transaction
-    */
-   public IndexInfo(String idxname, String tblname, String fldname,
-                    Transaction tx) {
-      this.idxname = idxname;
-      this.fldname = fldname;
-      this.tx = tx;
-      ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
-      si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
-   }
-   
-   /**
-    * Opens the index described by this object.
-    * @return the Index object associated with this information
-    */
-   public Index open() {
-      Schema sch = schema();
-      // Create new HashIndex for hash indexing
-      return new HashIndex(idxname, sch, tx);
-   }
-   
-   /**
-    * Estimates the number of block accesses required to
-    * find all index records having a particular search key.
-    * The method uses the table's metadata to estimate the
-    * size of the index file and the number of index records
-    * per block.
-    * It then passes this information to the traversalCost
-    * method of the appropriate index type,
-    * which provides the estimate.
-    * @return the number of block accesses required to traverse the index
-    */
-   public int blocksAccessed() {
-      TableInfo idxti = new TableInfo("", schema());
-      int rpb = BLOCK_SIZE / idxti.recordLength();
-      int numblocks = si.recordsOutput() / rpb;
-      // Call HashIndex.searchCost for hash indexing
-      return HashIndex.searchCost(numblocks, rpb);
-   }
-   
-   /**
-    * Returns the estimated number of records having a
-    * search key.  This value is the same as doing a select
-    * query; that is, it is the number of records in the table
-    * divided by the number of distinct values of the indexed field.
-    * @return the estimated number of records having a search key
-    */
-   public int recordsOutput() {
-      return si.recordsOutput() / si.distinctValues(fldname);
-   }
-   
-   /** 
-    * Returns the distinct values for a specified field 
-    * in the underlying table, or 1 for the indexed field.
-    * @param fname the specified field
-    */
-   public int distinctValues(String fname) {
-      if (fldname.equals(fname))
-         return 1;
-      else 
-         return Math.min(si.distinctValues(fldname), recordsOutput());
-   }
-   
-   /**
-    * Returns the schema of the index records.
-    * The schema consists of the dataRID (which is
-    * represented as two integers, the block number and the
-    * record ID) and the dataval (which is the indexed field).
-    * Schema information about the indexed field is obtained
-    * via the table's metadata.
-    * @return the schema of the index records
-    */
-   private Schema schema() {
-      Schema sch = new Schema();
-      sch.addIntField("block");
-      sch.addIntField("id");
-      if (ti.schema().type(fldname) == INTEGER)
-         sch.addIntField("dataval");
-      else {
-         int fldlen = ti.schema().length(fldname);
-         sch.addStringField("dataval", fldlen);
-      }
-      return sch;
-   }
-}
diff --git a/src/simpledb/metadata/IndexMgr.class b/src/simpledb/metadata/IndexMgr.class
deleted file mode 100644
index 0af5415..0000000
Binary files a/src/simpledb/metadata/IndexMgr.class and /dev/null differ
diff --git a/src/simpledb/metadata/IndexMgr.java b/src/simpledb/metadata/IndexMgr.java
deleted file mode 100644
index 9f11b89..0000000
--- a/src/simpledb/metadata/IndexMgr.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package simpledb.metadata;
-
-import static simpledb.metadata.TableMgr.MAX_NAME;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import java.util.*;
-
-/**
- * The index manager.
- * The index manager has similar functionalty to the table manager.
- * @author Edward Sciore
- */
-public class IndexMgr {
-   private TableInfo ti;
-   
-   /**
-    * Creates the index manager.
-    * This constructor is called during system startup.
-    * If the database is new, then the <i>idxcat</i> table is created.
-    * @param isnew indicates whether this is a new database
-    * @param tx the system startup transaction
-    */
-   public IndexMgr(boolean isnew, TableMgr tblmgr, Transaction tx) {
-      if (isnew) {
-         Schema sch = new Schema();
-         sch.addStringField("indexname", MAX_NAME);
-         sch.addStringField("tablename", MAX_NAME);
-         sch.addStringField("fieldname", MAX_NAME);
-         tblmgr.createTable("idxcat", sch, tx);
-      }
-      ti = tblmgr.getTableInfo("idxcat", tx);
-   }
-   
-   /**
-    * Creates an index of the specified type for the specified field.
-    * A unique ID is assigned to this index, and its information
-    * is stored in the idxcat table.
-    * @param idxname the name of the index
-    * @param tblname the name of the indexed table
-    * @param fldname the name of the indexed field
-    * @param tx the calling transaction
-    */
-   public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
-      RecordFile rf = new RecordFile(ti, tx);
-      rf.insert();
-      rf.setString("indexname", idxname);
-      rf.setString("tablename", tblname);
-      rf.setString("fieldname", fldname);
-      rf.close();
-   }
-   
-   /**
-    * Returns a map containing the index info for all indexes
-    * on the specified table.
-    * @param tblname the name of the table
-    * @param tx the calling transaction
-    * @return a map of IndexInfo objects, keyed by their field names
-    */
-   public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
-      Map<String,IndexInfo> result = new HashMap<String,IndexInfo>();
-      RecordFile rf = new RecordFile(ti, tx);
-      while (rf.next())
-         if (rf.getString("tablename").equals(tblname)) {
-         String idxname = rf.getString("indexname");
-         String fldname = rf.getString("fieldname");
-         IndexInfo ii = new IndexInfo(idxname, tblname, fldname, tx);
-         result.put(fldname, ii);
-      }
-      rf.close();
-      return result;
-   }
-}
diff --git a/src/simpledb/metadata/MetadataMgr.class b/src/simpledb/metadata/MetadataMgr.class
deleted file mode 100644
index 5019e65..0000000
Binary files a/src/simpledb/metadata/MetadataMgr.class and /dev/null differ
diff --git a/src/simpledb/metadata/MetadataMgr.java b/src/simpledb/metadata/MetadataMgr.java
deleted file mode 100644
index f2aa8ef..0000000
--- a/src/simpledb/metadata/MetadataMgr.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package simpledb.metadata;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import java.util.Map;
-
-public class MetadataMgr {
-   private static TableMgr  tblmgr;
-   private static ViewMgr   viewmgr;
-   private static StatMgr   statmgr;
-   private static IndexMgr  idxmgr;
-   
-   public MetadataMgr(boolean isnew, Transaction tx) {
-      tblmgr  = new TableMgr(isnew, tx);
-      viewmgr = new ViewMgr(isnew, tblmgr, tx);
-      statmgr = new StatMgr(tblmgr, tx);
-      idxmgr  = new IndexMgr(isnew, tblmgr, tx);
-   }
-   
-   public void createTable(String tblname, Schema sch, Transaction tx) {
-      tblmgr.createTable(tblname, sch, tx);
-   }
-   
-   public TableInfo getTableInfo(String tblname, Transaction tx) {
-      return tblmgr.getTableInfo(tblname, tx);
-   }
-   
-   public void createView(String viewname, String viewdef, Transaction tx) {
-      viewmgr.createView(viewname, viewdef, tx);
-   }
-   
-   public String getViewDef(String viewname, Transaction tx) {
-      return viewmgr.getViewDef(viewname, tx);
-   }
-   
-   public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
-      idxmgr.createIndex(idxname, tblname, fldname, tx);
-   }
-   
-   public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
-      return idxmgr.getIndexInfo(tblname, tx);
-   }
-   
-   public StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
-      return statmgr.getStatInfo(tblname, ti, tx);
-   }
-}
diff --git a/src/simpledb/metadata/StatInfo.class b/src/simpledb/metadata/StatInfo.class
deleted file mode 100644
index 188d946..0000000
Binary files a/src/simpledb/metadata/StatInfo.class and /dev/null differ
diff --git a/src/simpledb/metadata/StatInfo.java b/src/simpledb/metadata/StatInfo.java
deleted file mode 100644
index 198ea2b..0000000
--- a/src/simpledb/metadata/StatInfo.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package simpledb.metadata;
-
-/**
- * Holds three pieces of statistical information about a table:
- * the number of blocks, the number of records,
- * and the number of distinct values for each field. 
- * @author Edward Sciore
- */
-public class StatInfo {
-   private int numBlocks;
-   private int numRecs;
-   
-   /**
-    * Creates a StatInfo object.
-    * Note that the number of distinct values is not
-    * passed into the constructor.
-    * The object fakes this value.
-    * @param numblocks the number of blocks in the table
-    * @param numrecs the number of records in the table
-    */
-   public StatInfo(int numblocks, int numrecs) {
-      this.numBlocks = numblocks;
-      this.numRecs   = numrecs;
-   }
-   
-   /**
-    * Returns the estimated number of blocks in the table.
-    * @return the estimated number of blocks in the table
-    */
-   public int blocksAccessed() {
-      return numBlocks;
-   }
-   
-   /**
-    * Returns the estimated number of records in the table.
-    * @return the estimated number of records in the table
-    */
-   public int recordsOutput() {
-      return numRecs;
-   }
-   
-   /**
-    * Returns the estimated number of distinct values
-    * for the specified field.
-    * In actuality, this estimate is a complete guess.
-    * @param fldname the name of the field
-    * @return a guess as to the number of distinct field values
-    */
-   public int distinctValues(String fldname) {
-      return 1 + (numRecs / 3);
-   }
-}
diff --git a/src/simpledb/metadata/StatMgr.class b/src/simpledb/metadata/StatMgr.class
deleted file mode 100644
index a67122d..0000000
Binary files a/src/simpledb/metadata/StatMgr.class and /dev/null differ
diff --git a/src/simpledb/metadata/StatMgr.java b/src/simpledb/metadata/StatMgr.java
deleted file mode 100644
index e128c6a..0000000
--- a/src/simpledb/metadata/StatMgr.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package simpledb.metadata;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import java.util.*;
-
-/**
- * The statistics manager, which is responsible for
- * keeping statistical information about each table.
- * The manager does not store this information in the database.
- * Instead, it calculates this information on system startup,
- * and periodically refreshes it.
- * @author Edward Sciore
- */
-class StatMgr {
-   private TableMgr tblMgr;
-   private Map<String,StatInfo> tablestats;
-   private int numcalls;
-   
-   /**
-    * Creates the statistics manager.
-    * The initial statistics are calculated by
-    * traversing the entire database.
-    * @param tx the startup transaction
-    */
-   public StatMgr(TableMgr tblMgr, Transaction tx) {
-      this.tblMgr = tblMgr;
-      refreshStatistics(tx);
-   }
-   
-   /**
-    * Returns the statistical information about the specified table.
-    * @param tblname the name of the table
-    * @param ti the table's metadata
-    * @param tx the calling transaction
-    * @return the statistical information about the table
-    */
-   public synchronized StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
-      numcalls++;
-      if (numcalls > 100)
-         refreshStatistics(tx);
-      StatInfo si = tablestats.get(tblname);
-      if (si == null) {
-         si = calcTableStats(ti, tx);
-         tablestats.put(tblname, si);
-      }
-      return si;
-   }
-   
-   private synchronized void refreshStatistics(Transaction tx) {
-      tablestats = new HashMap<String,StatInfo>();
-      numcalls = 0;
-      TableInfo tcatmd = tblMgr.getTableInfo("tblcat", tx);
-      RecordFile tcatfile = new RecordFile(tcatmd, tx);
-      while(tcatfile.next()) {
-         String tblname = tcatfile.getString("tblname");
-         TableInfo md = tblMgr.getTableInfo(tblname, tx);
-         StatInfo si = calcTableStats(md, tx);
-         tablestats.put(tblname, si);
-      }
-      tcatfile.close();
-   }
-   
-   private synchronized StatInfo calcTableStats(TableInfo ti, Transaction tx) {
-      int numRecs = 0;
-      RecordFile rf = new RecordFile(ti, tx);
-      int numblocks = 0;
-      while (rf.next()) {
-         numRecs++;
-         numblocks = rf.currentRid().blockNumber() + 1;
-      }
-      rf.close();
-      return new StatInfo(numblocks, numRecs);
-   }
-}
diff --git a/src/simpledb/metadata/TableMgr.class b/src/simpledb/metadata/TableMgr.class
deleted file mode 100644
index 99b887b..0000000
Binary files a/src/simpledb/metadata/TableMgr.class and /dev/null differ
diff --git a/src/simpledb/metadata/TableMgr.java b/src/simpledb/metadata/TableMgr.java
deleted file mode 100644
index 9f8b1b9..0000000
--- a/src/simpledb/metadata/TableMgr.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package simpledb.metadata;
-
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import java.util.*;
-
-/**
- * The table manager.
- * There are methods to create a table, save the metadata
- * in the catalog, and obtain the metadata of a
- * previously-created table.
- * @author Edward Sciore
- *
- */
-public class TableMgr {
-   /**
-    * The maximum number of characters in any
-    * tablename or fieldname.
-    * Currently, this value is 16.
-    */
-   public static final int MAX_NAME = 16;
-   
-   private TableInfo tcatInfo, fcatInfo;
-   
-   /**
-    * Creates a new catalog manager for the database system.
-    * If the database is new, then the two catalog tables
-    * are created.
-    * @param isNew has the value true if the database is new
-    * @param tx the startup transaction
-    */
-   public TableMgr(boolean isNew, Transaction tx) {
-      Schema tcatSchema = new Schema();
-      tcatSchema.addStringField("tblname", MAX_NAME);
-      tcatSchema.addIntField("reclength");
-      tcatInfo = new TableInfo("tblcat", tcatSchema);
-      
-      Schema fcatSchema = new Schema();
-      fcatSchema.addStringField("tblname", MAX_NAME);
-      fcatSchema.addStringField("fldname", MAX_NAME);
-      fcatSchema.addIntField("type");
-      fcatSchema.addIntField("length");
-      fcatSchema.addIntField("offset");
-      fcatInfo = new TableInfo("fldcat", fcatSchema);
-      
-      if (isNew) {
-         createTable("tblcat", tcatSchema, tx);
-         createTable("fldcat", fcatSchema, tx);
-      }
-   }
-   
-   /**
-    * Creates a new table having the specified name and schema.
-    * @param tblname the name of the new table
-    * @param sch the table's schema
-    * @param tx the transaction creating the table
-    */
-   public void createTable(String tblname, Schema sch, Transaction tx) {
-      TableInfo ti = new TableInfo(tblname, sch);
-      // insert one record into tblcat
-      RecordFile tcatfile = new RecordFile(tcatInfo, tx);
-      tcatfile.insert();
-      tcatfile.setString("tblname", tblname);
-      tcatfile.setInt("reclength", ti.recordLength());
-      tcatfile.close();
-      
-      // insert a record into fldcat for each field
-      RecordFile fcatfile = new RecordFile(fcatInfo, tx);
-      for (String fldname : sch.fields()) {
-         fcatfile.insert();
-         fcatfile.setString("tblname", tblname);
-         fcatfile.setString("fldname", fldname);
-         fcatfile.setInt   ("type",   sch.type(fldname));
-         fcatfile.setInt   ("length", sch.length(fldname));
-         fcatfile.setInt   ("offset", ti.offset(fldname));
-      }
-      fcatfile.close();
-   }
-   
-   /**
-    * Retrieves the metadata for the specified table
-    * out of the catalog.
-    * @param tblname the name of the table
-    * @param tx the transaction
-    * @return the table's stored metadata
-    */
-   public TableInfo getTableInfo(String tblname, Transaction tx) {
-      RecordFile tcatfile = new RecordFile(tcatInfo, tx);
-      int reclen = -1;
-      while (tcatfile.next())
-         if(tcatfile.getString("tblname").equals(tblname)) {
-         reclen = tcatfile.getInt("reclength");
-         break;
-      }
-      tcatfile.close();
-      
-      RecordFile fcatfile = new RecordFile(fcatInfo, tx);
-      Schema sch = new Schema();
-      Map<String,Integer> offsets = new HashMap<String,Integer>();
-      while (fcatfile.next())
-         if (fcatfile.getString("tblname").equals(tblname)) {
-         String fldname = fcatfile.getString("fldname");
-         int fldtype    = fcatfile.getInt("type");
-         int fldlen     = fcatfile.getInt("length");
-         int offset     = fcatfile.getInt("offset");
-         offsets.put(fldname, offset);
-         sch.addField(fldname, fldtype, fldlen);
-      }
-      fcatfile.close();
-      return new TableInfo(tblname, sch, offsets, reclen);
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/metadata/ViewMgr.class b/src/simpledb/metadata/ViewMgr.class
deleted file mode 100644
index c1f3a99..0000000
Binary files a/src/simpledb/metadata/ViewMgr.class and /dev/null differ
diff --git a/src/simpledb/metadata/ViewMgr.java b/src/simpledb/metadata/ViewMgr.java
deleted file mode 100644
index 9b60e8f..0000000
--- a/src/simpledb/metadata/ViewMgr.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package simpledb.metadata;
-
-import simpledb.record.*;
-import simpledb.tx.Transaction;
-
-class ViewMgr {
-   private static final int MAX_VIEWDEF = 100;
-   TableMgr tblMgr;
-   
-   public ViewMgr(boolean isNew, TableMgr tblMgr, Transaction tx) {
-      this.tblMgr = tblMgr;
-      if (isNew) {
-         Schema sch = new Schema();
-         sch.addStringField("viewname", TableMgr.MAX_NAME);
-         sch.addStringField("viewdef", MAX_VIEWDEF);
-         tblMgr.createTable("viewcat", sch, tx);
-      }
-   }
-   
-   public void createView(String vname, String vdef, Transaction tx) {
-      TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
-      RecordFile rf = new RecordFile(ti, tx);
-      rf.insert();
-      rf.setString("viewname", vname);
-      rf.setString("viewdef", vdef);
-      rf.close();
-   }
-   
-   public String getViewDef(String vname, Transaction tx) {
-      String result = null;
-      TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
-      RecordFile rf = new RecordFile(ti, tx);
-      while (rf.next())
-         if (rf.getString("viewname").equals(vname)) {
-         result = rf.getString("viewdef");
-         break;
-      }
-      rf.close();
-      return result;
-   }
-}
diff --git a/src/simpledb/multibuffer/BufferNeeds.class b/src/simpledb/multibuffer/BufferNeeds.class
deleted file mode 100644
index de2c5e2..0000000
Binary files a/src/simpledb/multibuffer/BufferNeeds.class and /dev/null differ
diff --git a/src/simpledb/multibuffer/BufferNeeds.java b/src/simpledb/multibuffer/BufferNeeds.java
deleted file mode 100644
index f8ab1e5..0000000
--- a/src/simpledb/multibuffer/BufferNeeds.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package simpledb.multibuffer;
-
-import simpledb.server.SimpleDB;
-
-/**
- * A class containing static methods,
- * which estimate the optimal number of buffers
- * to allocate for a scan.
- * @author Edward Sciore
- */
-public class BufferNeeds {
-   
-   /**
-    * This method considers the various roots
-    * of the specified output size (in blocks),
-    * and returns the highest root that is less than
-    * the number of available buffers.
-    * @param size the size of the output file
-    * @return the highest number less than the number of available buffers, that is a root of the plan's output size
-    */
-   public static int bestRoot(int size) {
-      int avail = SimpleDB.bufferMgr().available();
-      if (avail <= 1)
-         return 1;
-      int k = Integer.MAX_VALUE;
-      double i = 1.0;
-      while (k > avail) {
-         i++;
-         k = (int)Math.ceil(Math.pow(size, 1/i));
-      }
-      return k;
-   }
-   
-   /**
-    * This method considers the various factors
-    * of the specified output size (in blocks),
-    * and returns the highest factor that is less than
-    * the number of available buffers.
-    * @param size the size of the output file
-    * @return the highest number less than the number of available buffers, that is a factor of the plan's output size
-    */
-   public static int bestFactor(int size) {
-      int avail = SimpleDB.bufferMgr().available();
-      if (avail <= 1)
-         return 1;
-      int k = size;
-      double i = 1.0;
-      while (k > avail) {
-         i++;
-         k = (int)Math.ceil(size / i);
-      }
-      return k;
-   }
-}
diff --git a/src/simpledb/multibuffer/ChunkScan.class b/src/simpledb/multibuffer/ChunkScan.class
deleted file mode 100644
index a88cdf0..0000000
Binary files a/src/simpledb/multibuffer/ChunkScan.class and /dev/null differ
diff --git a/src/simpledb/multibuffer/ChunkScan.java b/src/simpledb/multibuffer/ChunkScan.java
deleted file mode 100644
index b0b4cb8..0000000
--- a/src/simpledb/multibuffer/ChunkScan.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package simpledb.multibuffer;
-
-import static java.sql.Types.INTEGER;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.file.Block;
-import simpledb.query.*;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * The class for the <i>chunk</i> operator.
- * @author Edward Sciore
- */
-public class ChunkScan implements Scan {
-   private List<RecordPage> pages;
-   private int startbnum, endbnum, current;
-   private Schema sch;
-   private RecordPage rp;
-   
-   /**
-    * Creates a chunk consisting of the specified pages. 
-    * @param ti the metadata for the chunked table
-    * @param startbnum the starting block number
-    * @param endbnum  the ending block number
-    * @param tx the current transaction
-    */ 
-   public ChunkScan(TableInfo ti, int startbnum, int endbnum, Transaction tx) {
-      pages = new ArrayList<RecordPage>();
-      this.startbnum = startbnum;
-      this.endbnum   = endbnum;
-      this.sch = ti.schema();
-      String filename = ti.fileName();
-      for (int i=startbnum; i<=endbnum; i++) {
-         Block blk = new Block(filename, i);
-         pages.add(new RecordPage(blk, ti, tx));
-      }
-      beforeFirst();
-   }
-   
-   
-   /**
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      moveToBlock(startbnum);
-   }
-   
-   /**
-    * Moves to the next record in the current block of the chunk.
-    * If there are no more records, then make
-    * the next block be current.
-    * If there are no more blocks in the chunk, return false.
-    * @see simpledb.query.Scan#next()  
-    */
-   public boolean next() {
-      while (true) {
-         if (rp.next())
-            return true;
-         if (current == endbnum)
-            return false;
-         moveToBlock(current+1);
-      }
-   }
-   
-   /**
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      for (RecordPage r : pages)
-         r.close();
-   }
-   
-   /**
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (sch.type(fldname) == INTEGER)
-         return new IntConstant(rp.getInt(fldname));
-      else
-         return new StringConstant(rp.getString(fldname));
-   }
-   
-   /**
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return rp.getInt(fldname);
-   }
-   
-   /**
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return rp.getString(fldname);
-   }
-   
-   /**
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return sch.hasField(fldname);
-   }
-   
-   private void moveToBlock(int blknum) {
-      current = blknum;
-      rp = pages.get(current - startbnum);
-      rp.moveToId(-1);
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/multibuffer/MultiBufferProductPlan.class b/src/simpledb/multibuffer/MultiBufferProductPlan.class
deleted file mode 100644
index 4975a63..0000000
Binary files a/src/simpledb/multibuffer/MultiBufferProductPlan.class and /dev/null differ
diff --git a/src/simpledb/multibuffer/MultiBufferProductPlan.java b/src/simpledb/multibuffer/MultiBufferProductPlan.java
deleted file mode 100644
index 2a8b354..0000000
--- a/src/simpledb/multibuffer/MultiBufferProductPlan.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package simpledb.multibuffer;
-
-import simpledb.server.SimpleDB;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-import simpledb.materialize.*;
-import simpledb.query.*;
-
-/**
- * The Plan class for the muti-buffer version of the
- * <i>product</i> operator.
- * @author Edward Sciore
- */
-public class MultiBufferProductPlan implements Plan {
-   private Plan lhs, rhs;
-   private Transaction tx;
-   private Schema schema = new Schema();
-   
-   /**
-    * Creates a product plan for the specified queries.
-    * @param lhs the plan for the LHS query
-    * @param rhs the plan for the RHS query
-    * @param tx the calling transaction
-    */
-   public MultiBufferProductPlan(Plan lhs, Plan rhs, Transaction tx) {
-      this.lhs = lhs;
-      this.rhs = rhs;
-      this.tx = tx;
-      schema.addAll(lhs.schema());
-      schema.addAll(rhs.schema());
-   }
-   
-   /**
-    * A scan for this query is created and returned, as follows.
-    * First, the method materializes its RHS query.
-    * It then determines the optimal chunk size,
-    * based on the size of the materialized file and the
-    * number of available buffers.
-    * It creates a chunk plan for each chunk, saving them in a list.
-    * Finally, it creates a multiscan for this list of plans,
-    * and returns that scan.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      TempTable tt = copyRecordsFrom(rhs);
-      TableInfo ti = tt.getTableInfo();
-      Scan leftscan = lhs.open();
-      return new MultiBufferProductScan(leftscan, ti, tx);
-   }
-   
-   /**
-    * Returns an estimate of the number of block accesses
-    * required to execute the query. The formula is:
-    * <pre> B(product(p1,p2)) = B(p2) + B(p1)*C(p2) </pre>
-    * where C(p2) is the number of chunks of p2.
-    * The method uses the current number of available buffers
-    * to calculate C(p2), and so this value may differ
-    * when the query scan is opened.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      // this guesses at the # of chunks
-      int avail = SimpleDB.bufferMgr().available();
-      int size = new MaterializePlan(rhs, tx).blocksAccessed();
-      int numchunks = size / avail;
-      return rhs.blocksAccessed() +
-         (lhs.blocksAccessed() * numchunks);
-   }
-   
-   /**
-    * Estimates the number of output records in the product.
-    * The formula is:
-    * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return lhs.recordsOutput() * rhs.recordsOutput();
-   }
-   
-   /**
-    * Estimates the distinct number of field values in the product.
-    * Since the product does not increase or decrease field values,
-    * the estimate is the same as in the appropriate underlying query.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (lhs.schema().hasField(fldname))
-         return lhs.distinctValues(fldname);
-      else
-         return rhs.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the product,
-    * which is the union of the schemas of the underlying queries.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return schema;
-   }
-   
-   private TempTable copyRecordsFrom(Plan p) {
-      Scan   src = p.open(); 
-      Schema sch = p.schema();
-      TempTable tt = new TempTable(sch, tx);
-      UpdateScan dest = (UpdateScan) tt.open();
-      while (src.next()) {
-         dest.insert();
-         for (String fldname : sch.fields())
-            dest.setVal(fldname, src.getVal(fldname));
-      }
-      src.close();
-      dest.close();
-      return tt;
-   }
-}
diff --git a/src/simpledb/multibuffer/MultiBufferProductScan.class b/src/simpledb/multibuffer/MultiBufferProductScan.class
deleted file mode 100644
index 2e372f0..0000000
Binary files a/src/simpledb/multibuffer/MultiBufferProductScan.class and /dev/null differ
diff --git a/src/simpledb/multibuffer/MultiBufferProductScan.java b/src/simpledb/multibuffer/MultiBufferProductScan.java
deleted file mode 100644
index 3fc21d3..0000000
--- a/src/simpledb/multibuffer/MultiBufferProductScan.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package simpledb.multibuffer;
-
-import simpledb.tx.Transaction;
-import simpledb.record.TableInfo;
-import simpledb.query.*;
-
-/** 
- * The Scan class for the muti-buffer version of the
- * <i>product</i> operator.
- * @author Edward Sciore
- */
-public class MultiBufferProductScan implements Scan {
-   private Scan lhsscan, rhsscan=null, prodscan;
-   private TableInfo ti;
-   private Transaction tx;
-   private int chunksize, nextblknum, filesize;
-   
-   
-   /**
-    * Creates the scan class for the product of the LHS scan and a table.
-    * @param lhsscan the LHS scan
-    * @param ti the metadata for the RHS table
-    * @param tx the current transaction
-    */
-   public MultiBufferProductScan(Scan lhsscan, TableInfo ti, Transaction tx) {
-      this.lhsscan = lhsscan;
-      this.ti = ti;
-      this.tx = tx;
-      filesize = tx.size(ti.fileName());
-      chunksize = BufferNeeds.bestFactor(filesize);
-      beforeFirst();
-   }
-   
-   /**
-    * Positions the scan before the first record.
-    * That is, the LHS scan is positioned at its first record,
-    * and the RHS scan is positioned before the first record of the first chunk.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      nextblknum = 0;
-      useNextChunk();
-   }
-   
-   /**
-    * Moves to the next record in the current scan.
-    * If there are no more records in the current chunk,
-    * then move to the next LHS record and the beginning of that chunk.
-    * If there are no more LHS records, then move to the next chunk
-    * and begin again.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      while (!prodscan.next()) 
-         if (!useNextChunk())
-         return false;
-      return true;
-   }
-   
-   /**
-    * Closes the current scans.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      prodscan.close();
-   }
-   
-   /** 
-    * Returns the value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      return prodscan.getVal(fldname);
-   }
-   
-   /** 
-    * Returns the integer value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      return prodscan.getInt(fldname);
-   }
-   
-   /** 
-    * Returns the string value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      return prodscan.getString(fldname);
-   }
-   
-   /**
-    * Returns true if the specified field is in
-    * either of the underlying scans.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return prodscan.hasField(fldname);
-   }
-   
-   private boolean useNextChunk() {
-      if (rhsscan != null)
-         rhsscan.close();
-      if (nextblknum >= filesize)
-         return false;
-      int end = nextblknum + chunksize - 1;
-      if (end >= filesize)
-         end = filesize - 1;
-      rhsscan = new ChunkScan(ti, nextblknum, end, tx);
-      lhsscan.beforeFirst();
-      prodscan = new ProductScan(lhsscan, rhsscan);
-      nextblknum = end + 1;
-      return true;
-   }
-}
-
diff --git a/src/simpledb/opt/HeuristicQueryPlanner.class b/src/simpledb/opt/HeuristicQueryPlanner.class
deleted file mode 100644
index 63b6e8f..0000000
Binary files a/src/simpledb/opt/HeuristicQueryPlanner.class and /dev/null differ
diff --git a/src/simpledb/opt/HeuristicQueryPlanner.java b/src/simpledb/opt/HeuristicQueryPlanner.java
deleted file mode 100644
index fec17b8..0000000
--- a/src/simpledb/opt/HeuristicQueryPlanner.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package simpledb.opt;
-
-import simpledb.tx.Transaction;
-import simpledb.query.*;
-import simpledb.opt.TablePlanner;
-import simpledb.parse.QueryData;
-import simpledb.planner.QueryPlanner;
-import java.util.*;
-
-/**
- * A query planner that optimizes using a heuristic-based algorithm.
- * @author Edward Sciore
- */
-public class HeuristicQueryPlanner implements QueryPlanner {
-   private Collection<TablePlanner> tableplanners = new ArrayList<TablePlanner>();
-   
-   /**
-    * Creates an optimized left-deep query plan using the following
-    * heuristics.
-    * H1. Choose the smallest table (considering selection predicates)
-    * to be first in the join order.
-    * H2. Add the table to the join order which
-    * results in the smallest output.
-    */
-   public Plan createPlan(QueryData data, Transaction tx) {
-      
-      // Step 1:  Create a TablePlanner object for each mentioned table
-      for (String tblname : data.tables()) {
-         TablePlanner tp = new TablePlanner(tblname, data.pred(), tx);
-         tableplanners.add(tp);
-      }
-      
-      // Step 2:  Choose the lowest-size plan to begin the join order
-      Plan currentplan = getLowestSelectPlan();
-      
-      // Step 3:  Repeatedly add a plan to the join order
-      while (!tableplanners.isEmpty()) {
-         Plan p = getLowestJoinPlan(currentplan);
-         if (p != null)
-            currentplan = p;
-         else  // no applicable join
-            currentplan = getLowestProductPlan(currentplan);
-      }
-      
-      // Step 4.  Project on the field names and return
-      return new ProjectPlan(currentplan, data.fields());
-   }
-   
-   private Plan getLowestSelectPlan() {
-      TablePlanner besttp = null;
-      Plan bestplan = null;
-      for (TablePlanner tp : tableplanners) {
-         Plan plan = tp.makeSelectPlan();
-         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
-            besttp = tp;
-            bestplan = plan;
-         }
-      }
-      tableplanners.remove(besttp);
-      return bestplan;
-   }
-   
-   private Plan getLowestJoinPlan(Plan current) {
-      TablePlanner besttp = null;
-      Plan bestplan = null;
-      for (TablePlanner tp : tableplanners) {
-         Plan plan = tp.makeJoinPlan(current);
-         if (plan != null && (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput())) {
-            besttp = tp;
-            bestplan = plan;
-         }
-      }
-      if (bestplan != null)
-         tableplanners.remove(besttp);
-      return bestplan;
-   }
-   
-   private Plan getLowestProductPlan(Plan current) {
-      TablePlanner besttp = null;
-      Plan bestplan = null;
-      for (TablePlanner tp : tableplanners) {
-         Plan plan = tp.makeProductPlan(current);
-         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
-            besttp = tp;
-            bestplan = plan;
-         }
-      }
-      tableplanners.remove(besttp);
-      return bestplan;
-   }
-}
diff --git a/src/simpledb/opt/TablePlanner.class b/src/simpledb/opt/TablePlanner.class
deleted file mode 100644
index 5edcc24..0000000
Binary files a/src/simpledb/opt/TablePlanner.class and /dev/null differ
diff --git a/src/simpledb/opt/TablePlanner.java b/src/simpledb/opt/TablePlanner.java
deleted file mode 100644
index b3b8da1..0000000
--- a/src/simpledb/opt/TablePlanner.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package simpledb.opt;
-
-import simpledb.tx.Transaction;
-import simpledb.record.Schema;
-import simpledb.query.*;
-import simpledb.index.query.*;
-import simpledb.metadata.IndexInfo;
-import simpledb.multibuffer.MultiBufferProductPlan;
-import simpledb.server.SimpleDB;
-import java.util.Map;
-
-/**
- * This class contains methods for planning a single table.
- * @author Edward Sciore
- */
-class TablePlanner {
-   private TablePlan myplan;
-   private Predicate mypred;
-   private Schema myschema;
-   private Map<String,IndexInfo> indexes;
-   private Transaction tx;
-   
-   /**
-    * Creates a new table planner.
-    * The specified predicate applies to the entire query.
-    * The table planner is responsible for determining
-    * which portion of the predicate is useful to the table,
-    * and when indexes are useful.
-    * @param tblname the name of the table
-    * @param mypred the query predicate
-    * @param tx the calling transaction
-    */
-   public TablePlanner(String tblname, Predicate mypred, Transaction tx) {
-      this.mypred  = mypred;
-      this.tx  = tx;
-      myplan   = new TablePlan(tblname, tx);
-      myschema = myplan.schema();
-      indexes  = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
-   }
-   
-   /**
-    * Constructs a select plan for the table.
-    * The plan will use an indexselect, if possible.
-    * @return a select plan for the table.
-    */
-   public Plan makeSelectPlan() {
-      Plan p = makeIndexSelect();
-      if (p == null)
-         p = myplan;
-      return addSelectPred(p);
-   }
-   
-   /**
-    * Constructs a join plan of the specified plan
-    * and the table.  The plan will use an indexjoin, if possible.
-    * (Which means that if an indexselect is also possible,
-    * the indexjoin operator takes precedence.)
-    * The method returns null if no join is possible.
-    * @param current the specified plan
-    * @return a join plan of the plan and this table
-    */
-   public Plan makeJoinPlan(Plan current) {
-      Schema currsch = current.schema();
-      Predicate joinpred = mypred.joinPred(myschema, currsch);
-      if (joinpred == null)
-         return null;
-      Plan p = makeIndexJoin(current, currsch);
-      if (p == null)
-         p = makeProductJoin(current, currsch);
-      return p;
-   }
-   
-   /**
-    * Constructs a product plan of the specified plan and
-    * this table.
-    * @param current the specified plan
-    * @return a product plan of the specified plan and this table
-    */
-   public Plan makeProductPlan(Plan current) {
-      Plan p = addSelectPred(myplan);
-      return new MultiBufferProductPlan(current, p, tx);
-   }
-   
-   private Plan makeIndexSelect() {
-      for (String fldname : indexes.keySet()) {
-         Constant val = mypred.equatesWithConstant(fldname);
-         if (val != null) {
-            IndexInfo ii = indexes.get(fldname);
-            return new IndexSelectPlan(myplan, ii, val, tx);
-         }
-      }
-      return null;
-   }
-   
-   private Plan makeIndexJoin(Plan current, Schema currsch) {
-      for (String fldname : indexes.keySet()) {
-         String outerfield = mypred.equatesWithField(fldname);
-         if (outerfield != null && currsch.hasField(outerfield)) {
-            IndexInfo ii = indexes.get(fldname);
-            Plan p = new IndexJoinPlan(current, myplan, ii, outerfield, tx);
-            p = addSelectPred(p);
-            return addJoinPred(p, currsch);
-         }
-      }
-      return null;
-   }
-   
-   private Plan makeProductJoin(Plan current, Schema currsch) {
-      Plan p = makeProductPlan(current);
-      return addJoinPred(p, currsch);
-   }
-   
-   private Plan addSelectPred(Plan p) {
-      Predicate selectpred = mypred.selectPred(myschema);
-      if (selectpred != null)
-         return new SelectPlan(p, selectpred);
-      else
-         return p;
-   }
-   
-   private Plan addJoinPred(Plan p, Schema currsch) {
-      Predicate joinpred = mypred.joinPred(currsch, myschema);
-      if (joinpred != null)
-         return new SelectPlan(p, joinpred);
-      else
-         return p;
-   }
-}
diff --git a/src/simpledb/parse/BadSyntaxException.class b/src/simpledb/parse/BadSyntaxException.class
deleted file mode 100644
index 870ef78..0000000
Binary files a/src/simpledb/parse/BadSyntaxException.class and /dev/null differ
diff --git a/src/simpledb/parse/BadSyntaxException.java b/src/simpledb/parse/BadSyntaxException.java
deleted file mode 100644
index 8abef7d..0000000
--- a/src/simpledb/parse/BadSyntaxException.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package simpledb.parse;
-
-/**
- * A runtime exception indicating that the submitted query
- * has incorrect syntax.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-public class BadSyntaxException extends RuntimeException {
-   public BadSyntaxException() {
-   }
-}
diff --git a/src/simpledb/parse/CreateIndexData.class b/src/simpledb/parse/CreateIndexData.class
deleted file mode 100644
index 65fc086..0000000
Binary files a/src/simpledb/parse/CreateIndexData.class and /dev/null differ
diff --git a/src/simpledb/parse/CreateIndexData.java b/src/simpledb/parse/CreateIndexData.java
deleted file mode 100644
index e2de0dd..0000000
--- a/src/simpledb/parse/CreateIndexData.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package simpledb.parse;
-
-/**
- * The parser for the <i>create index</i> statement.
- * @author Edward Sciore
- */
-public class CreateIndexData {
-   private String idxname, tblname, fldname;
-   
-   /**
-    * Saves the table and field names of the specified index.
-    */
-   public CreateIndexData(String idxname, String tblname, String fldname) {
-      this.idxname = idxname;
-      this.tblname = tblname;
-      this.fldname = fldname;
-   }
-   
-   /**
-    * Returns the name of the index.
-    * @return the name of the index
-    */
-   public String indexName() {
-      return idxname;
-   }
-   
-   /**
-    * Returns the name of the indexed table.
-    * @return the name of the indexed table
-    */
-   public String tableName() {
-      return tblname;
-   }
-   
-   /**
-    * Returns the name of the indexed field.
-    * @return the name of the indexed field
-    */
-   public String fieldName() {
-      return fldname;
-   }
-}
-
diff --git a/src/simpledb/parse/CreateTableData.class b/src/simpledb/parse/CreateTableData.class
deleted file mode 100644
index 83a8e40..0000000
Binary files a/src/simpledb/parse/CreateTableData.class and /dev/null differ
diff --git a/src/simpledb/parse/CreateTableData.java b/src/simpledb/parse/CreateTableData.java
deleted file mode 100644
index 35fa0f2..0000000
--- a/src/simpledb/parse/CreateTableData.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package simpledb.parse;
-
-import simpledb.record.Schema;
-
-/**
- * Data for the SQL <i>create table</i> statement.
- * @author Edward Sciore
- */
-public class CreateTableData {
-   private String tblname;
-   private Schema sch;
-   
-   /**
-    * Saves the table name and schema.
-    */
-   public CreateTableData(String tblname, Schema sch) {
-      this.tblname = tblname;
-      this.sch = sch;
-   }
-   
-   /**
-    * Returns the name of the new table.
-    * @return the name of the new table
-    */
-   public String tableName() {
-      return tblname;
-   }
-   
-   /**
-    * Returns the schema of the new table.
-    * @return the schema of the new table
-    */
-   public Schema newSchema() {
-      return sch;
-   }
-}
-
diff --git a/src/simpledb/parse/CreateViewData.class b/src/simpledb/parse/CreateViewData.class
deleted file mode 100644
index 1314087..0000000
Binary files a/src/simpledb/parse/CreateViewData.class and /dev/null differ
diff --git a/src/simpledb/parse/CreateViewData.java b/src/simpledb/parse/CreateViewData.java
deleted file mode 100644
index 2443d98..0000000
--- a/src/simpledb/parse/CreateViewData.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package simpledb.parse;
-
-/**
- * Data for the SQL <i>create view</i> statement.
- * @author Edward Sciore
- */
-public class CreateViewData {
-   private String viewname;
-   private QueryData qrydata;
-   
-   /**
-    * Saves the view name and its definition.
-    */
-   public CreateViewData(String viewname, QueryData qrydata) {
-      this.viewname = viewname;
-      this.qrydata = qrydata;
-   }
-   
-   /**
-    * Returns the name of the new view.
-    * @return the name of the new view
-    */
-   public String viewName() {
-      return viewname;
-   }
-   
-   /**
-    * Returns the definition of the new view.
-    * @return the definition of the new view
-    */
-   public String viewDef() {
-      return qrydata.toString();
-   }
-}
diff --git a/src/simpledb/parse/DeleteData.class b/src/simpledb/parse/DeleteData.class
deleted file mode 100644
index bc5a3e7..0000000
Binary files a/src/simpledb/parse/DeleteData.class and /dev/null differ
diff --git a/src/simpledb/parse/DeleteData.java b/src/simpledb/parse/DeleteData.java
deleted file mode 100644
index db97040..0000000
--- a/src/simpledb/parse/DeleteData.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package simpledb.parse;
-
-import simpledb.query.*;
-
-/**
- * Data for the SQL <i>delete</i> statement.
- * @author Edward Sciore
- */
-public class DeleteData {
-   private String tblname;
-   private Predicate pred;
-   
-   /**
-    * Saves the table name and predicate.
-    */
-   public DeleteData(String tblname, Predicate pred) {
-      this.tblname = tblname;
-      this.pred = pred;
-   }
-   
-   /**
-    * Returns the name of the affected table.
-    * @return the name of the affected table
-    */
-   public String tableName() {
-      return tblname;
-   }
-   
-   /**
-    * Returns the predicate that describes which
-    * records should be deleted.
-    * @return the deletion predicate
-    */
-   public Predicate pred() {
-      return pred;
-   }
-}
-
diff --git a/src/simpledb/parse/InsertData.class b/src/simpledb/parse/InsertData.class
deleted file mode 100644
index 5d2c677..0000000
Binary files a/src/simpledb/parse/InsertData.class and /dev/null differ
diff --git a/src/simpledb/parse/InsertData.java b/src/simpledb/parse/InsertData.java
deleted file mode 100644
index 51408a1..0000000
--- a/src/simpledb/parse/InsertData.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package simpledb.parse;
-
-import simpledb.query.Constant;
-import java.util.*;
-
-/**
- * Data for the SQL <i>insert</i> statement.
- * @author Edward Sciore
- */
-public class InsertData {
-   private String tblname;
-   private List<String> flds;
-   private List<Constant> vals;
-   
-   /**
-    * Saves the table name and the field and value lists.
-    */
-   public InsertData(String tblname, List<String> flds, List<Constant> vals) {
-      this.tblname = tblname;
-      this.flds = flds;
-      this.vals = vals;
-   }
-   
-   /**
-    * Returns the name of the affected table.
-    * @return the name of the affected table
-    */
-   public String tableName() {
-      return tblname;
-   }
-   
-   /**
-    * Returns a list of fields for which
-    * values will be specified in the new record.
-    * @return a list of field names
-    */
-   public List<String> fields() {
-      return flds;
-   }
-   
-   /**
-    * Returns a list of values for the specified fields.
-    * There is a one-one correspondence between this
-    * list of values and the list of fields.
-    * @return a list of Constant values.
-    */
-   public List<Constant> vals() {
-      return vals;
-   }
-}
-
diff --git a/src/simpledb/parse/Lexer.class b/src/simpledb/parse/Lexer.class
deleted file mode 100644
index 34d7e0e..0000000
Binary files a/src/simpledb/parse/Lexer.class and /dev/null differ
diff --git a/src/simpledb/parse/Lexer.java b/src/simpledb/parse/Lexer.java
deleted file mode 100644
index 0ae4404..0000000
--- a/src/simpledb/parse/Lexer.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package simpledb.parse;
-
-import java.util.*;
-import java.io.*;
-
-/**
- * The lexical analyzer.
- * @author Edward Sciore
- */
-public class Lexer {
-   private Collection<String> keywords;
-   private StreamTokenizer tok;
-   
-   /**
-    * Creates a new lexical analyzer for SQL statement s.
-    * @param s the SQL statement
-    */
-   public Lexer(String s) {
-      initKeywords();
-      tok = new StreamTokenizer(new StringReader(s));
-      tok.ordinaryChar('.');
-      tok.lowerCaseMode(true); //ids and keywords are converted
-      nextToken();
-   }
-   
-//Methods to check the status of the current token
-   
-   /**
-    * Returns true if the current token is
-    * the specified delimiter character.
-    * @param d a character denoting the delimiter
-    * @return true if the delimiter is the current token
-    */
-   public boolean matchDelim(char d) {
-      return d == (char)tok.ttype;
-   }
-   
-   /**
-    * Returns true if the current token is an integer.
-    * @return true if the current token is an integer
-    */
-   public boolean matchIntConstant() {
-      return tok.ttype == StreamTokenizer.TT_NUMBER;
-   }
-   
-   /**
-    * Returns true if the current token is a string.
-    * @return true if the current token is a string
-    */
-   public boolean matchStringConstant() {
-      return '\'' == (char)tok.ttype;
-   }
-   
-   /**
-    * Returns true if the current token is the specified keyword.
-    * @param w the keyword string
-    * @return true if that keyword is the current token
-    */
-   public boolean matchKeyword(String w) {
-      return tok.ttype == StreamTokenizer.TT_WORD && tok.sval.equals(w);
-   }
-   
-   /**
-    * Returns true if the current token is a legal identifier.
-    * @return true if the current token is an identifier
-    */
-   public boolean matchId() {
-      return  tok.ttype==StreamTokenizer.TT_WORD && !keywords.contains(tok.sval);
-   }
-   
-//Methods to "eat" the current token
-   
-   /**
-    * Throws an exception if the current token is not the
-    * specified delimiter. 
-    * Otherwise, moves to the next token.
-    * @param d a character denoting the delimiter
-    */
-   public void eatDelim(char d) {
-      if (!matchDelim(d))
-         throw new BadSyntaxException();
-      nextToken();
-   }
-   
-   /**
-    * Throws an exception if the current token is not 
-    * an integer. 
-    * Otherwise, returns that integer and moves to the next token.
-    * @return the integer value of the current token
-    */
-   public int eatIntConstant() {
-      if (!matchIntConstant())
-         throw new BadSyntaxException();
-      int i = (int) tok.nval;
-      nextToken();
-      return i;
-   }
-   
-   /**
-    * Throws an exception if the current token is not 
-    * a string. 
-    * Otherwise, returns that string and moves to the next token.
-    * @return the string value of the current token
-    */
-   public String eatStringConstant() {
-      if (!matchStringConstant())
-         throw new BadSyntaxException();
-      String s = tok.sval; //constants are not converted to lower case
-      nextToken();
-      return s;
-   }
-   
-   /**
-    * Throws an exception if the current token is not the
-    * specified keyword. 
-    * Otherwise, moves to the next token.
-    * @param w the keyword string
-    */
-   public void eatKeyword(String w) {
-      if (!matchKeyword(w))
-         throw new BadSyntaxException();
-      nextToken();
-   }
-   
-   /**
-    * Throws an exception if the current token is not 
-    * an identifier. 
-    * Otherwise, returns the identifier string 
-    * and moves to the next token.
-    * @return the string value of the current token
-    */
-   public String eatId() {
-      if (!matchId())
-         throw new BadSyntaxException();
-      String s = tok.sval;
-      nextToken();
-      return s;
-   }
-   
-   private void nextToken() {
-      try {
-         tok.nextToken();
-      }
-      catch(IOException e) {
-         throw new BadSyntaxException();
-      }
-   }
-   
-   private void initKeywords() {
-      keywords = Arrays.asList("select", "from", "where", "and",
-                               "insert", "into", "values", "delete", "update", "set", 
-                               "create", "table", "int", "varchar", "view", "as", "index", "on");
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/parse/ModifyData.class b/src/simpledb/parse/ModifyData.class
deleted file mode 100644
index 38a50ff..0000000
Binary files a/src/simpledb/parse/ModifyData.class and /dev/null differ
diff --git a/src/simpledb/parse/ModifyData.java b/src/simpledb/parse/ModifyData.java
deleted file mode 100644
index 88295d8..0000000
--- a/src/simpledb/parse/ModifyData.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package simpledb.parse;
-
-import simpledb.query.*;
-
-/**
- * Data for the SQL <i>update</i> statement.
- * @author Edward Sciore
- */
-public class ModifyData {
-   private String tblname;
-   private String fldname;
-   private Expression newval;
-   private Predicate pred;
-   
-   /**
-    * Saves the table name, the modified field and its new value, and the predicate.
-    */
-   public ModifyData(String tblname, String fldname, Expression newval, Predicate pred) {
-      this.tblname = tblname;
-      this.fldname = fldname;
-      this.newval = newval;
-      this.pred = pred;
-   }
-   
-   /**
-    * Returns the name of the affected table.
-    * @return the name of the affected table
-    */
-   public String tableName() {
-      return tblname;
-   }
-   
-   /**
-    * Returns the field whose values will be modified
-    * @return the name of the target field
-    */
-   public String targetField() {
-      return fldname;
-   }
-   
-   /**
-    * Returns an expression.
-    * Evaluating this expression for a record produces
-    * the value that will be stored in the record's target field.
-    * @return the target expression
-    */
-   public Expression newValue() {
-      return newval;
-   }
-   
-   /**
-    * Returns the predicate that describes which
-    * records should be modified.
-    * @return the modification predicate
-    */
-   public Predicate pred() {
-      return pred;
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/parse/Parser.class b/src/simpledb/parse/Parser.class
deleted file mode 100644
index 462b26b..0000000
Binary files a/src/simpledb/parse/Parser.class and /dev/null differ
diff --git a/src/simpledb/parse/Parser.java b/src/simpledb/parse/Parser.java
deleted file mode 100644
index cf52092..0000000
--- a/src/simpledb/parse/Parser.java
+++ /dev/null
@@ -1,245 +0,0 @@
-package simpledb.parse;
-
-import java.util.*;
-import simpledb.query.*;
-import simpledb.record.Schema;
-
-/**
- * The SimpleDB parser.
- * @author Edward Sciore
- */
-public class Parser {
-   private Lexer lex;
-   
-   public Parser(String s) {
-      lex = new Lexer(s);
-   }
-   
-// Methods for parsing predicates, terms, expressions, constants, and fields
-   
-   public String field() {
-      return lex.eatId();
-   }
-   
-   public Constant constant() {
-      if (lex.matchStringConstant())
-         return new StringConstant(lex.eatStringConstant());
-      else
-         return new IntConstant(lex.eatIntConstant());
-   }
-   
-   public Expression expression() {
-      if (lex.matchId())
-         return new FieldNameExpression(field());
-      else
-         return new ConstantExpression(constant());
-   }
-   
-   public Term term() {
-      Expression lhs = expression();
-      lex.eatDelim('=');
-      Expression rhs = expression();
-      return new Term(lhs, rhs);
-   }
-   
-   public Predicate predicate() {
-      Predicate pred = new Predicate(term());
-      if (lex.matchKeyword("and")) {
-         lex.eatKeyword("and");
-         pred.conjoinWith(predicate());
-      }
-      return pred;
-   }
-   
-// Methods for parsing queries
-   
-   public QueryData query() {
-      lex.eatKeyword("select");
-      Collection<String> fields = selectList();
-      lex.eatKeyword("from");
-      Collection<String> tables = tableList();
-      Predicate pred = new Predicate();
-      if (lex.matchKeyword("where")) {
-         lex.eatKeyword("where");
-         pred = predicate();
-      }
-      return new QueryData(fields, tables, pred);
-   }
-   
-   private Collection<String> selectList() {
-      Collection<String> L = new ArrayList<String>();
-      L.add(field());
-      if (lex.matchDelim(',')) {
-         lex.eatDelim(',');
-         L.addAll(selectList());
-      }
-      return L;
-   }
-   
-   private Collection<String> tableList() {
-      Collection<String> L = new ArrayList<String>();
-      L.add(lex.eatId());
-      if (lex.matchDelim(',')) {
-         lex.eatDelim(',');
-         L.addAll(tableList());
-      }
-      return L;
-   }
-   
-// Methods for parsing the various update commands
-   
-   public Object updateCmd() {
-      if (lex.matchKeyword("insert"))
-         return insert();
-      else if (lex.matchKeyword("delete"))
-         return delete();
-      else if (lex.matchKeyword("update"))
-         return modify();
-      else
-         return create();
-   }
-   
-   private Object create() {
-      lex.eatKeyword("create");
-      if (lex.matchKeyword("table"))
-         return createTable();
-      else if (lex.matchKeyword("view"))
-         return createView();
-      else
-         return createIndex();
-   }
-   
-// Method for parsing delete commands
-   
-   public DeleteData delete() {
-      lex.eatKeyword("delete");
-      lex.eatKeyword("from");
-      String tblname = lex.eatId();
-      Predicate pred = new Predicate();
-      if (lex.matchKeyword("where")) {
-         lex.eatKeyword("where");
-         pred = predicate();
-      }
-      return new DeleteData(tblname, pred);
-   }
-   
-// Methods for parsing insert commands
-   
-   public InsertData insert() {
-      lex.eatKeyword("insert");
-      lex.eatKeyword("into");
-      String tblname = lex.eatId();
-      lex.eatDelim('(');
-      List<String> flds = fieldList();
-      lex.eatDelim(')');
-      lex.eatKeyword("values");
-      lex.eatDelim('(');
-      List<Constant> vals = constList();
-      lex.eatDelim(')');
-      return new InsertData(tblname, flds, vals);
-   }
-   
-   private List<String> fieldList() {
-      List<String> L = new ArrayList<String>();
-      L.add(field());
-      if (lex.matchDelim(',')) {
-         lex.eatDelim(',');
-         L.addAll(fieldList());
-      }
-      return L;
-   }
-   
-   private List<Constant> constList() {
-      List<Constant> L = new ArrayList<Constant>();
-      L.add(constant());
-      if (lex.matchDelim(',')) {
-         lex.eatDelim(',');
-         L.addAll(constList());
-      }
-      return L;
-   }
-   
-// Method for parsing modify commands
-   
-   public ModifyData modify() {
-      lex.eatKeyword("update");
-      String tblname = lex.eatId();
-      lex.eatKeyword("set");
-      String fldname = field();
-      lex.eatDelim('=');
-      Expression newval = expression();
-      Predicate pred = new Predicate();
-      if (lex.matchKeyword("where")) {
-         lex.eatKeyword("where");
-         pred = predicate();
-      }
-      return new ModifyData(tblname, fldname, newval, pred);
-   }
-   
-// Method for parsing create table commands
-   
-   public CreateTableData createTable() {
-      lex.eatKeyword("table");
-      String tblname = lex.eatId();
-      lex.eatDelim('(');
-      Schema sch = fieldDefs();
-      lex.eatDelim(')');
-      return new CreateTableData(tblname, sch);
-   }
-   
-   private Schema fieldDefs() {
-      Schema schema = fieldDef();
-      if (lex.matchDelim(',')) {
-         lex.eatDelim(',');
-         Schema schema2 = fieldDefs();
-         schema.addAll(schema2);
-      }
-      return schema;
-   }
-   
-   private Schema fieldDef() {
-      String fldname = field();
-      return fieldType(fldname);
-   }
-   
-   private Schema fieldType(String fldname) {
-      Schema schema = new Schema();
-      if (lex.matchKeyword("int")) {
-         lex.eatKeyword("int");
-         schema.addIntField(fldname);
-      }
-      else {
-         lex.eatKeyword("varchar");
-         lex.eatDelim('(');
-         int strLen = lex.eatIntConstant();
-         lex.eatDelim(')');
-         schema.addStringField(fldname, strLen);
-      }
-      return schema;
-   }
-   
-// Method for parsing create view commands
-   
-   public CreateViewData createView() {
-      lex.eatKeyword("view");
-      String viewname = lex.eatId();
-      lex.eatKeyword("as");
-      QueryData qd = query();
-      return new CreateViewData(viewname, qd);
-   }
-   
-   
-//  Method for parsing create index commands
-   
-   public CreateIndexData createIndex() {
-      lex.eatKeyword("index");
-      String idxname = lex.eatId();
-      lex.eatKeyword("on");
-      String tblname = lex.eatId();
-      lex.eatDelim('(');
-      String fldname = field();
-      lex.eatDelim(')');
-      return new CreateIndexData(idxname, tblname, fldname);
-   }
-}
-
diff --git a/src/simpledb/parse/QueryData.class b/src/simpledb/parse/QueryData.class
deleted file mode 100644
index d7f8cef..0000000
Binary files a/src/simpledb/parse/QueryData.class and /dev/null differ
diff --git a/src/simpledb/parse/QueryData.java b/src/simpledb/parse/QueryData.java
deleted file mode 100644
index 898c42b..0000000
--- a/src/simpledb/parse/QueryData.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package simpledb.parse;
-
-import simpledb.query.*;
-import java.util.*;
-
-/**
- * Data for the SQL <i>select</i> statement.
- * @author Edward Sciore
- */
-public class QueryData {
-   private Collection<String> fields;
-   private Collection<String> tables;
-   private Predicate pred;
-   
-   /**
-    * Saves the field and table list and predicate.
-    */
-   public QueryData(Collection<String> fields, Collection<String> tables, Predicate pred) {
-      this.fields = fields;
-      this.tables = tables;
-      this.pred = pred;
-   }
-   
-   /**
-    * Returns the fields mentioned in the select clause.
-    * @return a collection of field names
-    */
-   public Collection<String> fields() {
-      return fields;
-   }
-   
-   /**
-    * Returns the tables mentioned in the from clause.
-    * @return a collection of table names
-    */
-   public Collection<String> tables() {
-      return tables;
-   }
-   
-   /**
-    * Returns the predicate that describes which
-    * records should be in the output table.
-    * @return the query predicate
-    */
-   public Predicate pred() {
-      return pred;
-   }
-   
-   public String toString() {
-      String result = "select ";
-      for (String fldname : fields)
-         result += fldname + ", ";
-      result = result.substring(0, result.length()-2); //remove final comma
-      result += " from ";
-      for (String tblname : tables)
-         result += tblname + ", ";
-      result = result.substring(0, result.length()-2); //remove final comma
-      String predstring = pred.toString();
-      if (!predstring.equals(""))
-         result += " where " + predstring;
-      return result;
-   }
-}
diff --git a/src/simpledb/planner/BasicQueryPlanner.class b/src/simpledb/planner/BasicQueryPlanner.class
deleted file mode 100644
index 524b07d..0000000
Binary files a/src/simpledb/planner/BasicQueryPlanner.class and /dev/null differ
diff --git a/src/simpledb/planner/BasicQueryPlanner.java b/src/simpledb/planner/BasicQueryPlanner.java
deleted file mode 100644
index dada735..0000000
--- a/src/simpledb/planner/BasicQueryPlanner.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package simpledb.planner;
-
-import simpledb.tx.Transaction;
-import simpledb.query.*;
-import simpledb.parse.*;
-import simpledb.server.SimpleDB;
-import java.util.*;
-
-/**
- * The simplest, most naive query planner possible.
- * @author Edward Sciore
- */
-public class BasicQueryPlanner implements QueryPlanner {
-   
-   /**
-    * Creates a query plan as follows.  It first takes
-    * the product of all tables and views; it then selects on the predicate;
-    * and finally it projects on the field list. 
-    */
-   public Plan createPlan(QueryData data, Transaction tx) {
-      //Step 1: Create a plan for each mentioned table or view
-      List<Plan> plans = new ArrayList<Plan>();
-      for (String tblname : data.tables()) {
-         String viewdef = SimpleDB.mdMgr().getViewDef(tblname, tx);
-         if (viewdef != null)
-            plans.add(SimpleDB.planner().createQueryPlan(viewdef, tx));
-         else
-            plans.add(new TablePlan(tblname, tx));
-      }
-      
-      //Step 2: Create the product of all table plans
-      Plan p = plans.remove(0);
-      for (Plan nextplan : plans)
-         p = new ProductPlan(p, nextplan);
-      
-      //Step 3: Add a selection plan for the predicate
-      p = new SelectPlan(p, data.pred());
-      
-      //Step 4: Project on the field names
-      p = new ProjectPlan(p, data.fields());
-      return p;
-   }
-}
diff --git a/src/simpledb/planner/BasicUpdatePlanner.class b/src/simpledb/planner/BasicUpdatePlanner.class
deleted file mode 100644
index cb9368b..0000000
Binary files a/src/simpledb/planner/BasicUpdatePlanner.class and /dev/null differ
diff --git a/src/simpledb/planner/BasicUpdatePlanner.java b/src/simpledb/planner/BasicUpdatePlanner.java
deleted file mode 100644
index c2b19da..0000000
--- a/src/simpledb/planner/BasicUpdatePlanner.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package simpledb.planner;
-
-import java.util.Iterator;
-import simpledb.server.SimpleDB;
-import simpledb.tx.Transaction;
-import simpledb.parse.*;
-import simpledb.query.*;
-
-/**
- * The basic planner for SQL update statements.
- * @author sciore
- */
-public class BasicUpdatePlanner implements UpdatePlanner {
-   
-   public int executeDelete(DeleteData data, Transaction tx) {
-      Plan p = new TablePlan(data.tableName(), tx);
-      p = new SelectPlan(p, data.pred());
-      UpdateScan us = (UpdateScan) p.open();
-      int count = 0;
-      while(us.next()) {
-         us.delete();
-         count++;
-      }
-      us.close();
-      return count;
-   }
-   
-   public int executeModify(ModifyData data, Transaction tx) {
-      Plan p = new TablePlan(data.tableName(), tx);
-      p = new SelectPlan(p, data.pred());
-      UpdateScan us = (UpdateScan) p.open();
-      int count = 0;
-      while(us.next()) {
-         Constant val = data.newValue().evaluate(us);
-         us.setVal(data.targetField(), val);
-         count++;
-      }
-      us.close();
-      return count;
-   }
-   
-   public int executeInsert(InsertData data, Transaction tx) {
-      Plan p = new TablePlan(data.tableName(), tx);
-      UpdateScan us = (UpdateScan) p.open();
-      us.insert();
-      Iterator<Constant> iter = data.vals().iterator();
-      for (String fldname : data.fields()) {
-         Constant val = iter.next();
-         us.setVal(fldname, val);
-      }
-      us.close();
-      return 1;
-   }
-   
-   public int executeCreateTable(CreateTableData data, Transaction tx) {
-      SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
-      return 0;
-   }
-   
-   public int executeCreateView(CreateViewData data, Transaction tx) {
-      SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
-      return 0;
-   }
-   public int executeCreateIndex(CreateIndexData data, Transaction tx) {
-      SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
-      return 0;  
-   }
-}
diff --git a/src/simpledb/planner/Planner.class b/src/simpledb/planner/Planner.class
deleted file mode 100644
index 3c0e2cb..0000000
Binary files a/src/simpledb/planner/Planner.class and /dev/null differ
diff --git a/src/simpledb/planner/Planner.java b/src/simpledb/planner/Planner.java
deleted file mode 100644
index f272fdd..0000000
--- a/src/simpledb/planner/Planner.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package simpledb.planner;
-
-import simpledb.tx.Transaction;
-import simpledb.parse.*;
-import simpledb.query.*;
-
-/**
- * The object that executes SQL statements.
- * @author sciore
- */
-public class Planner {
-   private QueryPlanner qplanner;
-   private UpdatePlanner uplanner;
-   
-   public Planner(QueryPlanner qplanner, UpdatePlanner uplanner) {
-      this.qplanner = qplanner;
-      this.uplanner = uplanner;
-   }
-   
-   /**
-    * Creates a plan for an SQL select statement, using the supplied planner.
-    * @param qry the SQL query string
-    * @param tx the transaction
-    * @return the scan corresponding to the query plan
-    */
-   public Plan createQueryPlan(String qry, Transaction tx) {
-      Parser parser = new Parser(qry);
-      QueryData data = parser.query();
-      return qplanner.createPlan(data, tx);
-   }
-   
-   /**
-    * Executes an SQL insert, delete, modify, or
-    * create statement.
-    * The method dispatches to the appropriate method of the
-    * supplied update planner,
-    * depending on what the parser returns.
-    * @param cmd the SQL update string
-    * @param tx the transaction
-    * @return an integer denoting the number of affected records
-    */
-   public int executeUpdate(String cmd, Transaction tx) {
-      Parser parser = new Parser(cmd);
-      Object obj = parser.updateCmd();
-      if (obj instanceof InsertData)
-         return uplanner.executeInsert((InsertData)obj, tx);
-      else if (obj instanceof DeleteData)
-         return uplanner.executeDelete((DeleteData)obj, tx);
-      else if (obj instanceof ModifyData)
-         return uplanner.executeModify((ModifyData)obj, tx);
-      else if (obj instanceof CreateTableData)
-         return uplanner.executeCreateTable((CreateTableData)obj, tx);
-      else if (obj instanceof CreateViewData)
-         return uplanner.executeCreateView((CreateViewData)obj, tx);
-      else if (obj instanceof CreateIndexData)
-         return uplanner.executeCreateIndex((CreateIndexData)obj, tx);
-      else
-         return 0;
-   }
-}
diff --git a/src/simpledb/planner/QueryPlanner.class b/src/simpledb/planner/QueryPlanner.class
deleted file mode 100644
index 66f6e28..0000000
Binary files a/src/simpledb/planner/QueryPlanner.class and /dev/null differ
diff --git a/src/simpledb/planner/QueryPlanner.java b/src/simpledb/planner/QueryPlanner.java
deleted file mode 100644
index b4f24d9..0000000
--- a/src/simpledb/planner/QueryPlanner.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package simpledb.planner;
-
-import simpledb.tx.Transaction;
-import simpledb.query.Plan;
-import simpledb.parse.QueryData;
-
-/**
- * The interface implemented by planners for 
- * the SQL select statement.
- * @author Edward Sciore
- *
- */
-public interface QueryPlanner {
-   
-   /**
-    * Creates a plan for the parsed query.
-    * @param data the parsed representation of the query
-    * @param tx the calling transaction
-    * @return a plan for that query
-    */
-   public Plan createPlan(QueryData data, Transaction tx);
-}
diff --git a/src/simpledb/planner/UpdatePlanner.class b/src/simpledb/planner/UpdatePlanner.class
deleted file mode 100644
index c660368..0000000
Binary files a/src/simpledb/planner/UpdatePlanner.class and /dev/null differ
diff --git a/src/simpledb/planner/UpdatePlanner.java b/src/simpledb/planner/UpdatePlanner.java
deleted file mode 100644
index 3e7439d..0000000
--- a/src/simpledb/planner/UpdatePlanner.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package simpledb.planner;
-
-import simpledb.tx.Transaction;
-import simpledb.parse.*;
-
-/**
- * The interface implemented by the planners
- * for SQL insert, delete, and modify statements.
- * @author Edward Sciore
- */
-public interface UpdatePlanner {
-   
-   /**
-    * Executes the specified insert statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the insert statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeInsert(InsertData data, Transaction tx);
-   
-   /**
-    * Executes the specified delete statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the delete statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeDelete(DeleteData data, Transaction tx);
-   
-   /**
-    * Executes the specified modify statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the modify statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeModify(ModifyData data, Transaction tx);
-   
-   /**
-    * Executes the specified create table statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the create table statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeCreateTable(CreateTableData data, Transaction tx);
-   
-   /**
-    * Executes the specified create view statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the create view statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeCreateView(CreateViewData data, Transaction tx);
-   
-   /**
-    * Executes the specified create index statement, and
-    * returns the number of affected records.
-    * @param data the parsed representation of the create index statement
-    * @param tx the calling transaction
-    * @return the number of affected records
-    */
-   public int executeCreateIndex(CreateIndexData data, Transaction tx);
-}
diff --git a/src/simpledb/query/Constant.class b/src/simpledb/query/Constant.class
deleted file mode 100644
index c82d332..0000000
Binary files a/src/simpledb/query/Constant.class and /dev/null differ
diff --git a/src/simpledb/query/Constant.java b/src/simpledb/query/Constant.java
deleted file mode 100644
index c15985b..0000000
--- a/src/simpledb/query/Constant.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package simpledb.query;
-
-/**
- * The interface that denotes values stored in the database.
- * @author Edward Sciore
- */
-public interface Constant extends Comparable<Constant> {
-   
-   /**
-    * Returns the Java object corresponding to this constant.
-    * @return the Java value of the constant
-    */
-   public Object  asJavaVal();
-}
diff --git a/src/simpledb/query/ConstantExpression.class b/src/simpledb/query/ConstantExpression.class
deleted file mode 100644
index c59b6cb..0000000
Binary files a/src/simpledb/query/ConstantExpression.class and /dev/null differ
diff --git a/src/simpledb/query/ConstantExpression.java b/src/simpledb/query/ConstantExpression.java
deleted file mode 100644
index 28df6d1..0000000
--- a/src/simpledb/query/ConstantExpression.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/**
- * An expression consisting entirely of a single constant.
- * @author Edward Sciore
- *
- */
-public class ConstantExpression implements Expression {
-   private Constant val;
-   
-   /**
-    * Creates a new expression by wrapping a constant.
-    * @param c the constant
-    */
-   public ConstantExpression(Constant c) {
-      val = c;
-   }
-   
-   /**
-    * Returns true.
-    * @see simpledb.query.Expression#isConstant()
-    */
-   public boolean isConstant() {
-      return true;
-   }
-   
-   /**
-    * Returns false.
-    * @see simpledb.query.Expression#isFieldName()
-    */
-   public boolean isFieldName() {
-      return false;
-   }
-   
-   /**
-    * Unwraps the constant and returns it.
-    * @see simpledb.query.Expression#asConstant()
-    */
-   public Constant asConstant() {
-      return val;
-   }
-   
-   /**
-    * This method should never be called.
-    * Throws a ClassCastException.
-    * @see simpledb.query.Expression#asFieldName()
-    */
-   public String asFieldName() {
-      throw new ClassCastException();
-   }
-   
-   /**
-    * Returns the constant, regardless of the scan.
-    * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
-    */
-   public Constant evaluate(Scan s) {
-      return val;
-   }
-   
-   /**
-    * Returns true, because a constant applies to any schema.
-    * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
-    */
-   public boolean appliesTo(Schema sch) {
-      return true;
-   }
-   
-   public String toString() {
-      return val.toString();
-   }
-}
diff --git a/src/simpledb/query/Expression.class b/src/simpledb/query/Expression.class
deleted file mode 100644
index 1645341..0000000
Binary files a/src/simpledb/query/Expression.class and /dev/null differ
diff --git a/src/simpledb/query/Expression.java b/src/simpledb/query/Expression.java
deleted file mode 100644
index a66d5e2..0000000
--- a/src/simpledb/query/Expression.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/**
- * The interface corresponding to SQL expressions.
- * @author Edward Sciore
- *
- */
-public interface Expression {
-   
-   /**
-    * Returns true if the expression is a constant.
-    * @return true if the expression is a constant
-    */
-   public boolean  isConstant();
-   
-   /**
-    * Returns true if the expression is a field reference.
-    * @return true if the expression denotes a field
-    */
-   public boolean  isFieldName();
-   
-   /**
-    * Returns the constant corresponding to a constant expression.
-    * Throws an exception if the expression does not
-    * denote a constant.
-    * @return the expression as a constant
-    */
-   public Constant asConstant();
-   
-   /**
-    * Returns the field name corresponding to a constant expression.
-    * Throws an exception if the expression does not
-    * denote a field.
-    * @return the expression as a field name
-    */
-   public String   asFieldName();
-   
-   /**
-    * Evaluates the expression with respect to the
-    * current record of the specified scan.
-    * @param s the scan
-    * @return the value of the expression, as a Constant
-    */
-   public Constant evaluate(Scan s);
-   
-   /**
-    * Determines if all of the fields mentioned in this expression
-    * are contained in the specified schema.
-    * @param sch the schema
-    * @return true if all fields in the expression are in the schema
-    */
-   public boolean  appliesTo(Schema sch);
-}
diff --git a/src/simpledb/query/FieldNameExpression.class b/src/simpledb/query/FieldNameExpression.class
deleted file mode 100644
index ce19bc4..0000000
Binary files a/src/simpledb/query/FieldNameExpression.class and /dev/null differ
diff --git a/src/simpledb/query/FieldNameExpression.java b/src/simpledb/query/FieldNameExpression.java
deleted file mode 100644
index 65f2310..0000000
--- a/src/simpledb/query/FieldNameExpression.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/**
- * An expression consisting entirely of a single field.
- * @author Edward Sciore
- *
- */
-public class FieldNameExpression implements Expression {
-   private String fldname;
-   
-   /**
-    * Creates a new expression by wrapping a field.
-    * @param fldname the name of the wrapped field
-    */
-   public FieldNameExpression(String fldname) {
-      this.fldname = fldname;
-   }
-   
-   /**
-    * Returns false.
-    * @see simpledb.query.Expression#isConstant()
-    */
-   public boolean isConstant() {
-      return false;
-   }
-   
-   /**
-    * Returns true.
-    * @see simpledb.query.Expression#isFieldName()
-    */
-   public boolean isFieldName() {
-      return true;
-   }
-   
-   /**
-    * This method should never be called.
-    * Throws a ClassCastException.
-    * @see simpledb.query.Expression#asConstant()
-    */
-   public Constant asConstant() {
-      throw new ClassCastException();
-   }
-   
-   /**
-    * Unwraps the field name and returns it.
-    * @see simpledb.query.Expression#asFieldName()
-    */
-   public String asFieldName() {
-      return fldname;
-   }
-   
-   /**
-    * Evaluates the field by getting its value in the scan.
-    * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
-    */
-   public Constant evaluate(Scan s) {
-      return s.getVal(fldname);
-   }
-   
-   /** 
-    * Returns true if the field is in the specified schema.
-    * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
-    */
-   public boolean appliesTo(Schema sch) {
-      return sch.hasField(fldname);
-   }
-   
-   public String toString() {
-      return fldname;
-   }
-}
diff --git a/src/simpledb/query/IntConstant.class b/src/simpledb/query/IntConstant.class
deleted file mode 100644
index 3689f60..0000000
Binary files a/src/simpledb/query/IntConstant.class and /dev/null differ
diff --git a/src/simpledb/query/IntConstant.java b/src/simpledb/query/IntConstant.java
deleted file mode 100644
index c739b57..0000000
--- a/src/simpledb/query/IntConstant.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package simpledb.query;
-
-/**
- * The class that wraps Java ints as database constants.
- * @author Edward Sciore
- */
-public class IntConstant implements Constant {
-   private Integer val;
-   
-   /**
-    * Create a constant by wrapping the specified int.
-    * @param n the int value
-    */
-   public IntConstant(int n) {
-      val = new Integer(n);
-   }
-   
-   /**
-    * Unwraps the Integer and returns it.
-    * @see simpledb.query.Constant#asJavaVal()
-    */
-   public Object asJavaVal() {
-      return val;
-   }
-   
-   public boolean equals(Object obj) {
-      IntConstant ic = (IntConstant) obj;
-      return ic != null && val.equals(ic.val);
-   }
-   
-   public int compareTo(Constant c) {
-      IntConstant ic = (IntConstant) c;
-      return val.compareTo(ic.val);
-   }
-   
-   public int hashCode() {
-      return val.hashCode();
-   }
-   
-   public String toString() {
-      return val.toString();
-   }
-}
diff --git a/src/simpledb/query/Plan.class b/src/simpledb/query/Plan.class
deleted file mode 100644
index ca8bda5..0000000
Binary files a/src/simpledb/query/Plan.class and /dev/null differ
diff --git a/src/simpledb/query/Plan.java b/src/simpledb/query/Plan.java
deleted file mode 100644
index f1e2b24..0000000
--- a/src/simpledb/query/Plan.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/**
- * The interface implemented by each query plan.
- * There is a Plan class for each relational algebra operator.
- * @author Edward Sciore
- *
- */
-public interface Plan {
-   
-   /**
-    * Opens a scan corresponding to this plan.
-    * The scan will be positioned before its first record.
-    * @return a scan
-    */
-   public Scan   open();
-   
-   /**
-    * Returns an estimate of the number of block accesses
-    * that will occur when the scan is read to completion.
-    * @return the estimated number of block accesses
-    */
-   public int    blocksAccessed();
-   
-   /**
-    * Returns an estimate of the number of records
-    * in the query's output table.
-    * @return the estimated number of output records
-    */
-   public int    recordsOutput();
-   
-   /**
-    * Returns an estimate of the number of distinct values
-    * for the specified field in the query's output table.
-    * @param fldname the name of a field
-    * @return the estimated number of distinct field values in the output
-    */
-   public int    distinctValues(String fldname);
-   
-   /**
-    * Returns the schema of the query.
-    * @return the query's schema
-    */
-   public Schema schema();
-}
diff --git a/src/simpledb/query/Predicate.class b/src/simpledb/query/Predicate.class
deleted file mode 100644
index 4ea5bf6..0000000
Binary files a/src/simpledb/query/Predicate.class and /dev/null differ
diff --git a/src/simpledb/query/Predicate.java b/src/simpledb/query/Predicate.java
deleted file mode 100644
index 03f956d..0000000
--- a/src/simpledb/query/Predicate.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-import java.util.*;
-/**
- * A predicate is a Boolean combination of terms.
- * @author Edward Sciore
- *
- */
-public class Predicate {
-   private List<Term> terms = new ArrayList<Term>();
-   
-   /**
-    * Creates an empty predicate, corresponding to "true".
-    */
-   public Predicate() {}
-   
-   /**
-    * Creates a predicate containing a single term.
-    * @param t the term
-    */
-   public Predicate(Term t) {
-      terms.add(t);
-   }
-   
-   /**
-    * Modifies the predicate to be the conjunction of
-    * itself and the specified predicate.
-    * @param pred the other predicate
-    */
-   public void conjoinWith(Predicate pred) {
-      terms.addAll(pred.terms);
-   }
-   
-   /**
-    * Returns true if the predicate evaluates to true
-    * with respect to the specified scan.
-    * @param s the scan
-    * @return true if the predicate is true in the scan
-    */
-   public boolean isSatisfied(Scan s) {
-      for (Term t : terms)
-         if (!t.isSatisfied(s))
-         return false;
-      return true;
-   }
-   
-   /** 
-    * Calculates the extent to which selecting on the predicate 
-    * reduces the number of records output by a query.
-    * For example if the reduction factor is 2, then the
-    * predicate cuts the size of the output in half.
-    * @param p the query's plan
-    * @return the integer reduction factor.
-    */ 
-   public int reductionFactor(Plan p) {
-      int factor = 1;
-      for (Term t : terms)
-         factor *= t.reductionFactor(p);
-      return factor;
-   }
-   
-   /**
-    * Returns the subpredicate that applies to the specified schema.
-    * @param sch the schema
-    * @return the subpredicate applying to the schema
-    */
-   public Predicate selectPred(Schema sch) {
-      Predicate result = new Predicate();
-      for (Term t : terms)
-         if (t.appliesTo(sch))
-         result.terms.add(t);
-      if (result.terms.size() == 0)
-         return null;
-      else
-         return result;
-   }
-   
-   /**
-    * Returns the subpredicate consisting of terms that apply
-    * to the union of the two specified schemas, 
-    * but not to either schema separately.
-    * @param sch1 the first schema
-    * @param sch2 the second schema
-    * @return the subpredicate whose terms apply to the union of the two schemas but not either schema separately.
-    */
-   public Predicate joinPred(Schema sch1, Schema sch2) {
-      Predicate result = new Predicate();
-      Schema newsch = new Schema();
-      newsch.addAll(sch1);
-      newsch.addAll(sch2);
-      for (Term t : terms)
-         if (!t.appliesTo(sch1)  &&
-             !t.appliesTo(sch2) &&
-             t.appliesTo(newsch))
-         result.terms.add(t);
-      if (result.terms.size() == 0)
-         return null;
-      else
-         return result;
-   }
-   
-   /**
-    * Determines if there is a term of the form "F=c"
-    * where F is the specified field and c is some constant.
-    * If so, the method returns that constant.
-    * If not, the method returns null.
-    * @param fldname the name of the field
-    * @return either the constant or null
-    */
-   public Constant equatesWithConstant(String fldname) {
-      for (Term t : terms) {
-         Constant c = t.equatesWithConstant(fldname);
-         if (c != null)
-            return c;
-      }
-      return null;
-   }
-   
-   /**
-    * Determines if there is a term of the form "F1=F2"
-    * where F1 is the specified field and F2 is another field.
-    * If so, the method returns the name of that field.
-    * If not, the method returns null.
-    * @param fldname the name of the field
-    * @return the name of the other field, or null
-    */
-   public String equatesWithField(String fldname) {
-      for (Term t : terms) {
-         String s = t.equatesWithField(fldname);
-         if (s != null)
-            return s;
-      }
-      return null;
-   }
-   
-   public String toString() {
-      Iterator<Term> iter = terms.iterator();
-      if (!iter.hasNext()) 
-         return "";
-      String result = iter.next().toString();
-      while (iter.hasNext())
-         result += " and " + iter.next().toString();
-      return result;
-   }
-}
diff --git a/src/simpledb/query/ProductPlan.class b/src/simpledb/query/ProductPlan.class
deleted file mode 100644
index 7d89c90..0000000
Binary files a/src/simpledb/query/ProductPlan.class and /dev/null differ
diff --git a/src/simpledb/query/ProductPlan.java b/src/simpledb/query/ProductPlan.java
deleted file mode 100644
index 1e8f1d5..0000000
--- a/src/simpledb/query/ProductPlan.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/** The Plan class corresponding to the <i>product</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class ProductPlan implements Plan {
-   private Plan p1, p2;
-   private Schema schema = new Schema();
-   
-   /**
-    * Creates a new product node in the query tree,
-    * having the two specified subqueries.
-    * @param p1 the left-hand subquery
-    * @param p2 the right-hand subquery
-    */
-   public ProductPlan(Plan p1, Plan p2) {
-      this.p1 = p1;
-      this.p2 = p2;
-      schema.addAll(p1.schema());
-      schema.addAll(p2.schema());
-   }
-   
-   /**
-    * Creates a product scan for this query.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s1 = p1.open();
-      Scan s2 = p2.open();
-      return new ProductScan(s1, s2);
-   }
-   
-   /**
-    * Estimates the number of block accesses in the product.
-    * The formula is:
-    * <pre> B(product(p1,p2)) = B(p1) + R(p1)*B(p2) </pre>
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p1.blocksAccessed() + (p1.recordsOutput() * p2.blocksAccessed());
-   }
-   
-   /**
-    * Estimates the number of output records in the product.
-    * The formula is:
-    * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p1.recordsOutput() * p2.recordsOutput();
-   }
-   
-   /**
-    * Estimates the distinct number of field values in the product.
-    * Since the product does not increase or decrease field values,
-    * the estimate is the same as in the appropriate underlying query.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (p1.schema().hasField(fldname))
-         return p1.distinctValues(fldname);
-      else
-         return p2.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the product,
-    * which is the union of the schemas of the underlying queries.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return schema;
-   }
-}
diff --git a/src/simpledb/query/ProductScan.class b/src/simpledb/query/ProductScan.class
deleted file mode 100644
index 4775e66..0000000
Binary files a/src/simpledb/query/ProductScan.class and /dev/null differ
diff --git a/src/simpledb/query/ProductScan.java b/src/simpledb/query/ProductScan.java
deleted file mode 100644
index 23746ac..0000000
--- a/src/simpledb/query/ProductScan.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package simpledb.query;
-
-/**
- * The scan class corresponding to the <i>product</i> relational
- * algebra operator.
- * @author Edward Sciore
- */
-public class ProductScan implements Scan {
-   private Scan s1, s2;
-   
-   /**
-    * Creates a product scan having the two underlying scans.
-    * @param s1 the LHS scan
-    * @param s2 the RHS scan
-    */
-   public ProductScan(Scan s1, Scan s2) {
-      this.s1 = s1;
-      this.s2 = s2;
-      s1.next();
-   }
-   
-   /**
-    * Positions the scan before its first record.
-    * In other words, the LHS scan is positioned at 
-    * its first record, and the RHS scan
-    * is positioned before its first record.
-    * @see simpledb.query.Scan#beforeFirst()
-    */
-   public void beforeFirst() {
-      s1.beforeFirst();
-      s1.next();
-      s2.beforeFirst();
-   }
-   
-   /**
-    * Moves the scan to the next record.
-    * The method moves to the next RHS record, if possible.
-    * Otherwise, it moves to the next LHS record and the
-    * first RHS record.
-    * If there are no more LHS records, the method returns false.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      if (s2.next())
-         return true;
-      else {
-         s2.beforeFirst();
-         return s2.next() && s1.next();
-      }
-   }
-   
-   /**
-    * Closes both underlying scans.
-    * @see simpledb.query.Scan#close()
-    */
-   public void close() {
-      s1.close();
-      s2.close();
-   }
-   
-   /** 
-    * Returns the value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getVal(fldname);
-      else
-         return s2.getVal(fldname);
-   }
-   
-   /** 
-    * Returns the integer value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getInt(fldname);
-      else
-         return s2.getInt(fldname);
-   }
-   
-   /** 
-    * Returns the string value of the specified field.
-    * The value is obtained from whichever scan
-    * contains the field.
-    * @see simpledb.query.Scan#getString(java.lang.String)
-    */
-   public String getString(String fldname) {
-      if (s1.hasField(fldname))
-         return s1.getString(fldname);
-      else
-         return s2.getString(fldname);
-   }
-   
-   /**
-    * Returns true if the specified field is in
-    * either of the underlying scans.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return s1.hasField(fldname) || s2.hasField(fldname);
-   }
-}
diff --git a/src/simpledb/query/ProjectPlan.class b/src/simpledb/query/ProjectPlan.class
deleted file mode 100644
index 5b6bc3a..0000000
Binary files a/src/simpledb/query/ProjectPlan.class and /dev/null differ
diff --git a/src/simpledb/query/ProjectPlan.java b/src/simpledb/query/ProjectPlan.java
deleted file mode 100644
index 8f7e877..0000000
--- a/src/simpledb/query/ProjectPlan.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-import java.util.Collection;
-
-/** The Plan class corresponding to the <i>project</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class ProjectPlan implements Plan {
-   private Plan p;
-   private Schema schema = new Schema();
-   
-   /**
-    * Creates a new project node in the query tree,
-    * having the specified subquery and field list.
-    * @param p the subquery
-    * @param fieldlist the list of fields
-    */
-   public ProjectPlan(Plan p, Collection<String> fieldlist) {
-      this.p = p;
-      for (String fldname : fieldlist)
-         schema.add(fldname, p.schema());
-   }
-   
-   /**
-    * Creates a project scan for this query.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s = p.open();
-      return new ProjectScan(s, schema.fields());
-   }
-   
-   /**
-    * Estimates the number of block accesses in the projection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p.blocksAccessed();
-   }
-   
-   /**
-    * Estimates the number of output records in the projection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p.recordsOutput();
-   }
-   
-   /**
-    * Estimates the number of distinct field values
-    * in the projection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      return p.distinctValues(fldname);
-   }
-   
-   /**
-    * Returns the schema of the projection,
-    * which is taken from the field list.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return schema;
-   }
-}
diff --git a/src/simpledb/query/ProjectScan.class b/src/simpledb/query/ProjectScan.class
deleted file mode 100644
index 3c764e3..0000000
Binary files a/src/simpledb/query/ProjectScan.class and /dev/null differ
diff --git a/src/simpledb/query/ProjectScan.java b/src/simpledb/query/ProjectScan.java
deleted file mode 100644
index 2498ecd..0000000
--- a/src/simpledb/query/ProjectScan.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package simpledb.query;
-
-import java.util.*;
-
-/**
- * The scan class corresponding to the <i>project</i> relational
- * algebra operator.
- * All methods except hasField delegate their work to the
- * underlying scan.
- * @author Edward Sciore
- */
-public class ProjectScan implements Scan {
-   private Scan s;
-   private Collection<String> fieldlist;
-   
-   /**
-    * Creates a project scan having the specified
-    * underlying scan and field list.
-    * @param s the underlying scan
-    * @param fieldlist the list of field names
-    */
-   public ProjectScan(Scan s, Collection<String> fieldlist) {
-      this.s = s;
-      this.fieldlist = fieldlist;
-   }
-   
-   public void beforeFirst() {
-      s.beforeFirst();
-   }
-   
-   public boolean next() {
-      return s.next();
-   }
-   
-   public void close() {
-      s.close();
-   }
-   
-   public Constant getVal(String fldname) {
-      if (hasField(fldname))
-         return s.getVal(fldname);
-      else
-         throw new RuntimeException("field " + fldname + " not found.");
-   }
-   
-   public int getInt(String fldname) {
-      if (hasField(fldname))
-         return s.getInt(fldname);
-      else
-         throw new RuntimeException("field " + fldname + " not found.");
-   }
-   
-   public String getString(String fldname) {
-      if (hasField(fldname))
-         return s.getString(fldname);
-      else
-         throw new RuntimeException("field " + fldname + " not found.");
-   }
-   
-   /**
-    * Returns true if the specified field
-    * is in the projection list.
-    * @see simpledb.query.Scan#hasField(java.lang.String)
-    */
-   public boolean hasField(String fldname) {
-      return fieldlist.contains(fldname);
-   }
-}
diff --git a/src/simpledb/query/Scan.class b/src/simpledb/query/Scan.class
deleted file mode 100644
index c4288d1..0000000
Binary files a/src/simpledb/query/Scan.class and /dev/null differ
diff --git a/src/simpledb/query/Scan.java b/src/simpledb/query/Scan.java
deleted file mode 100644
index 4f9191c..0000000
--- a/src/simpledb/query/Scan.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package simpledb.query;
-
-/**
- * The interface will be implemented by each query scan.
- * There is a Scan class for each relational
- * algebra operator.
- * @author Edward Sciore
- */
-public interface Scan {
-   
-   /**
-    * Positions the scan before its first record.
-    */
-   public void     beforeFirst();
-   
-   /**
-    * Moves the scan to the next record.
-    * @return false if there is no next record
-    */
-   public boolean  next();
-   
-   /**
-    * Closes the scan and its subscans, if any. 
-    */
-   public void     close();
-   
-   /**
-    * Returns the value of the specified field in the current record.
-    * The value is expressed as a Constant.
-    * @param fldname the name of the field
-    * @return the value of that field, expressed as a Constant.
-    */
-   public Constant getVal(String fldname);
-   
-   /**
-    * Returns the value of the specified integer field 
-    * in the current record.
-    * @param fldname the name of the field
-    * @return the field's integer value in the current record
-    */
-   public int      getInt(String fldname);
-   
-   /**
-    * Returns the value of the specified string field 
-    * in the current record.
-    * @param fldname the name of the field
-    * @return the field's string value in the current record
-    */
-   public String   getString(String fldname);
-   
-   /**
-    * Returns true if the scan has the specified field.
-    * @param fldname the name of the field
-    * @return true if the scan has that field
-    */
-   public boolean  hasField(String fldname);
-}
diff --git a/src/simpledb/query/SelectPlan.class b/src/simpledb/query/SelectPlan.class
deleted file mode 100644
index 821f74a..0000000
Binary files a/src/simpledb/query/SelectPlan.class and /dev/null differ
diff --git a/src/simpledb/query/SelectPlan.java b/src/simpledb/query/SelectPlan.java
deleted file mode 100644
index 360bdf4..0000000
--- a/src/simpledb/query/SelectPlan.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/** The Plan class corresponding to the <i>select</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class SelectPlan implements Plan {
-   private Plan p;
-   private Predicate pred;
-   
-   /**
-    * Creates a new select node in the query tree,
-    * having the specified subquery and predicate.
-    * @param p the subquery
-    * @param pred the predicate
-    */
-   public SelectPlan(Plan p, Predicate pred) {
-      this.p = p;
-      this.pred = pred;
-   }
-   
-   /**
-    * Creates a select scan for this query.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s = p.open();
-      return new SelectScan(s, pred);
-   }
-   
-   /**
-    * Estimates the number of block accesses in the selection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p.blocksAccessed();
-   }
-   
-   /**
-    * Estimates the number of output records in the selection,
-    * which is determined by the 
-    * reduction factor of the predicate.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p.recordsOutput() / pred.reductionFactor(p);
-   }
-   
-   /**
-    * Estimates the number of distinct field values
-    * in the projection.
-    * If the predicate contains a term equating the specified 
-    * field to a constant, then this value will be 1.
-    * Otherwise, it will be the number of the distinct values
-    * in the underlying query 
-    * (but not more than the size of the output table).
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (pred.equatesWithConstant(fldname) != null)
-         return 1;
-      else {
-         String fldname2 = pred.equatesWithField(fldname);
-         if (fldname2 != null) 
-            return Math.min(p.distinctValues(fldname),
-                            p.distinctValues(fldname2));
-         else
-            return Math.min(p.distinctValues(fldname),
-                            recordsOutput());
-      }
-   }
-   
-   /**
-    * Returns the schema of the selection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return p.schema();
-   }
-}
diff --git a/src/simpledb/query/SelectPlan.java~ b/src/simpledb/query/SelectPlan.java~
deleted file mode 100644
index ad5cb2b..0000000
--- a/src/simpledb/query/SelectPlan.java~
+++ /dev/null
@@ -1,84 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/** The Plan class corresponding to the <i>select</i>
-  * relational algebra operator.
-  * @author Edward Sciore
-  */
-public class SelectPlan implements Plan {
-   private Plan p;
-   private Predicate pred;
-   
-   /**
-    * Creates a new select node in the query tree,
-    * having the specified subquery and predicate.
-    * @param p the subquery
-    * @param pred the predicate
-    */
-   public SelectPlan(Plan p, Predicate pred) {
-      this.p = p;
-      this.pred = pred;
-   }
-   
-   /**
-    * Creates a select scan for this query.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      Scan s = p.open();
-      return new SelectScan(s, pred);
-   }
-   
-   /**
-    * Estimates the number of block accesses in the selection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */
-   public int blocksAccessed() {
-      return p.blocksAccessed();
-   }
-   
-   /**
-    * Estimates the number of output records in the selection,
-    * which is determined by the 
-    * reduction factor of the predicate.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return p.recordsOutput() / pred.reductionFactor(p);
-   }
-   
-   /**
-    * Estimates the number of distinct field values
-    * in the projection.
-    * If the predicate contains a term equating the specified 
-    * field to a constant, then this value will be 1.
-    * Otherwise, it will be the number of the distinct values
-    * in the underlying query 
-    * (but not more than the size of the output table).
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      if (pred.equatesWithConstant(fldname) != null)
-         return 1;
-      else {
-          String fldname2 = pred.equatesWithField(fldname);
-          if (fldname2 != null) 
-              return Math.min(p.distinctValues(fldname),
-                              p.distinctValues(fldname2));
-          else
-              return Math.min(p.distinctValues(fldname),
-                              recordsOutput());
-      }
-   }
-   
-   /**
-    * Returns the schema of the selection,
-    * which is the same as in the underlying query.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return p.schema();
-   }
-}
diff --git a/src/simpledb/query/SelectScan.class b/src/simpledb/query/SelectScan.class
deleted file mode 100644
index ef519f6..0000000
Binary files a/src/simpledb/query/SelectScan.class and /dev/null differ
diff --git a/src/simpledb/query/SelectScan.java b/src/simpledb/query/SelectScan.java
deleted file mode 100644
index ea14ec9..0000000
--- a/src/simpledb/query/SelectScan.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.*;
-
-/**
- * The scan class corresponding to the <i>select</i> relational
- * algebra operator.
- * All methods except next delegate their work to the
- * underlying scan.
- * @author Edward Sciore
- */
-public class SelectScan implements UpdateScan {
-   private Scan s;
-   private Predicate pred;
-   
-   /**
-    * Creates a select scan having the specified underlying
-    * scan and predicate.
-    * @param s the scan of the underlying query
-    * @param pred the selection predicate
-    */
-   public SelectScan(Scan s, Predicate pred) {
-      this.s = s;
-      this.pred = pred;
-   }
-   
-   // Scan methods
-   
-   public void beforeFirst() {
-      s.beforeFirst();
-   }
-   
-   /**
-    * Move to the next record satisfying the predicate.
-    * The method repeatedly calls next on the underlying scan
-    * until a suitable record is found, or the underlying scan
-    * contains no more records.
-    * @see simpledb.query.Scan#next()
-    */
-   public boolean next() {
-      while (s.next())
-         if (pred.isSatisfied(s))
-         return true;
-      return false;
-   }
-   
-   public void close() {
-      s.close();
-   }
-   
-   public Constant getVal(String fldname) {
-      return s.getVal(fldname);
-   }
-   
-   public int getInt(String fldname) {
-      return s.getInt(fldname);
-   }
-   
-   public String getString(String fldname) {
-      return s.getString(fldname);
-   }
-   
-   public boolean hasField(String fldname) {
-      return s.hasField(fldname);
-   }
-   
-   // UpdateScan methods
-   
-   public void setVal(String fldname, Constant val) {
-      UpdateScan us = (UpdateScan) s;
-      us.setVal(fldname, val);
-   }
-   
-   public void setInt(String fldname, int val) {
-      UpdateScan us = (UpdateScan) s;
-      us.setInt(fldname, val);
-   }
-   
-   public void setString(String fldname, String val) {
-      UpdateScan us = (UpdateScan) s;
-      us.setString(fldname, val);
-   }
-   
-   public void delete() {
-      UpdateScan us = (UpdateScan) s;
-      us.delete();
-   }
-   
-   public void insert() {
-      UpdateScan us = (UpdateScan) s;
-      us.insert();
-   }
-   
-   public RID getRid() {
-      UpdateScan us = (UpdateScan) s;
-      return us.getRid();
-   }
-   
-   public void moveToRid(RID rid) {
-      UpdateScan us = (UpdateScan) s;
-      us.moveToRid(rid);
-   }
-}
diff --git a/src/simpledb/query/StringConstant.class b/src/simpledb/query/StringConstant.class
deleted file mode 100644
index 805668d..0000000
Binary files a/src/simpledb/query/StringConstant.class and /dev/null differ
diff --git a/src/simpledb/query/StringConstant.java b/src/simpledb/query/StringConstant.java
deleted file mode 100644
index b3884a9..0000000
--- a/src/simpledb/query/StringConstant.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package simpledb.query;
-
-/**
- * The class that wraps Java strings as database constants.
- * @author Edward Sciore
- */
-public class StringConstant implements Constant {
-   private String val;
-   
-   /**
-    * Create a constant by wrapping the specified string.
-    * @param s the string value
-    */
-   public StringConstant(String s) {
-      val = s;
-   }
-   
-   /**
-    * Unwraps the string and returns it.
-    * @see simpledb.query.Constant#asJavaVal()
-    */
-   public String asJavaVal() {
-      return val;
-   }
-   
-   public boolean equals(Object obj) {
-      StringConstant sc = (StringConstant) obj;
-      return sc != null && val.equals(sc.val);
-   }
-   
-   public int compareTo(Constant c) {
-      StringConstant sc = (StringConstant) c;
-      return val.compareTo(sc.val);
-   }
-   
-   public int hashCode() {
-      return val.hashCode();
-   }
-   
-   public String toString() {
-      return val;
-   }
-}
diff --git a/src/simpledb/query/TablePlan.class b/src/simpledb/query/TablePlan.class
deleted file mode 100644
index bfc58d8..0000000
Binary files a/src/simpledb/query/TablePlan.class and /dev/null differ
diff --git a/src/simpledb/query/TablePlan.java b/src/simpledb/query/TablePlan.java
deleted file mode 100644
index 4e6b949..0000000
--- a/src/simpledb/query/TablePlan.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package simpledb.query;
-
-import simpledb.server.SimpleDB;
-import simpledb.tx.Transaction;
-import simpledb.metadata.*;
-import simpledb.record.*;
-
-/** The Plan class corresponding to a table.
-  * @author Edward Sciore
-  */
-public class TablePlan implements Plan {
-   private Transaction tx;
-   private TableInfo ti;
-   private StatInfo si;
-   
-   /**
-    * Creates a leaf node in the query tree corresponding
-    * to the specified table.
-    * @param tblname the name of the table
-    * @param tx the calling transaction
-    */
-   public TablePlan(String tblname, Transaction tx) {
-      this.tx = tx;
-      ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
-      si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
-   }
-   
-   /**
-    * Creates a table scan for this query.
-    * @see simpledb.query.Plan#open()
-    */
-   public Scan open() {
-      return new TableScan(ti, tx);
-   }
-   
-   /**
-    * Estimates the number of block accesses for the table,
-    * which is obtainable from the statistics manager.
-    * @see simpledb.query.Plan#blocksAccessed()
-    */ 
-   public int blocksAccessed() {
-      return si.blocksAccessed();
-   }
-   
-   /**
-    * Estimates the number of records in the table,
-    * which is obtainable from the statistics manager.
-    * @see simpledb.query.Plan#recordsOutput()
-    */
-   public int recordsOutput() {
-      return si.recordsOutput();
-   }
-   
-   /**
-    * Estimates the number of distinct field values in the table,
-    * which is obtainable from the statistics manager.
-    * @see simpledb.query.Plan#distinctValues(java.lang.String)
-    */
-   public int distinctValues(String fldname) {
-      return si.distinctValues(fldname);
-   }
-   
-   /**
-    * Determines the schema of the table,
-    * which is obtainable from the catalog manager.
-    * @see simpledb.query.Plan#schema()
-    */
-   public Schema schema() {
-      return ti.schema();
-   }
-}
diff --git a/src/simpledb/query/TableScan.class b/src/simpledb/query/TableScan.class
deleted file mode 100644
index 61f3c49..0000000
Binary files a/src/simpledb/query/TableScan.class and /dev/null differ
diff --git a/src/simpledb/query/TableScan.java b/src/simpledb/query/TableScan.java
deleted file mode 100644
index d13d26f..0000000
--- a/src/simpledb/query/TableScan.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package simpledb.query;
-
-import static java.sql.Types.INTEGER;
-import simpledb.tx.Transaction;
-import simpledb.record.*;
-
-/**
- * The Scan class corresponding to a table.
- * A table scan is just a wrapper for a RecordFile object;
- * most methods just delegate to the corresponding
- * RecordFile methods.
- * @author Edward Sciore
- *
- */
-public class TableScan implements UpdateScan {
-   private RecordFile rf;
-   private Schema sch;
-   
-   /**
-    * Creates a new table scan,
-    * and opens its corresponding record file. 
-    * @param ti the table's metadata
-    * @param tx the calling transaction
-    */
-   public TableScan(TableInfo ti, Transaction tx) {
-      rf  = new RecordFile(ti, tx);
-      sch = ti.schema();
-   }
-   
-   // Scan methods
-   
-   public void beforeFirst() {
-      rf.beforeFirst();
-   }
-   
-   public boolean next() {
-      return rf.next();
-   }
-   
-   public void close() {
-      rf.close();
-   }
-   
-   /**
-    * Returns the value of the specified field, as a Constant.
-    * The schema is examined to determine the field's type.
-    * If INTEGER, then the record file's getInt method is called;
-    * otherwise, the getString method is called.
-    * @see simpledb.query.Scan#getVal(java.lang.String)
-    */
-   public Constant getVal(String fldname) {
-      if (sch.type(fldname) == INTEGER)
-         return new IntConstant(rf.getInt(fldname));
-      else
-         return new StringConstant(rf.getString(fldname));
-   }
-   
-   public int getInt(String fldname) {
-      return rf.getInt(fldname);
-   }
-   
-   public String getString(String fldname) {
-      return rf.getString(fldname);
-   }
-   
-   public boolean hasField(String fldname) {
-      return sch.hasField(fldname);
-   }
-   
-   // UpdateScan methods
-   
-   /**
-    * Sets the value of the specified field, as a Constant.
-    * The schema is examined to determine the field's type.
-    * If INTEGER, then the record file's setInt method is called;
-    * otherwise, the setString method is called.
-    * @see simpledb.query.UpdateScan#setVal(java.lang.String, simpledb.query.Constant)
-    */ 
-   public void setVal(String fldname, Constant val) {
-      if (sch.type(fldname) == INTEGER)
-         rf.setInt(fldname, (Integer)val.asJavaVal());
-      else
-         rf.setString(fldname, (String)val.asJavaVal());
-   }
-   
-   public void setInt(String fldname, int val) {
-      rf.setInt(fldname, val);
-   }
-   
-   public void setString(String fldname, String val) {
-      rf.setString(fldname, val);
-   }
-   
-   public void delete() {
-      rf.delete();
-   }
-   
-   public void insert() {
-      rf.insert();
-   }
-   
-   public RID getRid() {
-      return rf.currentRid();
-   }
-   
-   public void moveToRid(RID rid) {
-      rf.moveToRid(rid);
-   }
-}
diff --git a/src/simpledb/query/Term.class b/src/simpledb/query/Term.class
deleted file mode 100644
index 4936314..0000000
Binary files a/src/simpledb/query/Term.class and /dev/null differ
diff --git a/src/simpledb/query/Term.java b/src/simpledb/query/Term.java
deleted file mode 100644
index fef85d1..0000000
--- a/src/simpledb/query/Term.java
+++ /dev/null
@@ -1,123 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.Schema;
-
-/**
- * A term is a comparison between two expressions.
- * @author Edward Sciore
- *
- */
-public class Term {
-   private Expression lhs, rhs;
-   
-   /**
-    * Creates a new term that compares two expressions
-    * for equality.
-    * @param lhs  the LHS expression
-    * @param rhs  the RHS expression
-    */
-   public Term(Expression lhs, Expression rhs) {
-      this.lhs = lhs;
-      this.rhs = rhs;
-   }
-   
-   /**
-    * Calculates the extent to which selecting on the term reduces 
-    * the number of records output by a query.
-    * For example if the reduction factor is 2, then the
-    * term cuts the size of the output in half.
-    * @param p the query's plan
-    * @return the integer reduction factor.
-    */
-   public int reductionFactor(Plan p) {
-      String lhsName, rhsName;
-      if (lhs.isFieldName() && rhs.isFieldName()) {
-         lhsName = lhs.asFieldName();
-         rhsName = rhs.asFieldName();
-         return Math.max(p.distinctValues(lhsName),
-                         p.distinctValues(rhsName));
-      }
-      if (lhs.isFieldName()) {
-         lhsName = lhs.asFieldName();
-         return p.distinctValues(lhsName);
-      }
-      if (rhs.isFieldName()) {
-         rhsName = rhs.asFieldName();
-         return p.distinctValues(rhsName);
-      }
-      // otherwise, the term equates constants
-      if (lhs.asConstant().equals(rhs.asConstant()))
-         return 1;
-      else
-         return Integer.MAX_VALUE;
-   }
-   
-   /**
-    * Determines if this term is of the form "F=c"
-    * where F is the specified field and c is some constant.
-    * If so, the method returns that constant.
-    * If not, the method returns null.
-    * @param fldname the name of the field
-    * @return either the constant or null
-    */
-   public Constant equatesWithConstant(String fldname) {
-      if (lhs.isFieldName() &&
-          lhs.asFieldName().equals(fldname) &&
-          rhs.isConstant())
-         return rhs.asConstant();
-      else if (rhs.isFieldName() &&
-               rhs.asFieldName().equals(fldname) &&
-               lhs.isConstant())
-         return lhs.asConstant();
-      else
-         return null;
-   }
-   
-   /**
-    * Determines if this term is of the form "F1=F2"
-    * where F1 is the specified field and F2 is another field.
-    * If so, the method returns the name of that field.
-    * If not, the method returns null.
-    * @param fldname the name of the field
-    * @return either the name of the other field, or null
-    */
-   public String equatesWithField(String fldname) {
-      if (lhs.isFieldName() &&
-          lhs.asFieldName().equals(fldname) &&
-          rhs.isFieldName())
-         return rhs.asFieldName();
-      else if (rhs.isFieldName() &&
-               rhs.asFieldName().equals(fldname) &&
-               lhs.isFieldName())
-         return lhs.asFieldName();
-      else
-         return null;
-   }
-   
-   /**
-    * Returns true if both of the term's expressions
-    * apply to the specified schema.
-    * @param sch the schema
-    * @return true if both expressions apply to the schema
-    */
-   public boolean appliesTo(Schema sch) {
-      return lhs.appliesTo(sch) && rhs.appliesTo(sch);
-   }
-   
-   /**
-    * Returns true if both of the term's expressions
-    * evaluate to the same constant,
-    * with respect to the specified scan.
-    * @param s the scan
-    * @return true if both expressions have the same value in the scan
-    */
-   public boolean isSatisfied(Scan s) {
-      Constant lhsval = lhs.evaluate(s);
-      Constant rhsval = rhs.evaluate(s);
-      return rhsval.equals(lhsval);
-   }
-   
-   public String toString() {
-      return lhs.toString() + "=" + rhs.toString();
-   }
-}
diff --git a/src/simpledb/query/UpdateScan.class b/src/simpledb/query/UpdateScan.class
deleted file mode 100644
index 8d27e6a..0000000
Binary files a/src/simpledb/query/UpdateScan.class and /dev/null differ
diff --git a/src/simpledb/query/UpdateScan.java b/src/simpledb/query/UpdateScan.java
deleted file mode 100644
index e9e3a63..0000000
--- a/src/simpledb/query/UpdateScan.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package simpledb.query;
-
-import simpledb.record.RID;
-
-/**
- * The interface implemented by all updateable scans.
- * @author Edward Sciore
- */
-public interface UpdateScan extends Scan {
-   /**
-    * Modifies the field value of the current record.
-    * @param fldname the name of the field
-    * @param val the new value, expressed as a Constant
-    */
-   public void setVal(String fldname, Constant val);
-   
-   /**
-    * Modifies the field value of the current record.
-    * @param fldname the name of the field
-    * @param val the new integer value
-    */
-   public void setInt(String fldname, int val);
-   
-   /**
-    * Modifies the field value of the current record.
-    * @param fldname the name of the field
-    * @param val the new string value
-    */
-   public void setString(String fldname, String val);
-   
-   /**
-    * Inserts a new record somewhere in the scan.
-    */
-   public void insert();
-   
-   /**
-    * Deletes the current record from the scan.
-    */
-   public void delete();
-   
-   /**
-    * Returns the RID of the current record.
-    * @return the RID of the current record
-    */
-   public RID  getRid();
-   
-   /**
-    * Positions the scan so that the current record has
-    * the specified RID.
-    * @param rid the RID of the desired record
-    */
-   public void moveToRid(RID rid);
-}
diff --git a/src/simpledb/record/RID.class b/src/simpledb/record/RID.class
deleted file mode 100644
index fd49e40..0000000
Binary files a/src/simpledb/record/RID.class and /dev/null differ
diff --git a/src/simpledb/record/RID.java b/src/simpledb/record/RID.java
deleted file mode 100644
index b76cbbe..0000000
--- a/src/simpledb/record/RID.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package simpledb.record;
-
-/**
- * An identifier for a record within a file.
- * A RID consists of the block number in the file,
- * and the ID of the record in that block.
- * @author Edward Sciore
- */
-public class RID {
-	private int blknum;
-	private int id;
-
-	/**
-	 * Creates a RID for the record having the
-	 * specified ID in the specified block.
-	 * @param blknum the block number where the record lives
-	 * @param id the record's ID
-	 */
-	public RID(int blknum, int id) {
-		this.blknum = blknum;
-		this.id     = id;
-	}
-
-	/**
-	 * Returns the block number associated with this RID.
-	 * @return the block number
-	 */
-	public int blockNumber() {
-		return blknum;
-	}
-
-	/**
-	 * Returns the ID associated with this RID.
-	 * @return the ID
-	 */
-	public int id() {
-		return id;
-	}
-
-	public boolean equals(Object obj) {
-		RID r = (RID) obj;
-		return blknum == r.blknum && id==r.id;
-	}
-
-	public String toString() {
-		return "[" + blknum + ", " + id + "]";
-	}
-}
diff --git a/src/simpledb/record/RecordFile.class b/src/simpledb/record/RecordFile.class
deleted file mode 100644
index fc45218..0000000
Binary files a/src/simpledb/record/RecordFile.class and /dev/null differ
diff --git a/src/simpledb/record/RecordFile.java b/src/simpledb/record/RecordFile.java
deleted file mode 100644
index 0c463ca..0000000
--- a/src/simpledb/record/RecordFile.java
+++ /dev/null
@@ -1,164 +0,0 @@
-package simpledb.record;
-
-import simpledb.file.Block;
-import simpledb.tx.Transaction;
-
-/**
- * Manages a file of records.
- * There are methods for iterating through the records
- * and accessing their contents.
- * @author Edward Sciore
- */
-public class RecordFile {
-   private TableInfo ti;
-   private Transaction tx;
-   private String filename;
-   private RecordPage rp;
-   private int currentblknum;
-   
-   /**
-    * Constructs an object to manage a file of records.
-    * If the file does not exist, it is created.
-    * @param ti the table metadata
-    * @param tx the transaction
-    */
-   public RecordFile(TableInfo ti, Transaction tx) {
-      this.ti = ti;
-      this.tx = tx;
-      filename = ti.fileName();
-      if (tx.size(filename) == 0)
-         appendBlock();
-      moveTo(0);
-   }
-   
-   /**
-    * Closes the record file.
-    */
-   public void close() {
-      rp.close();
-   }
-   
-   /**
-    * Positions the current record so that a call to method next
-    * will wind up at the first record. 
-    */
-   public void beforeFirst() {
-      moveTo(0);
-   }
-   
-   /**
-    * Moves to the next record. Returns false if there
-    * is no next record.
-    * @return false if there is no next record.
-    */
-   public boolean next() {
-      while (true) {
-         if (rp.next())
-            return true;
-         if (atLastBlock())
-            return false;
-         moveTo(currentblknum + 1);
-      }
-   }
-   
-   /**
-    * Returns the value of the specified field
-    * in the current record.
-    * @param fldname the name of the field
-    * @return the integer value at that field
-    */
-   public int getInt(String fldname) {
-      return rp.getInt(fldname);
-   }
-   
-   /**
-    * Returns the value of the specified field
-    * in the current record.
-    * @param fldname the name of the field
-    * @return the string value at that field
-    */
-   public String getString(String fldname) {
-      return rp.getString(fldname);
-   }
-   
-   /**
-    * Sets the value of the specified field 
-    * in the current record.
-    * @param fldname the name of the field
-    * @param val the new value for the field
-    */
-   public void setInt(String fldname, int val) {
-      rp.setInt(fldname, val);
-   }
-   
-   /**
-    * Sets the value of the specified field 
-    * in the current record.
-    * @param fldname the name of the field
-    * @param val the new value for the field
-    */
-   public void setString(String fldname, String val) {
-      rp.setString(fldname, val);
-   }
-   
-   /**
-    * Deletes the current record.
-    * The client must call next() to move to
-    * the next record.
-    * Calls to methods on a deleted record 
-    * have unspecified behavior.
-    */
-   public void delete() {
-      rp.delete();
-   }
-   
-   /**
-    * Inserts a new, blank record somewhere in the file
-    * beginning at the current record.
-    * If the new record does not fit into an existing block,
-    * then a new block is appended to the file.
-    */
-   public void insert() {
-      while (!rp.insert()) {
-         if (atLastBlock())
-            appendBlock();
-         moveTo(currentblknum + 1);
-      }
-   }
-   
-   /**
-    * Positions the current record as indicated by the
-    * specified RID. 
-    * @param rid a record identifier
-    */
-   public void moveToRid(RID rid) {
-      moveTo(rid.blockNumber());
-      rp.moveToId(rid.id());
-   }
-   
-   /**
-    * Returns the RID of the current record.
-    * @return a record identifier
-    */
-   public RID currentRid() {
-      int id = rp.currentId();
-      return new RID(currentblknum, id);
-   }
-   
-   private void moveTo(int b) {
-      if (rp != null)
-         rp.close();
-      currentblknum = b;
-      Block blk = new Block(filename, currentblknum);
-      rp = new RecordPage(blk, ti, tx);
-   }
-   
-   private boolean atLastBlock() {
-      return currentblknum == tx.size(filename) - 1;
-   }
-   
-   private void appendBlock() {
-      RecordFormatter fmtr = new RecordFormatter(ti);
-      tx.append(filename, fmtr);
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/record/RecordFormatter.class b/src/simpledb/record/RecordFormatter.class
deleted file mode 100644
index 4d1e210..0000000
Binary files a/src/simpledb/record/RecordFormatter.class and /dev/null differ
diff --git a/src/simpledb/record/RecordFormatter.java b/src/simpledb/record/RecordFormatter.java
deleted file mode 100644
index 9059544..0000000
--- a/src/simpledb/record/RecordFormatter.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package simpledb.record;
-
-import static java.sql.Types.INTEGER;
-import static simpledb.file.Page.*;
-import static simpledb.record.RecordPage.EMPTY;
-import simpledb.file.Page;
-import simpledb.buffer.PageFormatter;
-
-/**
- * An object that can format a page to look like a block of 
- * empty records.
- * @author Edward Sciore
- */
-class RecordFormatter implements PageFormatter {
-   private TableInfo ti;
-   
-   /**
-    * Creates a formatter for a new page of a table.
-    * @param ti the table's metadata
-    */
-   public RecordFormatter(TableInfo ti) {
-      this.ti = ti;
-   }
-   
-   /** 
-    * Formats the page by allocating as many record slots
-    * as possible, given the record length.
-    * Each record slot is assigned a flag of EMPTY.
-    * Each integer field is given a value of 0, and
-    * each string field is given a value of "".
-    * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
-    */
-   public void format(Page page) {
-      int recsize = ti.recordLength() + INT_SIZE;
-      for (int pos=0; pos+recsize<=BLOCK_SIZE; pos += recsize) {
-         page.setInt(pos, EMPTY);
-         makeDefaultRecord(page, pos);
-      }
-   }
-   
-   private void makeDefaultRecord(Page page, int pos) {
-      for (String fldname : ti.schema().fields()) {
-         int offset = ti.offset(fldname);
-         if (ti.schema().type(fldname) == INTEGER)
-            page.setInt(pos + INT_SIZE + offset, 0);
-         else
-            page.setString(pos + INT_SIZE + offset, "");
-      }
-   }
-}
diff --git a/src/simpledb/record/RecordPage.class b/src/simpledb/record/RecordPage.class
deleted file mode 100644
index 226da80..0000000
Binary files a/src/simpledb/record/RecordPage.class and /dev/null differ
diff --git a/src/simpledb/record/RecordPage.java b/src/simpledb/record/RecordPage.java
deleted file mode 100644
index 5cbf4ae..0000000
--- a/src/simpledb/record/RecordPage.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package simpledb.record;
-
-import static simpledb.file.Page.*;
-import simpledb.file.Block;
-import simpledb.tx.Transaction;
-
-/**
- * Manages the placement and access of records in a block.
- * @author Edward Sciore
- */
-public class RecordPage {
-   public static final int EMPTY = 0, INUSE = 1;
-   
-   private Block blk;
-   private TableInfo ti;
-   private Transaction tx;
-   private int slotsize;
-   private int currentslot = -1;
-   
-   /** Creates the record manager for the specified block.
-     * The current record is set to be prior to the first one.
-     * @param blk a reference to the disk block
-     * @param ti the table's metadata
-     * @param tx the transaction performing the operations
-     */
-   public RecordPage(Block blk, TableInfo ti, Transaction tx) {
-      this.blk = blk;
-      this.ti = ti;
-      this.tx = tx;
-      slotsize = ti.recordLength() + INT_SIZE;
-      tx.pin(blk);
-  }
-   
-   /**
-    * Closes the manager, by unpinning the block.
-    */
-   public void close() {
-      if (blk != null) {
-    	  tx.unpin(blk);
-    	  blk = null;
-      }
-   }
-   
-   /**
-    * Moves to the next record in the block.
-    * @return false if there is no next record.
-    */
-   public boolean next() {
-      return searchFor(INUSE);
-   }
-   
-   /**
-    * Returns the integer value stored for the
-    * specified field of the current record.
-    * @param fldname the name of the field.
-    * @return the integer stored in that field
-    */
-   public int getInt(String fldname) {
-      int position = fieldpos(fldname);
-      return tx.getInt(blk, position);
-   }
-   
-   /**
-    * Returns the string value stored for the
-    * specified field of the current record.
-    * @param fldname the name of the field.
-    * @return the string stored in that field
-    */
-   public String getString(String fldname) {
-      int position = fieldpos(fldname);
-      return tx.getString(blk, position);
-   }
-   
-   /**
-    * Stores an integer at the specified field
-    * of the current record.
-    * @param fldname the name of the field
-    * @param val the integer value stored in that field
-    */
-   public void setInt(String fldname, int val) {
-      int position = fieldpos(fldname);
-      tx.setInt(blk, position, val);
-   }
-   
-   /**
-    * Stores a string at the specified field
-    * of the current record.
-    * @param fldname the name of the field
-    * @param val the string value stored in that field
-    */
-   public void setString(String fldname, String val) {
-      int position = fieldpos(fldname);
-      tx.setString(blk, position, val);
-   }
-   
-   /**
-    * Deletes the current record.
-    * Deletion is performed by just marking the record
-    * as "deleted"; the current record does not change. 
-    * To get to the next record, call next().
-    */
-   public void delete() {
-      int position = currentpos();
-      tx.setInt(blk, position, EMPTY);
-   }
-   
-   /**
-    * Inserts a new, blank record somewhere in the page.
-    * Return false if there were no available slots.
-    * @return false if the insertion was not possible
-    */
-   public boolean insert() {
-      currentslot = -1;
-      boolean found = searchFor(EMPTY);
-      if (found) {
-         int position = currentpos();
-         tx.setInt(blk, position, INUSE);
-      }
-      return found;
-   }
-   
-   /**
-    * Sets the current record to be the record having the
-    * specified ID.
-    * @param id the ID of the record within the page.
-    */
-   public void moveToId(int id) {
-      currentslot = id;
-   }
-   
-   /**
-    * Returns the ID of the current record.
-    * @return the ID of the current record
-    */
-   public int currentId() {
-      return currentslot;
-   }
-   
-   private int currentpos() {
-      return currentslot * slotsize;
-   }
-   
-   private int fieldpos(String fldname) {
-      int offset = INT_SIZE + ti.offset(fldname);
-      return currentpos() + offset;
-   }
-   
-   private boolean isValidSlot() {
-      return currentpos() + slotsize <= BLOCK_SIZE;
-   }
-   
-   private boolean searchFor(int flag) {
-      currentslot++;
-      while (isValidSlot()) {
-         int position = currentpos();
-         if (tx.getInt(blk, position) == flag)
-            return true;
-         currentslot++;
-      }
-      return false;
-   }
-}
diff --git a/src/simpledb/record/Schema$FieldInfo.class b/src/simpledb/record/Schema$FieldInfo.class
deleted file mode 100644
index df484c1..0000000
Binary files a/src/simpledb/record/Schema$FieldInfo.class and /dev/null differ
diff --git a/src/simpledb/record/Schema.class b/src/simpledb/record/Schema.class
deleted file mode 100644
index 8361bb1..0000000
Binary files a/src/simpledb/record/Schema.class and /dev/null differ
diff --git a/src/simpledb/record/Schema.java b/src/simpledb/record/Schema.java
deleted file mode 100644
index 155391e..0000000
--- a/src/simpledb/record/Schema.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package simpledb.record;
-
-import static java.sql.Types.*;
-import java.util.*;
-
-/**
- * The record schema of a table.
- * A schema contains the name and type of
- * each field of the table, as well as the length
- * of each varchar field.
- * @author Edward Sciore
- *
- */
-public class Schema {
-   private Map<String,FieldInfo> info = new HashMap<String,FieldInfo>();
-   
-   /**
-    * Creates an empty schema.
-    * Field information can be added to a schema
-    * via the five addXXX methods. 
-    */
-   public Schema() {}
-   
-   /**
-    * Adds a field to the schema having a specified
-    * name, type, and length.
-    * If the field type is "integer", then the length
-    * value is irrelevant.
-    * @param fldname the name of the field
-    * @param type the type of the field, according to the constants in simpledb.sql.types
-    * @param length the conceptual length of a string field.
-    */
-   public void addField(String fldname, int type, int length) {
-      info.put(fldname, new FieldInfo(type, length));
-   }
-   
-   /**
-    * Adds an integer field to the schema.
-    * @param fldname the name of the field
-    */
-   public void addIntField(String fldname) {
-      addField(fldname, INTEGER, 0);
-   }
-   
-   /**
-    * Adds a string field to the schema.
-    * The length is the conceptual length of the field.
-    * For example, if the field is defined as varchar(8),
-    * then its length is 8.
-    * @param fldname the name of the field
-    * @param length the number of chars in the varchar definition
-    */
-   public void addStringField(String fldname, int length) {
-      addField(fldname, VARCHAR, length);
-   }
-   
-   /**
-    * Adds a field to the schema having the same
-    * type and length as the corresponding field
-    * in another schema.
-    * @param fldname the name of the field
-    * @param sch the other schema
-    */
-   public void add(String fldname, Schema sch) {
-      int type   = sch.type(fldname);
-      int length = sch.length(fldname);
-      addField(fldname, type, length);
-   }
-   
-   /**
-    * Adds all of the fields in the specified schema
-    * to the current schema.
-    * @param sch the other schema
-    */
-   public void addAll(Schema sch) {
-      info.putAll(sch.info);
-   }
-   
-   /**
-    * Returns a collection containing the name of
-    * each field in the schema.
-    * @return the collection of the schema's field names
-    */
-   public Collection<String> fields() {
-      return info.keySet();
-   }
-   
-   /**
-    * Returns true if the specified field
-    * is in the schema
-    * @param fldname the name of the field
-    * @return true if the field is in the schema
-    */
-   public boolean hasField(String fldname) {
-      return fields().contains(fldname);
-   }
-   
-   /**
-    * Returns the type of the specified field, using the
-    * constants in {@link java.sql.Types}.
-    * @param fldname the name of the field
-    * @return the integer type of the field
-    */
-   public int type(String fldname) {
-      return info.get(fldname).type;
-   }
-   
-   /**
-    * Returns the conceptual length of the specified field.
-    * If the field is not a string field, then
-    * the return value is undefined.
-    * @param fldname the name of the field
-    * @return the conceptual length of the field
-    */
-   public int length(String fldname) {
-      return info.get(fldname).length;
-   }
-   
-   class FieldInfo {
-      int type, length;
-      public FieldInfo(int type, int length) {
-         this.type = type;
-         this.length = length;
-      }
-   }
-}
diff --git a/src/simpledb/record/TableInfo.class b/src/simpledb/record/TableInfo.class
deleted file mode 100644
index a0cc903..0000000
Binary files a/src/simpledb/record/TableInfo.class and /dev/null differ
diff --git a/src/simpledb/record/TableInfo.java b/src/simpledb/record/TableInfo.java
deleted file mode 100644
index 883d7cb..0000000
--- a/src/simpledb/record/TableInfo.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package simpledb.record;
-
-import static java.sql.Types.INTEGER;
-import static simpledb.file.Page.*;
-import java.util.*;
-
-/**
- * The metadata about a table and its records.
- * @author Edward Sciore
- */
-public class TableInfo {
-   private Schema schema;
-   private Map<String,Integer> offsets;
-   private int recordlen;
-   private String tblname;
-   
-   /**
-    * Creates a TableInfo object, given a table name
-    * and schema. The constructor calculates the
-    * physical offset of each field.
-    * This constructor is used when a table is created. 
-    * @param tblname the name of the table
-    * @param schema the schema of the table's records
-    */
-   public TableInfo(String tblname, Schema schema) {
-      this.schema = schema;
-      this.tblname = tblname;
-      offsets  = new HashMap<String,Integer>();
-      int pos = 0;
-      for (String fldname : schema.fields()) {
-         offsets.put(fldname, pos);
-         pos += lengthInBytes(fldname);
-      }
-      recordlen = pos;
-   }
-   
-   /**
-    * Creates a TableInfo object from the 
-    * specified metadata.
-    * This constructor is used when the metadata
-    * is retrieved from the catalog.
-    * @param tblname the name of the table
-    * @param schema the schema of the table's records
-    * @param offsets the already-calculated offsets of the fields within a record
-    * @param recordlen the already-calculated length of each record
-    */
-   public TableInfo(String tblname, Schema schema, Map<String,Integer> offsets, int recordlen) {
-      this.tblname   = tblname;
-      this.schema    = schema;
-      this.offsets   = offsets;
-      this.recordlen = recordlen;
-   }
-   
-   /**
-    * Returns the filename assigned to this table.
-    * Currently, the filename is the table name
-    * followed by ".tbl".
-    * @return the name of the file assigned to the table
-    */
-   public String fileName() {
-      return tblname + ".tbl";
-   }
-   
-   /**
-    * Returns the schema of the table's records
-    * @return the table's record schema
-    */
-   public Schema schema() {
-      return schema;
-   }
-   
-   /**
-    * Returns the offset of a specified field within a record
-    * @param fldname the name of the field
-    * @return the offset of that field within a record
-    */
-   public int offset(String fldname) {
-      return offsets.get(fldname);
-   }
-   
-   /**
-    * Returns the length of a record, in bytes.
-    * @return the length in bytes of a record
-    */
-   public int recordLength() {
-      return recordlen;
-   }
-   
-   private int lengthInBytes(String fldname) {
-      int fldtype = schema.type(fldname);
-      if (fldtype == INTEGER)
-         return INT_SIZE;
-      else
-         return STR_SIZE(schema.length(fldname));
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/remote/ConnectionAdapter.class b/src/simpledb/remote/ConnectionAdapter.class
deleted file mode 100644
index 27982ae..0000000
Binary files a/src/simpledb/remote/ConnectionAdapter.class and /dev/null differ
diff --git a/src/simpledb/remote/ConnectionAdapter.java b/src/simpledb/remote/ConnectionAdapter.java
deleted file mode 100644
index 98cd153..0000000
--- a/src/simpledb/remote/ConnectionAdapter.java
+++ /dev/null
@@ -1,236 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-import java.util.*;
-import java.util.concurrent.Executor;
-
-/**
- * This class implements all of the methods of the Connection interface,
- * by throwing an exception for each one.
- * Subclasses (such as SimpleConnection) can override those methods that 
- * it want to implement.
- * @author Edward Sciore
- */
-public abstract class ConnectionAdapter implements Connection {
-   @Override
-	public void setSchema(String schema) throws SQLException {
-	      throw new SQLException("operation not implemented");
-	}
-
-	@Override
-	public String getSchema() throws SQLException {
-	      throw new SQLException("operation not implemented");
-	}
-
-	@Override
-	public void abort(Executor executor) throws SQLException {
-	      throw new SQLException("operation not implemented");
-		
-	}
-
-	@Override
-	public void setNetworkTimeout(Executor executor, int milliseconds)
-	{
-    	// TODO: implement
-		return;
-	}
-
-	@Override
-	public int getNetworkTimeout() throws SQLException {
-	      throw new SQLException("operation not implemented");
-	}
-
-public void clearWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void close() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void commit() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Blob createBlob() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Clob createClob() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public NClob createNClob() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLXML createSQLXML() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Statement createStatement() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean getAutoCommit() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getCatalog() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Properties getClientInfo() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getClientInfo(String name) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getHoldability() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public DatabaseMetaData getMetaData() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getTransactionIsolation() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Map<String,Class<?>> getTypeMap() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLWarning getWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isClosed() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isReadOnly() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isValid(int timeout) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String nativeSQL(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public CallableStatement prepareCall(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void releaseSavepoint(Savepoint savepoint) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void rollback() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void rollback(Savepoint svepoint) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setAutoCommit(boolean autoCommit) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setCatalog(String catalog) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setClientInfo(String name, String value) {
-   }
-   
-   public void setClientInfo(Properties properties) {
-   }
-   
-   public void setHoldability(int holdability) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setReadOnly(boolean readOnly) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Savepoint setSavepoint() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Savepoint setSavepoint(String name) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setTransactionIsolation(int level) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setTypeMap(Map<String,Class<?>> map) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isWrapperFor(Class<?> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public <T> T unwrap(Class<T> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/remote/DriverAdapter.class b/src/simpledb/remote/DriverAdapter.class
deleted file mode 100644
index 986d084..0000000
Binary files a/src/simpledb/remote/DriverAdapter.class and /dev/null differ
diff --git a/src/simpledb/remote/DriverAdapter.java b/src/simpledb/remote/DriverAdapter.java
deleted file mode 100644
index 81dc727..0000000
--- a/src/simpledb/remote/DriverAdapter.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-import java.util.*;
-
-/**
- * This class implements all of the methods of the Driver interface,
- * by throwing an exception for each one.
- * Subclasses (such as SimpleDriver) can override those methods that 
- * it want to implement.
- * @author Edward Sciore
- */
-public abstract class DriverAdapter implements Driver {
-   public boolean acceptsURL(String url) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Connection connect(String url, Properties info) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getMajorVersion() {
-      return 0;
-   }
-   
-   public int getMinorVersion() {
-      return 0;
-   }
-   
-   public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
-      return null;
-   }
-   
-   public boolean jdbcCompliant() {
-      return false;
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/remote/RemoteConnection.class b/src/simpledb/remote/RemoteConnection.class
deleted file mode 100644
index 2ba5375..0000000
Binary files a/src/simpledb/remote/RemoteConnection.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteConnection.java b/src/simpledb/remote/RemoteConnection.java
deleted file mode 100644
index a65dbd8..0000000
--- a/src/simpledb/remote/RemoteConnection.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.*;
-
-/**
- * The RMI remote interface corresponding to Connection.
- * The methods are identical to those of Connection, 
- * except that they throw RemoteExceptions instead of SQLExceptions.
- * @author Edward Sciore
- */
-public interface RemoteConnection extends Remote {
-   public RemoteStatement createStatement() throws RemoteException;
-   public void close() throws RemoteException;
-}
-
diff --git a/src/simpledb/remote/RemoteConnectionImpl.class b/src/simpledb/remote/RemoteConnectionImpl.class
deleted file mode 100644
index 06aeab0..0000000
Binary files a/src/simpledb/remote/RemoteConnectionImpl.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteConnectionImpl.java b/src/simpledb/remote/RemoteConnectionImpl.java
deleted file mode 100644
index 6cfc369..0000000
--- a/src/simpledb/remote/RemoteConnectionImpl.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package simpledb.remote;
-
-import simpledb.tx.Transaction;
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-
-/**
- * The RMI server-side implementation of RemoteConnection.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial") 
-class RemoteConnectionImpl extends UnicastRemoteObject implements RemoteConnection {
-   private Transaction tx;
-   
-   /**
-    * Creates a remote connection
-    * and begins a new transaction for it.
-    * @throws RemoteException
-    */
-   RemoteConnectionImpl() throws RemoteException {
-      tx = new Transaction();
-   }
-   
-   /**
-    * Creates a new RemoteStatement for this connection.
-    * @see simpledb.remote.RemoteConnection#createStatement()
-    */
-   public RemoteStatement createStatement() throws RemoteException {
-      return new RemoteStatementImpl(this);
-   }
-   
-   /**
-    * Closes the connection.
-    * The current transaction is committed.
-    * @see simpledb.remote.RemoteConnection#close()
-    */
-   public void close() throws RemoteException {
-      tx.commit();
-   }
-   
-// The following methods are used by the server-side classes.
-   
-   /**
-    * Returns the transaction currently associated with
-    * this connection.
-    * @return the transaction associated with this connection
-    */
-   Transaction getTransaction() {  
-      return tx;
-   }
-   
-   /**
-    * Commits the current transaction,
-    * and begins a new one.
-    */
-   void commit() {
-      tx.commit();
-      tx = new Transaction();
-   }
-   
-   /**
-    * Rolls back the current transaction,
-    * and begins a new one.
-    */
-   void rollback() {
-      tx.rollback();
-      tx = new Transaction();
-   }
-}
-
diff --git a/src/simpledb/remote/RemoteDriver.class b/src/simpledb/remote/RemoteDriver.class
deleted file mode 100644
index e34bb35..0000000
Binary files a/src/simpledb/remote/RemoteDriver.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteDriver.java b/src/simpledb/remote/RemoteDriver.java
deleted file mode 100644
index eaaa30d..0000000
--- a/src/simpledb/remote/RemoteDriver.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.*;
-
-/**
- * The RMI remote interface corresponding to Driver.
- * The method is similar to that of Driver, 
- * except that it takes no arguments and
- * throws RemoteExceptions instead of SQLExceptions.
- * @author Edward Sciore
- */
-public interface RemoteDriver extends Remote {
-   public RemoteConnection connect() throws RemoteException;
-}
-
diff --git a/src/simpledb/remote/RemoteDriverImpl.class b/src/simpledb/remote/RemoteDriverImpl.class
deleted file mode 100644
index f781833..0000000
Binary files a/src/simpledb/remote/RemoteDriverImpl.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteDriverImpl.java b/src/simpledb/remote/RemoteDriverImpl.java
deleted file mode 100644
index b709cfa..0000000
--- a/src/simpledb/remote/RemoteDriverImpl.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-
-/**
- * The RMI server-side implementation of RemoteDriver.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-public class RemoteDriverImpl extends UnicastRemoteObject implements RemoteDriver {
-   public RemoteDriverImpl() throws RemoteException {
-   }
-   
-   /**
-    * Creates a new RemoteConnectionImpl object and 
-    * returns it.
-    * @see simpledb.remote.RemoteDriver#connect()
-    */
-   public RemoteConnection connect() throws RemoteException {
-      return new RemoteConnectionImpl();
-   }
-}
-
diff --git a/src/simpledb/remote/RemoteMetaData.class b/src/simpledb/remote/RemoteMetaData.class
deleted file mode 100644
index add08a4..0000000
Binary files a/src/simpledb/remote/RemoteMetaData.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteMetaData.java b/src/simpledb/remote/RemoteMetaData.java
deleted file mode 100644
index 418edc6..0000000
--- a/src/simpledb/remote/RemoteMetaData.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.*;
-
-/**
- * The RMI remote interface corresponding to ResultSetMetaData.
- * The methods are identical to those of ResultSetMetaData, 
- * except that they throw RemoteExceptions instead of SQLExceptions.
- * @author Edward Sciore
- */
-public interface RemoteMetaData extends Remote {
-   public int    getColumnCount()              throws RemoteException;
-   public String getColumnName(int column)     throws RemoteException;
-   public int    getColumnType(int column)     throws RemoteException;
-   public int getColumnDisplaySize(int column) throws RemoteException;
-}
-
diff --git a/src/simpledb/remote/RemoteMetaDataImpl.class b/src/simpledb/remote/RemoteMetaDataImpl.class
deleted file mode 100644
index cf189a6..0000000
Binary files a/src/simpledb/remote/RemoteMetaDataImpl.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteMetaDataImpl.java b/src/simpledb/remote/RemoteMetaDataImpl.java
deleted file mode 100644
index b2ec583..0000000
--- a/src/simpledb/remote/RemoteMetaDataImpl.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package simpledb.remote;
-
-import simpledb.record.Schema;
-import static java.sql.Types.INTEGER;
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-import java.util.*;
-
-/**
- * The RMI server-side implementation of RemoteMetaData.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-public class RemoteMetaDataImpl extends UnicastRemoteObject implements RemoteMetaData {
-   private Schema sch;
-   private List<String> fields = new ArrayList<String>();
-   
-   /**
-    * Creates a metadata object that wraps the specified schema.
-    * The method also creates a list to hold the schema's
-    * collection of field names,
-    * so that the fields can be accessed by position.
-    * @param sch the schema
-    * @throws RemoteException
-    */
-   public RemoteMetaDataImpl(Schema sch) throws RemoteException {
-      this.sch = sch;
-      fields.addAll(sch.fields());
-   }
-   
-   /**
-    * Returns the size of the field list.
-    * @see simpledb.remote.RemoteMetaData#getColumnCount()
-    */
-   public int getColumnCount() throws RemoteException {
-      return fields.size();
-   }
-   
-   /**
-    * Returns the field name for the specified column number.
-    * In JDBC, column numbers start with 1, so the field
-    * is taken from position (column-1) in the list.
-    * @see simpledb.remote.RemoteMetaData#getColumnName(int)
-    */
-   public String getColumnName(int column) throws RemoteException {
-      return fields.get(column-1);
-   }
-   
-   /**
-    * Returns the type of the specified column.
-    * The method first finds the name of the field in that column,
-    * and then looks up its type in the schema.
-    * @see simpledb.remote.RemoteMetaData#getColumnType(int)
-    */
-   public int getColumnType(int column) throws RemoteException {
-      String fldname = getColumnName(column);
-      return sch.type(fldname);
-   }
-   
-   /**
-    * Returns the number of characters required to display the
-    * specified column.
-    * For a string-type field, the method simply looks up the 
-    * field's length in the schema and returns that.
-    * For an int-type field, the method needs to decide how
-    * large integers can be.
-    * Here, the method arbitrarily chooses 6 characters,
-    * which means that integers over 999,999 will  
-    * probably get displayed improperly.
-    * @see simpledb.remote.RemoteMetaData#getColumnDisplaySize(int)
-    */
-   public int getColumnDisplaySize(int column) throws RemoteException {
-      String fldname = getColumnName(column);
-      int fldtype = sch.type(fldname);
-      int fldlength = sch.length(fldname);
-      if (fldtype == INTEGER)
-         return 6;  // accommodate 6-digit integers
-      else
-         return fldlength;
-   }
-}
diff --git a/src/simpledb/remote/RemoteResultSet.class b/src/simpledb/remote/RemoteResultSet.class
deleted file mode 100644
index b93bc2c..0000000
Binary files a/src/simpledb/remote/RemoteResultSet.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteResultSet.java b/src/simpledb/remote/RemoteResultSet.java
deleted file mode 100644
index ac847a2..0000000
--- a/src/simpledb/remote/RemoteResultSet.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.*;
-
-/**
- * The RMI remote interface corresponding to ResultSet.
- * The methods are identical to those of ResultSet, 
- * except that they throw RemoteExceptions instead of SQLExceptions.
- * @author Edward Sciore
- */
-public interface RemoteResultSet extends Remote {
-   public boolean next()                   throws RemoteException;
-   public int getInt(String fldname)       throws RemoteException;
-   public String getString(String fldname) throws RemoteException;
-   public RemoteMetaData getMetaData()     throws RemoteException;
-   public void close()                     throws RemoteException;
-}
-
diff --git a/src/simpledb/remote/RemoteResultSetImpl.class b/src/simpledb/remote/RemoteResultSetImpl.class
deleted file mode 100644
index 6ecfbba..0000000
Binary files a/src/simpledb/remote/RemoteResultSetImpl.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteResultSetImpl.java b/src/simpledb/remote/RemoteResultSetImpl.java
deleted file mode 100644
index 50d2366..0000000
--- a/src/simpledb/remote/RemoteResultSetImpl.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package simpledb.remote;
-
-import simpledb.record.Schema;
-import simpledb.query.*;
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-
-/**
- * The RMI server-side implementation of RemoteResultSet.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-class RemoteResultSetImpl extends UnicastRemoteObject implements RemoteResultSet {
-   private Scan s;
-   private Schema sch;
-   private RemoteConnectionImpl rconn;
-
-   /**
-    * Creates a RemoteResultSet object.
-    * The specified plan is opened, and the scan is saved.
-    * @param plan the query plan
-    * @param rconn TODO
-    * @throws RemoteException
-    */
-   public RemoteResultSetImpl(Plan plan, RemoteConnectionImpl rconn) throws RemoteException {
-      s = plan.open();
-      sch = plan.schema();
-      this.rconn = rconn;
-   }
-
-   /**
-    * Moves to the next record in the result set,
-    * by moving to the next record in the saved scan.
-    * @see simpledb.remote.RemoteResultSet#next()
-    */
-   public boolean next() throws RemoteException {
-		try {
-	      return s.next();
-      }
-      catch(RuntimeException e) {
-         rconn.rollback();
-         throw e;
-      }
-   }
-
-   /**
-    * Returns the integer value of the specified field,
-    * by returning the corresponding value on the saved scan.
-    * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
-    */
-   public int getInt(String fldname) throws RemoteException {
-		try {
-	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
-	      return s.getInt(fldname);
-      }
-      catch(RuntimeException e) {
-         rconn.rollback();
-         throw e;
-      }
-   }
-
-   /**
-    * Returns the integer value of the specified field,
-    * by returning the corresponding value on the saved scan.
-    * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
-    */
-   public String getString(String fldname) throws RemoteException {
-		try {
-	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
-	      return s.getString(fldname);
-      }
-      catch(RuntimeException e) {
-         rconn.rollback();
-         throw e;
-      }
-   }
-
-   /**
-    * Returns the result set's metadata,
-    * by passing its schema into the RemoteMetaData constructor.
-    * @see simpledb.remote.RemoteResultSet#getMetaData()
-    */
-   public RemoteMetaData getMetaData() throws RemoteException {
-      return new RemoteMetaDataImpl(sch);
-   }
-
-   /**
-    * Closes the result set by closing its scan.
-    * @see simpledb.remote.RemoteResultSet#close()
-    */
-   public void close() throws RemoteException {
-      s.close();
-      rconn.commit();
-   }
-}
-
diff --git a/src/simpledb/remote/RemoteStatement.class b/src/simpledb/remote/RemoteStatement.class
deleted file mode 100644
index 7a076c0..0000000
Binary files a/src/simpledb/remote/RemoteStatement.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteStatement.java b/src/simpledb/remote/RemoteStatement.java
deleted file mode 100644
index e8a54ca..0000000
--- a/src/simpledb/remote/RemoteStatement.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package simpledb.remote;
-
-import java.rmi.*;
-
-/**
- * The RMI remote interface corresponding to Statement.
- * The methods are identical to those of Statement, 
- * except that they throw RemoteExceptions instead of SQLExceptions.
- * @author Edward Sciore
- */
-public interface RemoteStatement extends Remote {
-   public RemoteResultSet executeQuery(String qry) throws RemoteException;
-   public int            executeUpdate(String cmd) throws RemoteException;
-}
-
diff --git a/src/simpledb/remote/RemoteStatementImpl.class b/src/simpledb/remote/RemoteStatementImpl.class
deleted file mode 100644
index 6916d72..0000000
Binary files a/src/simpledb/remote/RemoteStatementImpl.class and /dev/null differ
diff --git a/src/simpledb/remote/RemoteStatementImpl.java b/src/simpledb/remote/RemoteStatementImpl.java
deleted file mode 100644
index bc67a20..0000000
--- a/src/simpledb/remote/RemoteStatementImpl.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package simpledb.remote;
-
-import simpledb.tx.Transaction;
-import simpledb.query.Plan;
-import simpledb.server.SimpleDB;
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-
-/**
- * The RMI server-side implementation of RemoteStatement.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-class RemoteStatementImpl extends UnicastRemoteObject implements RemoteStatement {
-   private RemoteConnectionImpl rconn;
-   
-   public RemoteStatementImpl(RemoteConnectionImpl rconn) throws RemoteException {
-      this.rconn = rconn;
-   }
-   
-   /**
-    * Executes the specified SQL query string.
-    * The method calls the query planner to create a plan
-    * for the query. It then sends the plan to the
-    * RemoteResultSetImpl constructor for processing.
-    * @see simpledb.remote.RemoteStatement#executeQuery(java.lang.String)
-    */
-   public RemoteResultSet executeQuery(String qry) throws RemoteException {
-      try {
-         Transaction tx = rconn.getTransaction();
-         Plan pln = SimpleDB.planner().createQueryPlan(qry, tx);
-         return new RemoteResultSetImpl(pln, rconn);
-      }
-      catch(RuntimeException e) {
-         rconn.rollback();
-         throw e;
-      }
-   }
-   
-   /**
-    * Executes the specified SQL update command.
-    * The method sends the command to the update planner,
-    * which executes it.
-    * @see simpledb.remote.RemoteStatement#executeUpdate(java.lang.String)
-    */
-   public int executeUpdate(String cmd) throws RemoteException {
-      try {
-         Transaction tx = rconn.getTransaction();
-         int result = SimpleDB.planner().executeUpdate(cmd, tx);
-         rconn.commit();
-         return result;
-      }
-      catch(RuntimeException e) {
-         rconn.rollback();
-         throw e;
-      }
-   }
-}
diff --git a/src/simpledb/remote/ResultSetAdapter.class b/src/simpledb/remote/ResultSetAdapter.class
deleted file mode 100644
index a31ef74..0000000
Binary files a/src/simpledb/remote/ResultSetAdapter.class and /dev/null differ
diff --git a/src/simpledb/remote/ResultSetAdapter.java b/src/simpledb/remote/ResultSetAdapter.java
deleted file mode 100644
index eed4994..0000000
--- a/src/simpledb/remote/ResultSetAdapter.java
+++ /dev/null
@@ -1,773 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-import java.util.Map;
-import java.util.Calendar;
-import java.io.*;
-import java.math.BigDecimal;
-import java.net.URL;
-
-/**
- * This class implements all of the methods of the ResultSet interface,
- * by throwing an exception for each one.
- * Subclasses (such as SimpleResultSet) can override those methods that 
- * it want to implement.
- * @author Edward Sciore
- */
-public abstract class ResultSetAdapter implements ResultSet {
-   public boolean absolute(int row) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void afterLast() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void beforeFirst() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void cancelRowUpdates() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void clearWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void close() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void deleteRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int findColumn(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean first() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Array getArray(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Array getArray(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getAsciiStream(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getAsciiStream(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getBinaryStream(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getBinaryStream(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Blob getBlob(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Blob getBlob(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean getBoolean(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean getBoolean(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public byte getByte(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public byte getByte(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public byte[] getBytes(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public byte[] getBytes(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Reader getCharacterStream(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Reader getCharacterStream(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Clob getClob(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Clob getClob(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getConcurrency() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getCursorName() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Date getDate(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Date getDate(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Date getDate(int columnIndex, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Date getDate(String columnLabel, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public double getDouble(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public double getDouble(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getFetchDirection() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getFetchSize() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public float getFloat(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public float getFloat(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getHoldability() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getInt(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getInt(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public long getLong(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public long getLong(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public ResultSetMetaData getMetaData() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Reader getNCharacterStream(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Reader getNCharacterStream(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public NClob getNClob(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public NClob getNClob(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getNString(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getNString(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Object getObject(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Object getObject(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Object getObject(int columnIndex, Map<String,Class<?>> map) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Object getObject(String columnLabel, Map<String,Class<?>> map) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Ref getRef(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Ref getRef(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public RowId getRowId(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public RowId getRowId(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public short getShort(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public short getShort(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLXML getSQLXML(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLXML getSQLXML(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Statement getStatement() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getString(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getString(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Time getTime(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Time getTime(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Time getTime(int columnIndex, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Time getTime(String columnLabel, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Timestamp getTimestamp(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Timestamp getTimestamp(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getType() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getUnicodeStream(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public InputStream getUnicodeStream(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public URL getURL(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public URL getURL(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLWarning getWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void insertRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isAfterLast() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isBeforeFirst() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isClosed() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isFirst() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isLast() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean last() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void moveToCurrentRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void moveToInsertRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean next() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean previous() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void refreshRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean relative(int rows) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean rowDeleted() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean rowInserted() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean rowUpdated() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setFetchDirection(int direction) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setFetchSize(int rows) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateArray(int columnIndex, Array x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateArray(String columnLabel, Array x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(int columnIndex, Blob x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(String columnLabel, Blob x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBoolean(int columnIndex, boolean x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBoolean(String columnLabel, boolean x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateByte(int columnIndex, byte x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateByte(String columnLabel, byte x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBytes(int columnIndex, byte[] x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateBytes(String columnLabel, byte[] x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(String columnLabel, Reader x, int length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(int columnIndex, Clob x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(String columnLabel, Clob x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(int columnIndex, Reader reader) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(String columnLabel, Reader reader) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateDate(int columnIndex, Date x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateDate(String columnLabel, Date x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateDouble(int columnIndex, double x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateDouble(String columnLabel, double x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateFloat(int columnIndex, float x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateFloat(String columnLabel, float x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateInt(int columnIndex, int x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateInt(String columnLabel, int x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateLong(int columnIndex, long x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateLong(String columnLabel, long x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(int columnIndex, Reader reader) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(String columnLabel, Reader reader) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNString(int columnIndex, String nstring) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNString(String columnLabel, String nstring) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNull(int columnIndex) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateNull(String columnLabel) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateObject(int columnIndex, Object x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateObject(String columnLabel, Object x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateObject(String columnLabel, Object x, int scale) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateRef(int columnIndex, Ref x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateRef(String columnLabel, Ref x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateRow() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateRowId(int columnIndex, RowId x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateRowId(String columnLabel, RowId x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateShort(int columnIndex, short x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateShort(String columnLabel, short x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateString(int columnIndex, String x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateString(String columnLabel, String x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateTime(int columnIndex, Time x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateTime(String columnLabel, Time x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean wasNull() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isWrapperFor(Class<?> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public <T> T unwrap(Class<T> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/remote/ResultSetMetaDataAdapter.class b/src/simpledb/remote/ResultSetMetaDataAdapter.class
deleted file mode 100644
index 7ea7554..0000000
Binary files a/src/simpledb/remote/ResultSetMetaDataAdapter.class and /dev/null differ
diff --git a/src/simpledb/remote/ResultSetMetaDataAdapter.java b/src/simpledb/remote/ResultSetMetaDataAdapter.java
deleted file mode 100644
index 576e7e2..0000000
--- a/src/simpledb/remote/ResultSetMetaDataAdapter.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-
-/**
- * This class implements all of the methods of the ResultSetMetaData interface,
- * by throwing an exception for each one.
- * Subclasses (such as SimpleMetaData) can override those methods that 
- * it want to implement.
- * @author Edward Sciore
- */
-public abstract class ResultSetMetaDataAdapter implements ResultSetMetaData {
-   public String getCatalogName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getColumnClassName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getColumnCount() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getColumnDisplaySize(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getColumnLabel(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getColumnName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getColumnType(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getColumnTypeName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getPrecision(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getScale(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getSchemaName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public String getTableName(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isAutoIncrement(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isCaseSensitive(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isCurrency(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isDefinitelyWritable(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int isNullable(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isReadOnly(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isSearchable(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isSigned(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isWritable(int column) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isWrapperFor(Class<?> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public <T> T unwrap(Class<T> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/remote/SimpleConnection.class b/src/simpledb/remote/SimpleConnection.class
deleted file mode 100644
index 8d58c54..0000000
Binary files a/src/simpledb/remote/SimpleConnection.class and /dev/null differ
diff --git a/src/simpledb/remote/SimpleConnection.java b/src/simpledb/remote/SimpleConnection.java
deleted file mode 100644
index 07842da..0000000
--- a/src/simpledb/remote/SimpleConnection.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package simpledb.remote;
-
-import java.sql.SQLException;
-import java.sql.Statement;
-
-/**
- * An adapter class that wraps RemoteConnection.
- * Its methods do nothing except transform RemoteExceptions
- * into SQLExceptions.
- * @author Edward Sciore
- */
-public class SimpleConnection extends ConnectionAdapter {
-   private RemoteConnection rconn;
-   
-   public SimpleConnection(RemoteConnection c) {
-      rconn = c;
-   }
-   
-   public Statement createStatement() throws SQLException {
-      try {
-         RemoteStatement rstmt = rconn.createStatement();
-         return new SimpleStatement(rstmt);
-      }
-      catch(Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public void close() throws SQLException {
-      try {
-         rconn.close();
-      }
-      catch(Exception e) {
-         throw new SQLException(e);
-      }
-   }
-}
-
diff --git a/src/simpledb/remote/SimpleDriver.class b/src/simpledb/remote/SimpleDriver.class
deleted file mode 100644
index 6d0c7ad..0000000
Binary files a/src/simpledb/remote/SimpleDriver.class and /dev/null differ
diff --git a/src/simpledb/remote/SimpleDriver.java b/src/simpledb/remote/SimpleDriver.java
deleted file mode 100644
index bd0ae4b..0000000
--- a/src/simpledb/remote/SimpleDriver.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-import java.rmi.*;
-import java.util.Properties;
-import java.util.logging.Logger;
-
-/**
- * The SimpleDB database driver.
- * @author Edward Sciore
- */
-public class SimpleDriver extends DriverAdapter {
-   
-   /**
-    * Connects to the SimpleDB server on the specified host.
-    * The method retrieves the RemoteDriver stub from
-    * the RMI registry on the specified host.
-    * It then calls the connect method on that stub,
-    * which in turn creates a new connection and
-    * returns the RemoteConnection stub for it.
-    * This stub is wrapped in a SimpleConnection object
-    * and is returned. 
-    * <P>
-    * The current implementation of this method ignores the 
-    * properties argument.
-    * @see java.sql.Driver#connect(java.lang.String, Properties)
-    */
-   public Connection connect(String url, Properties prop) throws SQLException {
-      try {
-         String newurl = url.replace("jdbc:simpledb", "rmi") + "/simpledb";
-         RemoteDriver rdvr = (RemoteDriver) Naming.lookup(newurl);
-         RemoteConnection rconn = rdvr.connect();
-         return new SimpleConnection(rconn);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-
-@Override
-public Logger getParentLogger() throws SQLFeatureNotSupportedException {
-	// TODO Auto-generated method stub
-	return null;
-}
-}
diff --git a/src/simpledb/remote/SimpleMetaData.class b/src/simpledb/remote/SimpleMetaData.class
deleted file mode 100644
index 41f27b3..0000000
Binary files a/src/simpledb/remote/SimpleMetaData.class and /dev/null differ
diff --git a/src/simpledb/remote/SimpleMetaData.java b/src/simpledb/remote/SimpleMetaData.java
deleted file mode 100644
index 9865f9b..0000000
--- a/src/simpledb/remote/SimpleMetaData.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-
-/**
- * An adapter class that wraps RemoteMetaData.
- * Its methods do nothing except transform RemoteExceptions
- * into SQLExceptions.
- * @author Edward Sciore
- */
-public class SimpleMetaData extends ResultSetMetaDataAdapter {
-   private RemoteMetaData rmd;
-   
-   public SimpleMetaData(RemoteMetaData md) {
-      rmd = md;
-   }
-   
-   public int getColumnCount() throws SQLException {
-      try {
-         return rmd.getColumnCount();
-      }
-      catch(Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public String getColumnName(int column) throws SQLException {
-      try {
-         return rmd.getColumnName(column);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public int getColumnType(int column) throws SQLException {
-      try {
-         return rmd.getColumnType(column);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public int getColumnDisplaySize(int column) throws SQLException {
-      try {
-         return rmd.getColumnDisplaySize(column);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-}
-
diff --git a/src/simpledb/remote/SimpleResultSet.class b/src/simpledb/remote/SimpleResultSet.class
deleted file mode 100644
index 0fab540..0000000
Binary files a/src/simpledb/remote/SimpleResultSet.class and /dev/null differ
diff --git a/src/simpledb/remote/SimpleResultSet.java b/src/simpledb/remote/SimpleResultSet.java
deleted file mode 100644
index 4a71b7c..0000000
--- a/src/simpledb/remote/SimpleResultSet.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-
-/**
- * An adapter class that wraps RemoteResultSet.
- * Its methods do nothing except transform RemoteExceptions
- * into SQLExceptions.
- * @author Edward Sciore
- */
-public class SimpleResultSet extends ResultSetAdapter {
-   private RemoteResultSet rrs;
-   
-   public SimpleResultSet(RemoteResultSet s) {
-      rrs = s;
-   }
-   
-   public boolean next() throws SQLException {
-      try {
-         return rrs.next();
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public int getInt(String fldname) throws SQLException {
-      try {
-         return rrs.getInt(fldname);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public String getString(String fldname) throws SQLException {
-      try {
-         return rrs.getString(fldname);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public ResultSetMetaData getMetaData() throws SQLException {
-      try {
-         RemoteMetaData rmd = rrs.getMetaData();
-         return new SimpleMetaData(rmd);
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public void close() throws SQLException {
-      try {
-         rrs.close();
-      }
-      catch (Exception e) {
-         throw new SQLException(e);
-      }
-   }
-
-@Override
-public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
-	// TODO Auto-generated method stub
-	return null;
-}
-
-@Override
-public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
-	// TODO Auto-generated method stub
-	return null;
-}
-}
-
diff --git a/src/simpledb/remote/SimpleStatement.class b/src/simpledb/remote/SimpleStatement.class
deleted file mode 100644
index 8960ae9..0000000
Binary files a/src/simpledb/remote/SimpleStatement.class and /dev/null differ
diff --git a/src/simpledb/remote/SimpleStatement.java b/src/simpledb/remote/SimpleStatement.java
deleted file mode 100644
index 63855bc..0000000
--- a/src/simpledb/remote/SimpleStatement.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-
-/**
- * An adapter class that wraps RemoteStatement.
- * Its methods do nothing except transform RemoteExceptions
- * into SQLExceptions.
- * @author Edward Sciore
- */
-public class SimpleStatement extends StatementAdapter {
-   private RemoteStatement rstmt;
-   
-   public SimpleStatement(RemoteStatement s) {
-      rstmt = s;
-   }
-   
-   public ResultSet executeQuery(String qry) throws SQLException {
-      try {
-         RemoteResultSet rrs = rstmt.executeQuery(qry);
-         return new SimpleResultSet(rrs);
-      }
-      catch(Exception e) {
-         throw new SQLException(e);
-      }
-   }
-   
-   public int executeUpdate(String cmd) throws SQLException {
-      try {
-         return rstmt.executeUpdate(cmd);
-      }
-      catch(Exception e) {
-         throw new SQLException(e);
-      }
-   }
-
-@Override
-public void closeOnCompletion() throws SQLException {
-	// TODO Auto-generated method stub
-	
-}
-
-@Override
-public boolean isCloseOnCompletion() throws SQLException {
-	// TODO Auto-generated method stub
-	return false;
-}
-}
-
diff --git a/src/simpledb/remote/StatementAdapter.class b/src/simpledb/remote/StatementAdapter.class
deleted file mode 100644
index 4b1dc7d..0000000
Binary files a/src/simpledb/remote/StatementAdapter.class and /dev/null differ
diff --git a/src/simpledb/remote/StatementAdapter.java b/src/simpledb/remote/StatementAdapter.java
deleted file mode 100644
index 7d7eeb8..0000000
--- a/src/simpledb/remote/StatementAdapter.java
+++ /dev/null
@@ -1,177 +0,0 @@
-package simpledb.remote;
-
-import java.sql.*;
-
-/**
- * This class implements all of the methods of the Statement interface,
- * by throwing an exception for each one.
- * Subclasses (such as SimpleStatement) can override those methods that 
- * it want to implement.
- * @author Edward Sciore
- */
-public abstract class StatementAdapter implements Statement {
-   public void addBatch(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void cancel() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void clearBatch() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void clearWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void close() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean execute(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean execute(String sql, int[] columnIndexes) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean execute(String sql, String[] columnNames) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int[] executeBatch() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public ResultSet executeQuery(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int executeUpdate(String sql) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int executeUpdate(String sql, String[] columnNames) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public Connection getConnection() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getFetchDirection() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getFetchSize() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public ResultSet getGeneratedKeys() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getMaxFieldSize() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getMaxRows() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean getMoreResults() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean getMoreResults(int current) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getQueryTimeout() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public ResultSet getResultSet() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getResultSetConcurrency() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getResultSetHoldability() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getResultSetType() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public int getUpdateCount() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public SQLWarning getWarnings() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isClosed() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public boolean isPoolable() throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setCursorName(String name) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setEscapeProcessing(boolean enable) {
-   }
-   
-   public void setFetchDirection(int direction) {
-   }
-   
-   public void setFetchSize(int rows) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setMaxFieldSize(int max) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setMaxRows(int max) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setPoolable(boolean poolable) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public void setQueryTimeout(int seconds) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   public boolean isWrapperFor(Class<?> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-   
-   public <T> T unwrap(Class<T> iface) throws SQLException {
-      throw new SQLException("operation not implemented");
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/server/SimpleDB.class b/src/simpledb/server/SimpleDB.class
deleted file mode 100644
index 9b3908c..0000000
Binary files a/src/simpledb/server/SimpleDB.class and /dev/null differ
diff --git a/src/simpledb/server/SimpleDB.java b/src/simpledb/server/SimpleDB.java
deleted file mode 100644
index 6910522..0000000
--- a/src/simpledb/server/SimpleDB.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package simpledb.server;
-
-import simpledb.file.FileMgr;
-import simpledb.buffer.*;
-import simpledb.tx.Transaction;
-import simpledb.log.LogMgr;
-import simpledb.metadata.MetadataMgr;
-import simpledb.planner.*;
-
-/**
- * The class that provides system-wide static global values.
- * These values must be initialized by the method
- * {@link #init(String) init} before use.
- * The methods {@link #initFileMgr(String) initFileMgr},
- * {@link #initFileAndLogMgr(String) initFileAndLogMgr},
- * {@link #initFileLogAndBufferMgr(String) initFileLogAndBufferMgr},
- * and {@link #initMetadataMgr(boolean, Transaction) initMetadataMgr}
- * provide limited initialization, and are useful for 
- * debugging purposes.
- * 
- * @author Edward Sciore
- */
-public class SimpleDB {
-   public static int BUFFER_SIZE = 16; // was 8
-   public static String LOG_FILE = "simpledb.log";
-   
-   private static FileMgr     fm;
-   private static BufferMgr   bm;
-   private static LogMgr      logm;
-   private static MetadataMgr mdm;
-   
-   /**
-    * Initializes the system.
-    * This method is called during system startup.
-    * @param dirname the name of the database directory
-    */
-   public static void init(String dirname) {
-      initFileLogAndBufferMgr(dirname);
-      Transaction tx = new Transaction();
-      boolean isnew = fm.isNew();
-      if (isnew)
-         System.out.println("creating new database");
-      else {
-         System.out.println("recovering existing database");
-         tx.recover();
-      }
-      initMetadataMgr(isnew, tx);
-      tx.commit();
-   }
-   
-   // The following initialization methods are useful for 
-   // testing the lower-level components of the system 
-   // without having to initialize everything.
-   
-   /**
-    * Initializes only the file manager.
-    * @param dirname the name of the database directory
-    */
-   public static void initFileMgr(String dirname) {
-      fm = new FileMgr(dirname);
-   }
-   
-   /**
-    * Initializes the file and log managers.
-    * @param dirname the name of the database directory
-    */
-   public static void initFileAndLogMgr(String dirname) {
-      initFileMgr(dirname);
-      logm = new LogMgr(LOG_FILE);
-   }
-   
-   /**
-    * Initializes the file, log, and buffer managers.
-    * @param dirname the name of the database directory
-    */
-   public static void initFileLogAndBufferMgr(String dirname) {
-      initFileAndLogMgr(dirname);
-      bm = new BufferMgr(BUFFER_SIZE);
-   }
-   
-   /**
-    * Initializes metadata manager.
-    * @param isnew an indication of whether a new
-    * database needs to be created.
-    * @param tx the transaction performing the initialization
-    */
-   public static void initMetadataMgr(boolean isnew, Transaction tx) {
-      mdm = new MetadataMgr(isnew, tx);
-   }
-   
-   public static FileMgr     fileMgr()   { return fm; }
-   public static BufferMgr   bufferMgr() { return bm; }
-   public static LogMgr      logMgr()    { return logm; }
-   public static MetadataMgr mdMgr()     { return mdm; }
-   
-   /**
-    * Creates a planner for SQL commands.
-    * To change how the planner works, modify this method.
-    * @return the system's planner for SQL commands
-    */public static Planner planner() {
-      QueryPlanner  qplanner = new BasicQueryPlanner();
-      UpdatePlanner uplanner = new BasicUpdatePlanner();
-      return new Planner(qplanner, uplanner);
-   }
-}
diff --git a/src/simpledb/server/Startup.class b/src/simpledb/server/Startup.class
deleted file mode 100644
index ef00934..0000000
Binary files a/src/simpledb/server/Startup.class and /dev/null differ
diff --git a/src/simpledb/server/Startup.java b/src/simpledb/server/Startup.java
deleted file mode 100644
index 09405ec..0000000
--- a/src/simpledb/server/Startup.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package simpledb.server;
-
-import simpledb.remote.*;
-import java.rmi.*;
-
-public class Startup {
-   public static void main(String args[]) throws Exception {
-      // configure and initialize the database
-      SimpleDB.init(args[0]);
-      
-      // post the server entry in the rmi registry
-      RemoteDriver d = new RemoteDriverImpl();
-      Naming.rebind("simpledb", d);
-      
-      System.out.println("database server ready");
-   }
-}
diff --git a/src/simpledb/studentClient/ChangeMajor.class b/src/simpledb/studentClient/ChangeMajor.class
deleted file mode 100644
index 519d341..0000000
Binary files a/src/simpledb/studentClient/ChangeMajor.class and /dev/null differ
diff --git a/src/simpledb/studentClient/ChangeMajor.java b/src/simpledb/studentClient/ChangeMajor.java
deleted file mode 100644
index b90cb87..0000000
--- a/src/simpledb/studentClient/ChangeMajor.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package simpledb.studentClient;
-
-import java.sql.*;
-import simpledb.remote.SimpleDriver;
-
-public class ChangeMajor {
-    public static void main(String[] args) {
-		Connection conn = null;
-		try {
-			Driver d = new SimpleDriver();
-			conn = d.connect("jdbc:simpledb://localhost", null);
-			Statement stmt = conn.createStatement();
-
-			String cmd = "update STUDENT set MajorId=30 "
-			           + "where SName = 'amy'";
-			stmt.executeUpdate(cmd);
-			System.out.println("Amy is now a drama major.");
-		}
-		catch(SQLException e) {
-			e.printStackTrace();
-		}
-		finally {
-			try {
-				if (conn != null)
-					conn.close();
-			}
-			catch (SQLException e) {
-				e.printStackTrace();
-			}
-		}
-	}
-}
diff --git a/src/simpledb/studentClient/CreateStudentDB.class b/src/simpledb/studentClient/CreateStudentDB.class
deleted file mode 100644
index d41cc0b..0000000
Binary files a/src/simpledb/studentClient/CreateStudentDB.class and /dev/null differ
diff --git a/src/simpledb/studentClient/CreateStudentDB.java b/src/simpledb/studentClient/CreateStudentDB.java
deleted file mode 100644
index 28a4605..0000000
--- a/src/simpledb/studentClient/CreateStudentDB.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package simpledb.studentClient;
-
-import java.sql.*;
-import simpledb.remote.SimpleDriver;
-
-public class CreateStudentDB {
-    public static void main(String[] args) {
-		Connection conn = null;
-		try {
-			Driver d = new SimpleDriver();
-			conn = d.connect("jdbc:simpledb://localhost", null);
-			Statement stmt = conn.createStatement();
-
-			String s = "create table STUDENT(SId int, SName varchar(10), MajorId int, GradYear int)";
-			stmt.executeUpdate(s);
-			System.out.println("Table STUDENT created.");
-
-			s = "insert into STUDENT(SId, SName, MajorId, GradYear) values ";
-			String[] studvals = {"(1, 'joe', 10, 2004)",
-								 "(2, 'amy', 20, 2004)",
-								 "(3, 'max', 10, 2005)",
-								 "(4, 'sue', 20, 2005)",
-								 "(5, 'bob', 30, 2003)",
-								 "(6, 'kim', 20, 2001)",
-								 "(7, 'art', 30, 2004)",
-								 "(8, 'pat', 20, 2001)",
-								 "(9, 'lee', 10, 2004)"};
-			for (int i=0; i<studvals.length; i++)
-				stmt.executeUpdate(s + studvals[i]);
-			System.out.println("STUDENT records inserted.");
-
-			s = "create table DEPT(DId int, DName varchar(8))";
-			stmt.executeUpdate(s);
-			System.out.println("Table DEPT created.");
-
-			s = "insert into DEPT(DId, DName) values ";
-			String[] deptvals = {"(10, 'compsci')",
-								 "(20, 'math')",
-								 "(30, 'drama')"};
-			for (int i=0; i<deptvals.length; i++)
-				stmt.executeUpdate(s + deptvals[i]);
-			System.out.println("DEPT records inserted.");
-
-			s = "create table COURSE(CId int, Title varchar(20), DeptId int)";
-			stmt.executeUpdate(s);
-			System.out.println("Table COURSE created.");
-
-			s = "insert into COURSE(CId, Title, DeptId) values ";
-			String[] coursevals = {"(12, 'db systems', 10)",
-								   "(22, 'compilers', 10)",
-								   "(32, 'calculus', 20)",
-								   "(42, 'algebra', 20)",
-								   "(52, 'acting', 30)",
-								   "(62, 'elocution', 30)"};
-			for (int i=0; i<coursevals.length; i++)
-				stmt.executeUpdate(s + coursevals[i]);
-			System.out.println("COURSE records inserted.");
-
-			s = "create table SECTION(SectId int, CourseId int, Prof varchar(8), YearOffered int)";
-			stmt.executeUpdate(s);
-			System.out.println("Table SECTION created.");
-
-			s = "insert into SECTION(SectId, CourseId, Prof, YearOffered) values ";
-			String[] sectvals = {"(13, 12, 'turing', 2004)",
-								 "(23, 12, 'turing', 2005)",
-								 "(33, 32, 'newton', 2000)",
-								 "(43, 32, 'einstein', 2001)",
-								 "(53, 62, 'brando', 2001)"};
-			for (int i=0; i<sectvals.length; i++)
-				stmt.executeUpdate(s + sectvals[i]);
-			System.out.println("SECTION records inserted.");
-
-			s = "create table ENROLL(EId int, StudentId int, SectionId int, Grade varchar(2))";
-			stmt.executeUpdate(s);
-			System.out.println("Table ENROLL created.");
-
-			s = "insert into ENROLL(EId, StudentId, SectionId, Grade) values ";
-			String[] enrollvals = {"(14, 1, 13, 'A')",
-								   "(24, 1, 43, 'C' )",
-								   "(34, 2, 43, 'B+')",
-								   "(44, 4, 33, 'B' )",
-								   "(54, 4, 53, 'A' )",
-								   "(64, 6, 53, 'A' )"};
-			for (int i=0; i<enrollvals.length; i++)
-				stmt.executeUpdate(s + enrollvals[i]);
-			System.out.println("ENROLL records inserted.");
-
-		}
-		catch(SQLException e) {
-			e.printStackTrace();
-		}
-		finally {
-			try {
-				if (conn != null)
-					conn.close();
-			}
-			catch (SQLException e) {
-				e.printStackTrace();
-			}
-		}
-	}
-}
diff --git a/src/simpledb/studentClient/FindMajors.class b/src/simpledb/studentClient/FindMajors.class
deleted file mode 100644
index e8d3bc9..0000000
Binary files a/src/simpledb/studentClient/FindMajors.class and /dev/null differ
diff --git a/src/simpledb/studentClient/FindMajors.java b/src/simpledb/studentClient/FindMajors.java
deleted file mode 100644
index 7de8bcf..0000000
--- a/src/simpledb/studentClient/FindMajors.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package simpledb.studentClient;
-
-import java.sql.*;
-import simpledb.remote.SimpleDriver;
-
-public class FindMajors {
-    public static void main(String[] args) {
-		String major = args[0];
-		System.out.println("Here are the " + major + " majors");
-		System.out.println("Name\tGradYear");
-
-		Connection conn = null;
-		try {
-			// Step 1: connect to database server
-			Driver d = new SimpleDriver();
-			conn = d.connect("jdbc:simpledb://localhost", null);
-
-			// Step 2: execute the query
-			Statement stmt = conn.createStatement();
-			String qry = "select sname, gradyear "
-			           + "from student, dept "
-			           + "where did = majorid "
-			           + "and dname = '" + major + "'";
-			ResultSet rs = stmt.executeQuery(qry);
-
-			// Step 3: loop through the result set
-			while (rs.next()) {
-				String sname = rs.getString("sname");
-				int gradyear = rs.getInt("gradyear");
-				System.out.println(sname + "\t" + gradyear);
-			}
-			rs.close();
-		}
-		catch(Exception e) {
-			e.printStackTrace();
-		}
-		finally {
-			// Step 4: close the connection
-			try {
-				if (conn != null)
-					conn.close();
-			}
-			catch (SQLException e) {
-				e.printStackTrace();
-			}
-		}
-	}
-}
diff --git a/src/simpledb/studentClient/SQLInterpreter.class b/src/simpledb/studentClient/SQLInterpreter.class
deleted file mode 100644
index d854a39..0000000
Binary files a/src/simpledb/studentClient/SQLInterpreter.class and /dev/null differ
diff --git a/src/simpledb/studentClient/SQLInterpreter.java b/src/simpledb/studentClient/SQLInterpreter.java
deleted file mode 100644
index 5ff9722..0000000
--- a/src/simpledb/studentClient/SQLInterpreter.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package simpledb.studentClient;
-
-import java.sql.*;
-import simpledb.remote.SimpleDriver;
-import java.io.*;
-
-public class SQLInterpreter {
-    private static Connection conn = null;
-
-    public static void main(String[] args) {
-	   try {
-			Driver d = new SimpleDriver();
-			conn = d.connect("jdbc:simpledb://localhost", null);
-
-			Reader rdr = new InputStreamReader(System.in);
-			BufferedReader br = new BufferedReader(rdr);
-
-			while (true) {
-				// process one line of input
-				System.out.print("\nSQL> ");
-				String cmd = br.readLine().trim();
-				System.out.println();
-				if (cmd.startsWith("exit"))
-					break;
-				else if (cmd.startsWith("select"))
-					doQuery(cmd);
-				else
-					doUpdate(cmd);
-		    }
-	    }
-	    catch (Exception e) {
-			e.printStackTrace();
-		}
-		finally {
-			try {
-				if (conn != null)
-					conn.close();
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-		}
-	}
-
-	private static void doQuery(String cmd) {
-		try {
-		    Statement stmt = conn.createStatement();
-		    ResultSet rs = stmt.executeQuery(cmd);
-		    ResultSetMetaData md = rs.getMetaData();
-		    int numcols = md.getColumnCount();
-		    int totalwidth = 0;
-
-		    // print header
-		    for(int i=1; i<=numcols; i++) {
-				int width = md.getColumnDisplaySize(i);
-				totalwidth += width;
-				String fmt = "%" + width + "s";
-				System.out.format(fmt, md.getColumnName(i));
-			}
-			System.out.println();
-			for(int i=0; i<totalwidth; i++)
-			    System.out.print("-");
-		    System.out.println();
-
-		    // print records
-		    while(rs.next()) {
-				for (int i=1; i<=numcols; i++) {
-					String fldname = md.getColumnName(i);
-					int fldtype = md.getColumnType(i);
-					String fmt = "%" + md.getColumnDisplaySize(i);
-					if (fldtype == Types.INTEGER)
-						System.out.format(fmt + "d", rs.getInt(fldname));
-					else
-						System.out.format(fmt + "s", rs.getString(fldname));
-				}
-				System.out.println();
-			}
-			rs.close();
-		}
-		catch (SQLException e) {
-			System.out.println("SQL Exception: " + e.getMessage());
-			e.printStackTrace();
-		}
-	}
-
-	private static void doUpdate(String cmd) {
-		try {
-		    Statement stmt = conn.createStatement();
-		    int howmany = stmt.executeUpdate(cmd);
-		    System.out.println(howmany + " records processed");
-		}
-		catch (SQLException e) {
-			System.out.println("SQL Exception: " + e.getMessage());
-			e.printStackTrace();
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/simpledb/studentClient/StudentMajor.class b/src/simpledb/studentClient/StudentMajor.class
deleted file mode 100644
index 188f5f5..0000000
Binary files a/src/simpledb/studentClient/StudentMajor.class and /dev/null differ
diff --git a/src/simpledb/studentClient/StudentMajor.java b/src/simpledb/studentClient/StudentMajor.java
deleted file mode 100644
index a3762b3..0000000
--- a/src/simpledb/studentClient/StudentMajor.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package simpledb.studentClient;
-
-import java.sql.*;
-import simpledb.remote.SimpleDriver;
-
-public class StudentMajor {
-    public static void main(String[] args) {
-		Connection conn = null;
-		try {
-			// Step 1: connect to database server
-			Driver d = new SimpleDriver();
-			conn = d.connect("jdbc:simpledb://localhost", null);
-
-			// Step 2: execute the query
-			Statement stmt = conn.createStatement();
-			String qry = "select SName, DName "
-			           + "from DEPT, STUDENT "
-			           + "where MajorId = DId";
-			ResultSet rs = stmt.executeQuery(qry);
-
-			// Step 3: loop through the result set
-			System.out.println("Name\tMajor");
-			while (rs.next()) {
-				String sname = rs.getString("SName");
-				String dname = rs.getString("DName");
-				System.out.println(sname + "\t" + dname);
-			}
-			rs.close();
-		}
-		catch(SQLException e) {
-			e.printStackTrace();
-		}
-		finally {
-			// Step 4: close the connection
-			try {
-				if (conn != null)
-					conn.close();
-			}
-			catch (SQLException e) {
-				e.printStackTrace();
-			}
-		}
-	}
-}
diff --git a/src/simpledb/tx/BufferList.class b/src/simpledb/tx/BufferList.class
deleted file mode 100644
index bbe44dc..0000000
Binary files a/src/simpledb/tx/BufferList.class and /dev/null differ
diff --git a/src/simpledb/tx/BufferList.java b/src/simpledb/tx/BufferList.java
deleted file mode 100644
index fc40b5b..0000000
--- a/src/simpledb/tx/BufferList.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package simpledb.tx;
-
-import simpledb.server.SimpleDB;
-import simpledb.file.Block;
-import simpledb.buffer.*;
-import java.util.*;
-
-/**
- * Manages the transaction's currently-pinned buffers. 
- * @author Edward Sciore
- */
-class BufferList {
-   private Map<Block,Buffer> buffers = new HashMap<Block,Buffer>();
-   private List<Block> pins = new ArrayList<Block>();
-   private BufferMgr bufferMgr = SimpleDB.bufferMgr();
-   
-   /**
-    * Returns the buffer pinned to the specified block.
-    * The method returns null if the transaction has not
-    * pinned the block.
-    * @param blk a reference to the disk block
-    * @return the buffer pinned to that block
-    */
-   Buffer getBuffer(Block blk) {
-      return buffers.get(blk);
-   }
-   
-   /**
-    * Pins the block and keeps track of the buffer internally.
-    * @param blk a reference to the disk block
-    */
-   void pin(Block blk) {
-	  Buffer buff = bufferMgr.pin(blk);
-      buffers.put(blk, buff);
-      pins.add(blk);
-   }
-   
-   /**
-    * Appends a new block to the specified file
-    * and pins it.
-    * @param filename the name of the file
-    * @param fmtr the formatter used to initialize the new page
-    * @return a reference to the newly-created block
-    */
-   Block pinNew(String filename, PageFormatter fmtr) {
-	  Buffer buff = bufferMgr.pinNew(filename, fmtr);
-      Block blk = buff.block();
-      buffers.put(blk, buff);
-      pins.add(blk);
-      return blk;
-   }
-   
-   /**
-    * Unpins the specified block.
-    * @param blk a reference to the disk block
-    */
-   void unpin(Block blk) {
-	  Buffer buff = buffers.get(blk);
-      bufferMgr.unpin(buff);
-      pins.remove(blk);
-      if (!pins.contains(blk))
-         buffers.remove(blk);
-   }
-   
-   /**
-    * Unpins any buffers still pinned by this transaction.
-    */
-   void unpinAll() {
-      for (Block blk : pins) {
-    	 Buffer buff = buffers.get(blk);
-         bufferMgr.unpin(buff);
-      }
-      buffers.clear();
-      pins.clear();
-   }
-}
\ No newline at end of file
diff --git a/src/simpledb/tx/Transaction.class b/src/simpledb/tx/Transaction.class
deleted file mode 100644
index fc54d9e..0000000
Binary files a/src/simpledb/tx/Transaction.class and /dev/null differ
diff --git a/src/simpledb/tx/Transaction.java b/src/simpledb/tx/Transaction.java
deleted file mode 100644
index 64b17e5..0000000
--- a/src/simpledb/tx/Transaction.java
+++ /dev/null
@@ -1,206 +0,0 @@
-package simpledb.tx;
-
-import simpledb.server.SimpleDB;
-import simpledb.file.Block;
-import simpledb.buffer.*;
-import simpledb.tx.recovery.RecoveryMgr;
-import simpledb.tx.concurrency.ConcurrencyMgr;
-
-/**
- * Provides transaction management for clients,
- * ensuring that all transactions are serializable, recoverable,
- * and in general satisfy the ACID properties.
- * @author Edward Sciore
- */
-public class Transaction {
-   private static int nextTxNum = 0;
-   private static final int END_OF_FILE = -1;
-   private RecoveryMgr    recoveryMgr;
-   private ConcurrencyMgr concurMgr;
-   private int txnum;
-   private BufferList myBuffers = new BufferList();
-   
-   /**
-    * Creates a new transaction and its associated 
-    * recovery and concurrency managers.
-    * This constructor depends on the file, log, and buffer
-    * managers that it gets from the class
-    * {@link simpledb.server.SimpleDB}.
-    * Those objects are created during system initialization.
-    * Thus this constructor cannot be called until either
-    * {@link simpledb.server.SimpleDB#init(String)} or 
-    * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)} or
-    * is called first.
-    */
-   public Transaction() {
-      txnum       = nextTxNumber();
-      recoveryMgr = new RecoveryMgr(txnum);
-      concurMgr   = new ConcurrencyMgr();
-   }
-   
-   /**
-    * Commits the current transaction.
-    * Flushes all modified buffers (and their log records),
-    * writes and flushes a commit record to the log,
-    * releases all locks, and unpins any pinned buffers.
-    */
-   public void commit() {
-      recoveryMgr.commit();
-      concurMgr.release();
-      myBuffers.unpinAll();
-      System.out.println("transaction " + txnum + " committed");
-   }
-   
-   /**
-    * Rolls back the current transaction.
-    * Undoes any modified values,
-    * flushes those buffers,
-    * writes and flushes a rollback record to the log,
-    * releases all locks, and unpins any pinned buffers.
-    */
-   public void rollback() {
-      recoveryMgr.rollback();
-      concurMgr.release();
-      myBuffers.unpinAll();
-      System.out.println("transaction " + txnum + " rolled back");
-   }
-   
-   /**
-    * Flushes all modified buffers.
-    * Then goes through the log, rolling back all
-    * uncommitted transactions.  Finally, 
-    * writes a quiescent checkpoint record to the log.
-    * This method is called only during system startup,
-    * before user transactions begin.
-    */
-   public void recover() {
-      SimpleDB.bufferMgr().flushAll(txnum);
-      recoveryMgr.recover();
-   }
-   
-   /**
-    * Pins the specified block.
-    * The transaction manages the buffer for the client.
-    * @param blk a reference to the disk block
-    */
-   public void pin(Block blk) {
-      myBuffers.pin(blk);
-   }
-   
-   /**
-    * Unpins the specified block.
-    * The transaction looks up the buffer pinned to this block,
-    * and unpins it.
-    * @param blk a reference to the disk block
-    */
-   public void unpin(Block blk) {
-      myBuffers.unpin(blk);
-   }
-   
-   /**
-    * Returns the integer value stored at the
-    * specified offset of the specified block.
-    * The method first obtains an SLock on the block,
-    * then it calls the buffer to retrieve the value.
-    * @param blk a reference to a disk block
-    * @param offset the byte offset within the block
-    * @return the integer stored at that offset
-    */
-   public int getInt(Block blk, int offset) {
-      concurMgr.sLock(blk);
-      Buffer buff = myBuffers.getBuffer(blk);
-      return buff.getInt(offset);
-   }
-   
-   /**
-    * Returns the string value stored at the
-    * specified offset of the specified block.
-    * The method first obtains an SLock on the block,
-    * then it calls the buffer to retrieve the value.
-    * @param blk a reference to a disk block
-    * @param offset the byte offset within the block
-    * @return the string stored at that offset
-    */
-   public String getString(Block blk, int offset) {
-      concurMgr.sLock(blk);
-      Buffer buff = myBuffers.getBuffer(blk);
-      return buff.getString(offset);
-   }
-   
-   /**
-    * Stores an integer at the specified offset 
-    * of the specified block.
-    * The method first obtains an XLock on the block.
-    * It then reads the current value at that offset,
-    * puts it into an update log record, and 
-    * writes that record to the log.
-    * Finally, it calls the buffer to store the value,
-    * passing in the LSN of the log record and the transaction's id. 
-    * @param blk a reference to the disk block
-    * @param offset a byte offset within that block
-    * @param val the value to be stored
-    */
-   public void setInt(Block blk, int offset, int val) {
-      concurMgr.xLock(blk);
-      Buffer buff = myBuffers.getBuffer(blk);
-      int lsn = recoveryMgr.setInt(buff, offset, val);
-      buff.setInt(offset, val, txnum, lsn);
-   }
-   
-   /**
-    * Stores a string at the specified offset 
-    * of the specified block.
-    * The method first obtains an XLock on the block.
-    * It then reads the current value at that offset,
-    * puts it into an update log record, and 
-    * writes that record to the log.
-    * Finally, it calls the buffer to store the value,
-    * passing in the LSN of the log record and the transaction's id. 
-    * @param blk a reference to the disk block
-    * @param offset a byte offset within that block
-    * @param val the value to be stored
-    */
-   public void setString(Block blk, int offset, String val) {
-      concurMgr.xLock(blk);
-      Buffer buff = myBuffers.getBuffer(blk);
-      int lsn = recoveryMgr.setString(buff, offset, val);
-      buff.setString(offset, val, txnum, lsn);
-   }
-   
-   /**
-    * Returns the number of blocks in the specified file.
-    * This method first obtains an SLock on the 
-    * "end of the file", before asking the file manager
-    * to return the file size.
-    * @param filename the name of the file
-    * @return the number of blocks in the file
-    */
-   public int size(String filename) {
-      Block dummyblk = new Block(filename, END_OF_FILE);
-      concurMgr.sLock(dummyblk);
-      return SimpleDB.fileMgr().size(filename);
-   }
-   
-   /**
-    * Appends a new block to the end of the specified file
-    * and returns a reference to it.
-    * This method first obtains an XLock on the
-    * "end of the file", before performing the append.
-    * @param filename the name of the file
-    * @param fmtr the formatter used to initialize the new page
-    * @return a reference to the newly-created disk block
-    */
-   public Block append(String filename, PageFormatter fmtr) {
-      Block dummyblk = new Block(filename, END_OF_FILE);
-      concurMgr.xLock(dummyblk);
-      Block blk = myBuffers.pinNew(filename, fmtr);
-      unpin(blk);
-      return blk;
-   }
-   
-   private static synchronized int nextTxNumber() {
-      nextTxNum++;
-      System.out.println("new transaction: " + nextTxNum);
-      return nextTxNum;
-   }
-}
diff --git a/src/simpledb/tx/concurrency/ConcurrencyMgr.class b/src/simpledb/tx/concurrency/ConcurrencyMgr.class
deleted file mode 100644
index 42830b7..0000000
Binary files a/src/simpledb/tx/concurrency/ConcurrencyMgr.class and /dev/null differ
diff --git a/src/simpledb/tx/concurrency/ConcurrencyMgr.java b/src/simpledb/tx/concurrency/ConcurrencyMgr.java
deleted file mode 100644
index b49fab7..0000000
--- a/src/simpledb/tx/concurrency/ConcurrencyMgr.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package simpledb.tx.concurrency;
-
-import simpledb.file.Block;
-import java.util.*;
-
-/**
- * The concurrency manager for the transaction.
- * Each transaction has its own concurrency manager. 
- * The concurrency manager keeps track of which locks the 
- * transaction currently has, and interacts with the
- * global lock table as needed. 
- * @author Edward Sciore
- */
-public class ConcurrencyMgr {
-   
-   /**
-    * The global lock table.  This variable is static because all transactions
-    * share the same table.
-    */
-   private static LockTable locktbl = new LockTable();
-   private Map<Block,String> locks  = new HashMap<Block,String>();
-   
-   /**
-    * Obtains an SLock on the block, if necessary.
-    * The method will ask the lock table for an SLock
-    * if the transaction currently has no locks on that block.
-    * @param blk a reference to the disk block
-    */
-   public void sLock(Block blk) {
-      if (locks.get(blk) == null) {
-         locktbl.sLock(blk);
-         locks.put(blk, "S");
-      }
-   }
-   
-   /**
-    * Obtains an XLock on the block, if necessary.
-    * If the transaction does not have an XLock on that block,
-    * then the method first gets an SLock on that block
-    * (if necessary), and then upgrades it to an XLock.
-    * @param blk a refrence to the disk block
-    */
-   public void xLock(Block blk) {
-      if (!hasXLock(blk)) {
-         sLock(blk);
-         locktbl.xLock(blk);
-         locks.put(blk, "X");
-      }
-   }
-   
-   /**
-    * Releases all locks by asking the lock table to
-    * unlock each one.
-    */
-   public void release() {
-      for (Block blk : locks.keySet())
-         locktbl.unlock(blk);
-      locks.clear();
-   }
-   
-   private boolean hasXLock(Block blk) {
-      String locktype = locks.get(blk);
-      return locktype != null && locktype.equals("X");
-   }
-}
diff --git a/src/simpledb/tx/concurrency/LockAbortException.class b/src/simpledb/tx/concurrency/LockAbortException.class
deleted file mode 100644
index c5e08a1..0000000
Binary files a/src/simpledb/tx/concurrency/LockAbortException.class and /dev/null differ
diff --git a/src/simpledb/tx/concurrency/LockAbortException.java b/src/simpledb/tx/concurrency/LockAbortException.java
deleted file mode 100644
index 8b54c7e..0000000
--- a/src/simpledb/tx/concurrency/LockAbortException.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package simpledb.tx.concurrency;
-
-/**
- * A runtime exception indicating that the transaction
- * needs to abort because a lock could not be obtained.
- * @author Edward Sciore
- */
-@SuppressWarnings("serial")
-public class LockAbortException extends RuntimeException {
-   public LockAbortException() {
-   }
-}
diff --git a/src/simpledb/tx/concurrency/LockTable.class b/src/simpledb/tx/concurrency/LockTable.class
deleted file mode 100644
index c020e4a..0000000
Binary files a/src/simpledb/tx/concurrency/LockTable.class and /dev/null differ
diff --git a/src/simpledb/tx/concurrency/LockTable.java b/src/simpledb/tx/concurrency/LockTable.java
deleted file mode 100644
index 84ecad2..0000000
--- a/src/simpledb/tx/concurrency/LockTable.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package simpledb.tx.concurrency;
-
-import simpledb.file.Block;
-import java.util.*;
-
-/**
- * The lock table, which provides methods to lock and unlock blocks.
- * If a transaction requests a lock that causes a conflict with an
- * existing lock, then that transaction is placed on a wait list.
- * There is only one wait list for all blocks.
- * When the last lock on a block is unlocked, then all transactions
- * are removed from the wait list and rescheduled.
- * If one of those transactions discovers that the lock it is waiting for
- * is still locked, it will place itself back on the wait list.
- * @author Edward Sciore
- */
-class LockTable {
-   private static final long MAX_TIME = 10000; // 10 seconds
-   
-   private Map<Block,Integer> locks = new HashMap<Block,Integer>();
-   
-   /**
-    * Grants an SLock on the specified block.
-    * If an XLock exists when the method is called,
-    * then the calling thread will be placed on a wait list
-    * until the lock is released.
-    * If the thread remains on the wait list for a certain 
-    * amount of time (currently 10 seconds),
-    * then an exception is thrown.
-    * @param blk a reference to the disk block
-    */
-   public synchronized void sLock(Block blk) {
-      try {
-         long timestamp = System.currentTimeMillis();
-         while (hasXlock(blk) && !waitingTooLong(timestamp))
-            wait(MAX_TIME);
-         if (hasXlock(blk))
-            throw new LockAbortException();
-         int val = getLockVal(blk);  // will not be negative
-         locks.put(blk, val+1);
-      }
-      catch(InterruptedException e) {
-         throw new LockAbortException();
-      }
-   }
-   
-   /**
-    * Grants an XLock on the specified block.
-    * If a lock of any type exists when the method is called,
-    * then the calling thread will be placed on a wait list
-    * until the locks are released.
-    * If the thread remains on the wait list for a certain 
-    * amount of time (currently 10 seconds),
-    * then an exception is thrown.
-    * @param blk a reference to the disk block
-    */
-   synchronized void xLock(Block blk) {
-      try {
-         long timestamp = System.currentTimeMillis();
-         while (hasOtherSLocks(blk) && !waitingTooLong(timestamp))
-            wait(MAX_TIME);
-         if (hasOtherSLocks(blk))
-            throw new LockAbortException();
-         locks.put(blk, -1);
-      }
-      catch(InterruptedException e) {
-         throw new LockAbortException();
-      }
-   }
-   
-   /**
-    * Releases a lock on the specified block.
-    * If this lock is the last lock on that block,
-    * then the waiting transactions are notified.
-    * @param blk a reference to the disk block
-    */
-   synchronized void unlock(Block blk) {
-      int val = getLockVal(blk);
-      if (val > 1)
-         locks.put(blk, val-1);
-      else {
-         locks.remove(blk);
-         notifyAll();
-      }
-   }
-   
-   private boolean hasXlock(Block blk) {
-      return getLockVal(blk) < 0;
-   }
-   
-   private boolean hasOtherSLocks(Block blk) {
-      return getLockVal(blk) > 1;
-   }
-   
-   private boolean waitingTooLong(long starttime) {
-      return System.currentTimeMillis() - starttime > MAX_TIME;
-   }
-   
-   private int getLockVal(Block blk) {
-      Integer ival = locks.get(blk);
-      return (ival == null) ? 0 : ival.intValue();
-   }
-}
diff --git a/src/simpledb/tx/recovery/CheckpointRecord.class b/src/simpledb/tx/recovery/CheckpointRecord.class
deleted file mode 100644
index 931646c..0000000
Binary files a/src/simpledb/tx/recovery/CheckpointRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/CheckpointRecord.java b/src/simpledb/tx/recovery/CheckpointRecord.java
deleted file mode 100644
index 632bacb..0000000
--- a/src/simpledb/tx/recovery/CheckpointRecord.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.log.BasicLogRecord;
-
-/**
- * The CHECKPOINT log record.
- * @author Edward Sciore
- */
-class CheckpointRecord implements LogRecord {
-   
-   /**
-    * Creates a quiescent checkpoint record.
-    */
-   public CheckpointRecord() {}
-   
-   /**
-    * Creates a log record by reading no other values 
-    * from the basic log record.
-    * @param rec the basic log record
-    */
-   public CheckpointRecord(BasicLogRecord rec) {}
-   
-   /** 
-    * Writes a checkpoint record to the log.
-    * This log record contains the CHECKPOINT operator,
-    * and nothing else.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {CHECKPOINT};
-      return logMgr.append(rec);
-   }
-   
-   public int op() {
-      return CHECKPOINT;
-   }
-   
-   /**
-    * Checkpoint records have no associated transaction,
-    * and so the method returns a "dummy", negative txid.
-    */
-   public int txNumber() {
-      return -1; // dummy value
-   }
-   
-   /**
-    * Does nothing, because a checkpoint record
-    * contains no undo information.
-    */
-   public void undo(int txnum) {}
-   
-   public String toString() {
-      return "<CHECKPOINT>";
-   }
-}
diff --git a/src/simpledb/tx/recovery/CommitRecord.class b/src/simpledb/tx/recovery/CommitRecord.class
deleted file mode 100644
index 33ea1fd..0000000
Binary files a/src/simpledb/tx/recovery/CommitRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/CommitRecord.java b/src/simpledb/tx/recovery/CommitRecord.java
deleted file mode 100644
index d62f993..0000000
--- a/src/simpledb/tx/recovery/CommitRecord.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.log.BasicLogRecord;
-
-/**
- * The COMMIT log record
- * @author Edward Sciore
- */
-class CommitRecord implements LogRecord {
-   private int txnum;
-   
-   /**
-    * Creates a new commit log record for the specified transaction.
-    * @param txnum the ID of the specified transaction
-    */
-   public CommitRecord(int txnum) {
-      this.txnum = txnum;
-   }
-   
-   /**
-    * Creates a log record by reading one other value from the log.
-    * @param rec the basic log record
-    */
-   public CommitRecord(BasicLogRecord rec) {
-      txnum = rec.nextInt();
-   }
-   
-   /** 
-    * Writes a commit record to the log.
-    * This log record contains the COMMIT operator,
-    * followed by the transaction id.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {COMMIT, txnum};
-      return logMgr.append(rec);
-   }
-   
-   public int op() {
-      return COMMIT;
-   }
-   
-   public int txNumber() {
-      return txnum;
-   }
-   
-   /**
-    * Does nothing, because a commit record
-    * contains no undo information.
-    */
-   public void undo(int txnum) {}
-   
-   public String toString() {
-      return "<COMMIT " + txnum + ">";
-   }
-}
diff --git a/src/simpledb/tx/recovery/LogRecord.class b/src/simpledb/tx/recovery/LogRecord.class
deleted file mode 100644
index 90cbdc5..0000000
Binary files a/src/simpledb/tx/recovery/LogRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/LogRecord.java b/src/simpledb/tx/recovery/LogRecord.java
deleted file mode 100644
index 8987b1f..0000000
--- a/src/simpledb/tx/recovery/LogRecord.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.log.LogMgr;
-import simpledb.server.SimpleDB;
-
-/**
- * The interface implemented by each type of log record.
- * @author Edward Sciore
- */
-public interface LogRecord {
-   /**
-    * The six different types of log record
-    */
-   static final int CHECKPOINT = 0, START = 1,
-      COMMIT = 2, ROLLBACK  = 3,
-      SETINT = 4, SETSTRING = 5;
-   
-   static final LogMgr logMgr = SimpleDB.logMgr();
-   
-   /**
-    * Writes the record to the log and returns its LSN.
-    * @return the LSN of the record in the log
-    */
-   int writeToLog();
-   
-   /**
-    * Returns the log record's type. 
-    * @return the log record's type
-    */
-   int op();
-   
-   /**
-    * Returns the transaction id stored with
-    * the log record.
-    * @return the log record's transaction id
-    */
-   int txNumber();
-   
-   /**
-    * Undoes the operation encoded by this log record.
-    * The only log record types for which this method
-    * does anything interesting are SETINT and SETSTRING.
-    * @param txnum the id of the transaction that is performing the undo.
-    */
-   void undo(int txnum);
-}
\ No newline at end of file
diff --git a/src/simpledb/tx/recovery/LogRecordIterator.class b/src/simpledb/tx/recovery/LogRecordIterator.class
deleted file mode 100644
index bf9e847..0000000
Binary files a/src/simpledb/tx/recovery/LogRecordIterator.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/LogRecordIterator.java b/src/simpledb/tx/recovery/LogRecordIterator.java
deleted file mode 100644
index a9a3051..0000000
--- a/src/simpledb/tx/recovery/LogRecordIterator.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package simpledb.tx.recovery;
-
-import static simpledb.tx.recovery.LogRecord.*;
-import java.util.Iterator;
-import simpledb.log.BasicLogRecord;
-import simpledb.server.SimpleDB;
-
-/**
- * A class that provides the ability to read records
- * from the log in reverse order.
- * Unlike the similar class 
- * {@link simpledb.log.LogIterator LogIterator},  
- * this class understands the meaning of the log records.
- * @author Edward Sciore
- */
-class LogRecordIterator implements Iterator<LogRecord> {
-   private Iterator<BasicLogRecord> iter = SimpleDB.logMgr().iterator();
-   
-   public boolean hasNext() {
-      return iter.hasNext();
-   }
-   
-   /**
-    * Constructs a log record from the values in the 
-    * current basic log record.
-    * The method first reads an integer, which denotes
-    * the type of the log record.  Based on that type,
-    * the method calls the appropriate LogRecord constructor
-    * to read the remaining values.
-    * @return the next log record, or null if no more records
-    */
-   public LogRecord next() {
-      BasicLogRecord rec = iter.next();
-      int op = rec.nextInt();
-      switch (op) {
-         case CHECKPOINT:
-            return new CheckpointRecord(rec);
-         case START:
-            return new StartRecord(rec);
-         case COMMIT:
-            return new CommitRecord(rec);
-         case ROLLBACK:
-            return new RollbackRecord(rec);
-         case SETINT:
-            return new SetIntRecord(rec);
-         case SETSTRING:
-            return new SetStringRecord(rec);
-         default:
-            return null;
-      }
-   } 
-   
-   public void remove() {
-      throw new UnsupportedOperationException();
-   }
-}
diff --git a/src/simpledb/tx/recovery/RecoveryMgr.class b/src/simpledb/tx/recovery/RecoveryMgr.class
deleted file mode 100644
index a4a92f4..0000000
Binary files a/src/simpledb/tx/recovery/RecoveryMgr.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/RecoveryMgr.java b/src/simpledb/tx/recovery/RecoveryMgr.java
deleted file mode 100644
index c2a5900..0000000
--- a/src/simpledb/tx/recovery/RecoveryMgr.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package simpledb.tx.recovery;
-
-import static simpledb.tx.recovery.LogRecord.CHECKPOINT;
-import static simpledb.tx.recovery.LogRecord.COMMIT;
-import static simpledb.tx.recovery.LogRecord.ROLLBACK;
-import static simpledb.tx.recovery.LogRecord.START;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-
-import simpledb.buffer.Buffer;
-import simpledb.file.Block;
-import simpledb.server.SimpleDB;
-
-/**
- * The recovery manager.  Each transaction has its own recovery manager.
- * @author Edward Sciore
- */
-public class RecoveryMgr {
-   private int txnum;
-
-   /**
-    * Creates a recovery manager for the specified transaction.
-    * @param txnum the ID of the specified transaction
-    */
-   public RecoveryMgr(int txnum) {
-      this.txnum = txnum;
-      new StartRecord(txnum).writeToLog();
-   }
-
-   /**
-    * Writes a commit record to the log, and flushes it to disk.
-    */
-   public void commit() {
-      SimpleDB.bufferMgr().flushAll(txnum);
-      int lsn = new CommitRecord(txnum).writeToLog();
-      SimpleDB.logMgr().flush(lsn);
-   }
-
-   /**
-    * Writes a rollback record to the log, and flushes it to disk.
-    */
-   public void rollback() {
-      doRollback();
-      SimpleDB.bufferMgr().flushAll(txnum);
-      int lsn = new RollbackRecord(txnum).writeToLog();
-      SimpleDB.logMgr().flush(lsn);
-   }
-
-   /**
-    * Recovers uncompleted transactions from the log,
-    * then writes a quiescent checkpoint record to the log and flushes it.
-    */
-   public void recover() {
-      doRecover();
-      SimpleDB.bufferMgr().flushAll(txnum);
-      int lsn = new CheckpointRecord().writeToLog();
-      SimpleDB.logMgr().flush(lsn);
-
-   }
-
-   /**
-    * Writes a setint record to the log, and returns its lsn.
-    * Updates to temporary files are not logged; instead, a
-    * "dummy" negative lsn is returned.
-    * @param buff the buffer containing the page
-    * @param offset the offset of the value in the page
-    * @param newval the value to be written
-    */
-   public int setInt(Buffer buff, int offset, int newval) {
-      int oldval = buff.getInt(offset);
-      Block blk = buff.block();
-      if (isTempBlock(blk))
-         return -1;
-      else
-         return new SetIntRecord(txnum, blk, offset, oldval).writeToLog();
-   }
-
-   /**
-    * Writes a setstring record to the log, and returns its lsn.
-    * Updates to temporary files are not logged; instead, a
-    * "dummy" negative lsn is returned.
-    * @param buff the buffer containing the page
-    * @param offset the offset of the value in the page
-    * @param newval the value to be written
-    */
-   public int setString(Buffer buff, int offset, String newval) {
-      String oldval = buff.getString(offset);
-      Block blk = buff.block();
-      if (isTempBlock(blk))
-         return -1;
-      else
-         return new SetStringRecord(txnum, blk, offset, oldval).writeToLog();
-   }
-
-   /**
-    * Rolls back the transaction.
-    * The method iterates through the log records,
-    * calling undo() for each log record it finds
-    * for the transaction,
-    * until it finds the transaction's START record.
-    */
-   private void doRollback() {
-      Iterator<LogRecord> iter = new LogRecordIterator();
-      while (iter.hasNext()) {
-         LogRecord rec = iter.next();
-         if (rec.txNumber() == txnum) {
-            if (rec.op() == START)
-               return;
-            rec.undo(txnum);
-         }
-      }
-   }
-
-   /**
-    * Does a complete database recovery.
-    * The method iterates through the log records.
-    * Whenever it finds a log record for an unfinished
-    * transaction, it calls undo() on that record.
-    * The method stops when it encounters a CHECKPOINT record
-    * or the end of the log.
-    */
-   private void doRecover() {
-      Collection<Integer> finishedTxs = new ArrayList<Integer>();
-      Iterator<LogRecord> iter = new LogRecordIterator();
-      while (iter.hasNext()) {
-         LogRecord rec = iter.next();
-         if (rec.op() == CHECKPOINT)
-            return;
-         if (rec.op() == COMMIT || rec.op() == ROLLBACK)
-            finishedTxs.add(rec.txNumber());
-         else if (!finishedTxs.contains(rec.txNumber()))
-            rec.undo(txnum);
-      }
-   }
-
-   /**
-    * Determines whether a block comes from a temporary file or not.
-    */
-   private boolean isTempBlock(Block blk) {
-      return blk.fileName().startsWith("temp");
-   }
-}
diff --git a/src/simpledb/tx/recovery/RollbackRecord.class b/src/simpledb/tx/recovery/RollbackRecord.class
deleted file mode 100644
index 17eb468..0000000
Binary files a/src/simpledb/tx/recovery/RollbackRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/RollbackRecord.java b/src/simpledb/tx/recovery/RollbackRecord.java
deleted file mode 100644
index f47a24d..0000000
--- a/src/simpledb/tx/recovery/RollbackRecord.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.log.BasicLogRecord;
-
-/**
- * The ROLLBACK log record.
- * @author Edward Sciore
- */
-class RollbackRecord implements LogRecord {
-   private int txnum;
-   
-   /**
-    * Creates a new rollback log record for the specified transaction.
-    * @param txnum the ID of the specified transaction
-    */
-   public RollbackRecord(int txnum) {
-      this.txnum = txnum;
-   }
-   
-   /**
-    * Creates a log record by reading one other value from the log.
-    * @param rec the basic log record
-    */
-   public RollbackRecord(BasicLogRecord rec) {
-      txnum = rec.nextInt();
-   }
-   
-   /** 
-    * Writes a rollback record to the log.
-    * This log record contains the ROLLBACK operator,
-    * followed by the transaction id.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {ROLLBACK, txnum};
-      return logMgr.append(rec);
-   }
-   
-   public int op() {
-      return ROLLBACK;
-   }
-   
-   public int txNumber() {
-      return txnum;
-   }
-   
-   /**
-    * Does nothing, because a rollback record
-    * contains no undo information.
-    */
-   public void undo(int txnum) {}
-   
-   public String toString() {
-      return "<ROLLBACK " + txnum + ">";
-   }
-}
diff --git a/src/simpledb/tx/recovery/SetIntRecord.class b/src/simpledb/tx/recovery/SetIntRecord.class
deleted file mode 100644
index d01dc8f..0000000
Binary files a/src/simpledb/tx/recovery/SetIntRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/SetIntRecord.java b/src/simpledb/tx/recovery/SetIntRecord.java
deleted file mode 100644
index 3305655..0000000
--- a/src/simpledb/tx/recovery/SetIntRecord.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.server.SimpleDB;
-import simpledb.buffer.*;
-import simpledb.file.Block;
-import simpledb.log.BasicLogRecord;
-
-class SetIntRecord implements LogRecord {
-   private int txnum, offset, val;
-   private Block blk;
-
-   /**
-    * Creates a new setint log record.
-    * @param txnum the ID of the specified transaction
-    * @param blk the block containing the value
-    * @param offset the offset of the value in the block
-    * @param val the new value
-    */
-   public SetIntRecord(int txnum, Block blk, int offset, int val) {
-      this.txnum = txnum;
-      this.blk = blk;
-      this.offset = offset;
-      this.val = val;
-   }
-
-   /**
-    * Creates a log record by reading five other values from the log.
-    * @param rec the basic log record
-    */
-   public SetIntRecord(BasicLogRecord rec) {
-      txnum = rec.nextInt();
-      String filename = rec.nextString();
-      int blknum = rec.nextInt();
-      blk = new Block(filename, blknum);
-      offset = rec.nextInt();
-      val = rec.nextInt();
-   }
-
-   /**
-    * Writes a setInt record to the log.
-    * This log record contains the SETINT operator,
-    * followed by the transaction id, the filename, number,
-    * and offset of the modified block, and the previous
-    * integer value at that offset.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {SETINT, txnum, blk.fileName(),
-         blk.number(), offset, val};
-      return logMgr.append(rec);
-   }
-
-   public int op() {
-      return SETINT;
-   }
-
-   public int txNumber() {
-      return txnum;
-   }
-
-   public String toString() {
-      return "<SETINT " + txnum + " " + blk + " " + offset + " " + val + ">";
-   }
-
-   /**
-    * Replaces the specified data value with the value saved in the log record.
-    * The method pins a buffer to the specified block,
-    * calls setInt to restore the saved value
-    * (using a dummy LSN), and unpins the buffer.
-    * @see simpledb.tx.recovery.LogRecord#undo(int)
-    */
-   public void undo(int txnum) {
-      BufferMgr buffMgr = SimpleDB.bufferMgr();
-      Buffer buff = buffMgr.pin(blk);
-      buff.setInt(offset, val, txnum, -1);
-      buffMgr.unpin(buff);
-   }
-}
diff --git a/src/simpledb/tx/recovery/SetStringRecord.class b/src/simpledb/tx/recovery/SetStringRecord.class
deleted file mode 100644
index 96658bf..0000000
Binary files a/src/simpledb/tx/recovery/SetStringRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/SetStringRecord.java b/src/simpledb/tx/recovery/SetStringRecord.java
deleted file mode 100644
index b22a2ec..0000000
--- a/src/simpledb/tx/recovery/SetStringRecord.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.server.SimpleDB;
-import simpledb.buffer.*;
-import simpledb.file.Block;
-import simpledb.log.BasicLogRecord;
-
-class SetStringRecord implements LogRecord {
-   private int txnum, offset;
-   private String val;
-   private Block blk;
-   
-   /**
-    * Creates a new setstring log record.
-    * @param txnum the ID of the specified transaction
-    * @param blk the block containing the value
-    * @param offset the offset of the value in the block
-    * @param val the new value
-    */
-   public SetStringRecord(int txnum, Block blk, int offset, String val) {
-      this.txnum = txnum;
-      this.blk = blk;
-      this.offset = offset;
-      this.val = val;
-   }
-   
-   /**
-    * Creates a log record by reading five other values from the log.
-    * @param rec the basic log record
-    */
-   public SetStringRecord(BasicLogRecord rec) {
-      txnum = rec.nextInt();
-      String filename = rec.nextString();
-      int blknum = rec.nextInt();
-      blk = new Block(filename, blknum);
-      offset = rec.nextInt();
-      val = rec.nextString();
-   }
-   
-   /** 
-    * Writes a setString record to the log.
-    * This log record contains the SETSTRING operator,
-    * followed by the transaction id, the filename, number,
-    * and offset of the modified block, and the previous
-    * string value at that offset.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {SETSTRING, txnum, blk.fileName(),
-         blk.number(), offset, val};
-      return logMgr.append(rec);
-   }
-   
-   public int op() {
-      return SETSTRING;
-   }
-   
-   public int txNumber() {
-      return txnum;
-   }
-   
-   public String toString() {
-      return "<SETSTRING " + txnum + " " + blk + " " + offset + " " + val + ">";
-   }
-   
-   /** 
-    * Replaces the specified data value with the value saved in the log record.
-    * The method pins a buffer to the specified block,
-    * calls setString to restore the saved value
-    * (using a dummy LSN), and unpins the buffer.
-    * @see simpledb.tx.recovery.LogRecord#undo(int)
-    */
-   public void undo(int txnum) {
-      BufferMgr buffMgr = SimpleDB.bufferMgr();
-      Buffer buff = buffMgr.pin(blk);
-      buff.setString(offset, val, txnum, -1);
-      buffMgr.unpin(buff);
-   }
-}
diff --git a/src/simpledb/tx/recovery/StartRecord.class b/src/simpledb/tx/recovery/StartRecord.class
deleted file mode 100644
index af64ed6..0000000
Binary files a/src/simpledb/tx/recovery/StartRecord.class and /dev/null differ
diff --git a/src/simpledb/tx/recovery/StartRecord.java b/src/simpledb/tx/recovery/StartRecord.java
deleted file mode 100644
index 38ea028..0000000
--- a/src/simpledb/tx/recovery/StartRecord.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package simpledb.tx.recovery;
-
-import simpledb.log.BasicLogRecord;
-
-class StartRecord implements LogRecord {
-   private int txnum;
-   
-   /**
-    * Creates a new start log record for the specified transaction.
-    * @param txnum the ID of the specified transaction
-    */
-   public StartRecord(int txnum) {
-      this.txnum = txnum;
-   }
-   
-   /**
-    * Creates a log record by reading one other value from the log.
-    * @param rec the basic log record
-    */
-   public StartRecord(BasicLogRecord rec) {
-      txnum = rec.nextInt();
-   }
-   
-   /** 
-    * Writes a start record to the log.
-    * This log record contains the START operator,
-    * followed by the transaction id.
-    * @return the LSN of the last log value
-    */
-   public int writeToLog() {
-      Object[] rec = new Object[] {START, txnum};
-      return logMgr.append(rec);
-   }
-   
-   public int op() {
-      return START;
-   }
-   
-   public int txNumber() {
-      return txnum;
-   }
-   
-   /**
-    * Does nothing, because a start record
-    * contains no undo information.
-    */
-   public void undo(int txnum) {}
-   
-   public String toString() {
-      return "<START " + txnum + ">";
-   }
-}
diff --git a/studentClient/derby/ChangeMajor.class b/studentClient/derby/ChangeMajor.class
new file mode 100755
index 0000000..da9438c
Binary files /dev/null and b/studentClient/derby/ChangeMajor.class differ
diff --git a/studentClient/derby/ChangeMajor.java b/studentClient/derby/ChangeMajor.java
new file mode 100755
index 0000000..d8ee0cc
--- /dev/null
+++ b/studentClient/derby/ChangeMajor.java
@@ -0,0 +1,29 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class ChangeMajor {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+			Statement stmt = conn.createStatement();
+
+			stmt.executeUpdate("update STUDENT set MajorId=30 where SName='amy'");
+			System.out.println("Amy is now a drama major.");
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/CreateStudentDB.class b/studentClient/derby/CreateStudentDB.class
new file mode 100755
index 0000000..48c411f
Binary files /dev/null and b/studentClient/derby/CreateStudentDB.class differ
diff --git a/studentClient/derby/CreateStudentDB.java b/studentClient/derby/CreateStudentDB.java
new file mode 100755
index 0000000..437c05b
--- /dev/null
+++ b/studentClient/derby/CreateStudentDB.java
@@ -0,0 +1,101 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class CreateStudentDB {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb;create=true";
+			conn = d.connect(url, null);
+			Statement stmt = conn.createStatement();
+
+			String s = "create table STUDENT(SId int, SName varchar(10), MajorId int, GradYear int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table STUDENT created.");
+
+			s = "insert into STUDENT(SId, SName, MajorId, GradYear) values ";
+			String[] studvals = {"(1, 'joe', 10, 2004)",
+								 "(2, 'amy', 20, 2004)",
+								 "(3, 'max', 10, 2005)",
+								 "(4, 'sue', 20, 2005)",
+								 "(5, 'bob', 30, 2003)",
+								 "(6, 'kim', 20, 2001)",
+								 "(7, 'art', 30, 2004)",
+								 "(8, 'pat', 20, 2001)",
+								 "(9, 'lee', 10, 2004)"};
+			for (int i=0; i<studvals.length; i++)
+				stmt.executeUpdate(s + studvals[i]);
+			System.out.println("STUDENT records inserted.");
+
+			s = "create table DEPT(DId int, DName varchar(8))";
+			stmt.executeUpdate(s);
+			System.out.println("Table DEPT created.");
+
+			s = "insert into DEPT(DId, DName) values ";
+			String[] deptvals = {"(10, 'compsci')",
+								 "(20, 'math')",
+								 "(30, 'drama')"};
+			for (int i=0; i<deptvals.length; i++)
+				stmt.executeUpdate(s + deptvals[i]);
+			System.out.println("DEPT records inserted.");
+
+			s = "create table COURSE(CId int, Title varchar(20), DeptId int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table COURSE created.");
+
+			s = "insert into COURSE(CId, Title, DeptId) values ";
+			String[] coursevals = {"(12, 'db systems', 10)",
+								   "(22, 'compilers', 10)",
+								   "(32, 'calculus', 20)",
+								   "(42, 'algebra', 20)",
+								   "(52, 'acting', 30)",
+								   "(62, 'elocution', 30)"};
+			for (int i=0; i<coursevals.length; i++)
+				stmt.executeUpdate(s + coursevals[i]);
+			System.out.println("COURSE records inserted.");
+
+			s = "create table SECTION(SectId int, CourseId int, Prof varchar(8), YearOffered int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table SECTION created.");
+
+			s = "insert into SECTION(SectId, CourseId, Prof, YearOffered) values ";
+			String[] sectvals = {"(13, 12, 'turing', 2004)",
+								 "(23, 12, 'turing', 2005)",
+								 "(33, 32, 'newton', 2000)",
+								 "(43, 32, 'einstein', 2001)",
+								 "(53, 62, 'brando', 2001)"};
+			for (int i=0; i<sectvals.length; i++)
+				stmt.executeUpdate(s + sectvals[i]);
+			System.out.println("SECTION records inserted.");
+
+			s = "create table ENROLL(EId int, StudentId int, SectionId int, Grade varchar(2))";
+			stmt.executeUpdate(s);
+			System.out.println("Table ENROLL created.");
+
+			s = "insert into ENROLL(EId, StudentId, SectionId, Grade) values ";
+			String[] enrollvals = {"(14, 1, 13, 'A')",
+								   "(24, 1, 43, 'C' )",
+								   "(34, 2, 43, 'B+')",
+								   "(44, 4, 33, 'B' )",
+								   "(54, 4, 53, 'A' )",
+								   "(64, 6, 53, 'A' )"};
+			for (int i=0; i<enrollvals.length; i++)
+				stmt.executeUpdate(s + enrollvals[i]);
+			System.out.println("ENROLL records inserted.");
+
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/FindMajors.class b/studentClient/derby/FindMajors.class
new file mode 100755
index 0000000..43ee26a
Binary files /dev/null and b/studentClient/derby/FindMajors.class differ
diff --git a/studentClient/derby/FindMajors.java b/studentClient/derby/FindMajors.java
new file mode 100755
index 0000000..0144e9c
--- /dev/null
+++ b/studentClient/derby/FindMajors.java
@@ -0,0 +1,47 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class FindMajors {
+    public static void main(String[] args) {
+		String major = args[0];
+		System.out.println("Here are the " + major + " majors");
+		System.out.println("Name\tGradYear");
+
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select sname, gradyear "
+			           + "from student, dept "
+			           + "where did = majorid "
+			           + "and dname = '" + major + "'";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			// Step 3: loop through the result set
+			while (rs.next()) {
+				String sname = rs.getString("sname");
+				int gradyear = rs.getInt("gradyear");
+				System.out.println(sname + "\t" + gradyear);
+			}
+			rs.close();
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/Course.class b/studentClient/derby/JPAStudentInfo/Course.class
new file mode 100755
index 0000000..5359a72
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Course.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Course.java b/studentClient/derby/JPAStudentInfo/Course.java
new file mode 100755
index 0000000..4ebe7bf
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Course.java
@@ -0,0 +1,44 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Course {
+
+    @Id private int cid;
+    private String title;
+
+    @OneToMany(mappedBy="course")
+    private Collection<Section> sections;
+
+    @ManyToOne
+    @JoinColumn(name="DeptId")
+    private Dept dept;
+
+	public Course() {}
+
+	public Course(int cid, String title, Dept dept) {
+		this.cid = cid;
+		this.title = title;
+		this.dept = dept;
+	}
+
+    public int getId() {
+        return cid;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void changeTitle(String title) {
+		this.title = title;
+	}
+
+    public Dept getDept() {
+		return dept;
+	}
+
+	public Collection<Section> getSections() {
+		return sections;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/Dept.class b/studentClient/derby/JPAStudentInfo/Dept.class
new file mode 100755
index 0000000..8d7b17a
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Dept.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Dept.java b/studentClient/derby/JPAStudentInfo/Dept.java
new file mode 100755
index 0000000..6165f40
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Dept.java
@@ -0,0 +1,35 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Dept {
+
+    @Id private int did;
+    private String dname;
+
+    @OneToMany(mappedBy="major")
+    private Collection<Student> majors;
+
+	public Dept() {}
+
+	public Dept(int did, String dname) {
+		this.did = did;
+		this.dname = dname;
+	}
+
+    public int getId() {
+        return did;
+    }
+
+    public String getName() {
+        return dname;
+    }
+
+    public void changeName(String newname) {
+        dname = newname;
+    }
+
+    public Collection<Student> getMajors() {
+		return majors;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/Enroll.class b/studentClient/derby/JPAStudentInfo/Enroll.class
new file mode 100755
index 0000000..3f22153
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Enroll.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Enroll.java b/studentClient/derby/JPAStudentInfo/Enroll.java
new file mode 100755
index 0000000..6ba8c04
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Enroll.java
@@ -0,0 +1,45 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Enroll {
+
+    @Id private int eid;
+    private String grade = null;
+
+    @ManyToOne
+    @JoinColumn(name="StudentId")
+    private Student student;
+
+    @ManyToOne
+    @JoinColumn(name="SectionId")
+    private Section section;
+
+	public Enroll() {}
+
+	public Enroll(int eid, Student student, Section section) {
+		this.eid = eid;
+		this.student = student;
+		this.section = section;
+	}
+
+    public int getId() {
+        return eid;
+    }
+
+    public Student getStudent() {
+        return student;
+    }
+
+	public Section getSection() {
+        return section;
+    }
+
+    public String getGrade() {
+		return grade;
+	}
+
+	public void changeGrade(String grade) {
+		this.grade = grade;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/JPAStudentInfo.class b/studentClient/derby/JPAStudentInfo/JPAStudentInfo.class
new file mode 100755
index 0000000..015ada1
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/JPAStudentInfo.class differ
diff --git a/studentClient/derby/JPAStudentInfo/JPAStudentInfo.java b/studentClient/derby/JPAStudentInfo/JPAStudentInfo.java
new file mode 100755
index 0000000..5de7871
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/JPAStudentInfo.java
@@ -0,0 +1,96 @@
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+import javax.swing.table.*;
+import javax.persistence.*;
+import java.util.Collection;
+
+public class JPAStudentInfo {
+	public static void main(String[] args) {
+        EntityManagerFactory emf = Persistence.createEntityManagerFactory("studentdb");
+        EntityManager em = emf.createEntityManager();
+   		JFrame frame = new TSFrame(em);
+    	frame.setVisible(true);
+    }
+}
+
+class TSFrame extends JFrame {
+	public TSFrame(EntityManager em) {
+		setTitle("Student Transcript Info");
+		setDefaultCloseOperation(EXIT_ON_CLOSE);
+        setSize(550,150);
+        setLocation(200,200);
+        getContentPane().add(new TSPanel(em));
+    }
+}
+
+class TSPanel extends JPanel {
+	private JLabel inputLbl  = new JLabel("Enter Student ID: ");
+	private JTextField txt   = new JTextField(4);
+	private JButton btn1     = new JButton("SHOW TRANSCRIPT");
+	private JButton btn2     = new JButton("CHANGE GRADYEAR");
+	private JButton btn3     = new JButton("CLOSE");
+	private JLabel outputLbl = new JLabel("");
+	private DefaultTableModel courses;
+	private EntityManager em;
+
+	public TSPanel(final EntityManager em) {
+		this.em = em;
+		Object[] columnNames = {"Title", "Year", "Grade"};
+		courses = new DefaultTableModel(columnNames, 0);
+		JTable tbl = new JTable(courses);
+		JScrollPane sp = new JScrollPane(tbl);
+		add(inputLbl); add(txt); add(btn1); add(btn2); add(btn3);
+		add(outputLbl); add(sp);
+
+		btn1.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent e) {
+					int sid = Integer.parseInt(txt.getText());
+					em.getTransaction().begin();
+					Student s = em.find(Student.class, sid);
+					display(s);
+					em.getTransaction().commit();
+				}
+			});
+
+		btn2.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent e) {
+					String yearstring = JOptionPane.showInputDialog("Enter new grad year");
+					int sid = Integer.parseInt(txt.getText());
+					int newyear = Integer.parseInt(yearstring);
+					em.getTransaction().begin();
+					Student s = em.find(Student.class, sid);
+					s.changeGradYear(newyear);
+					display(s);
+					em.getTransaction().commit();
+				}
+			});
+
+		btn3.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent e) {
+					em.close();
+					setVisible(false);
+					System.exit(0);
+				}
+			});
+	}
+
+	private void display(Student s) {
+		courses.setRowCount(0);
+		if (s == null)
+			outputLbl.setText("            No such student!");
+		else {
+			outputLbl.setText("Name: " + s.getName()
+			            + "    Graduation Year: " + s.getGradYear());
+			for (Enroll e : s.getEnrollments()) {
+				Section k = e.getSection();
+				Course  c = k.getCourse();
+				Object[] row = {c.getTitle(), k.getYearOffered(), e.getGrade()};
+				courses.addRow(row);
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/META-INF/persistence.xml b/studentClient/derby/JPAStudentInfo/META-INF/persistence.xml
new file mode 100755
index 0000000..b392050
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/META-INF/persistence.xml
@@ -0,0 +1,20 @@
+<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
+    <persistence-unit name="studentdb">
+        <provider>
+        	org.apache.openjpa.persistence.PersistenceProviderImpl
+        </provider>
+
+        <class>Student</class>
+        <class>Enroll</class>
+        <class>Section</class>
+        <class>Course</class>
+        <class>Dept</class>
+	<class>Permit</class>
+
+        <properties>
+            <property name="openjpa.ConnectionURL" value="jdbc:derby://localhost/studentdb"/>
+            <property name="openjpa.ConnectionDriverName" value="org.apache.derby.jdbc.ClientDriver"/>
+        </properties>
+    </persistence-unit>
+</persistence>
+
diff --git a/studentClient/derby/JPAStudentInfo/Permit.class b/studentClient/derby/JPAStudentInfo/Permit.class
new file mode 100755
index 0000000..30cda16
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Permit.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Permit.java b/studentClient/derby/JPAStudentInfo/Permit.java
new file mode 100755
index 0000000..1c2602f
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Permit.java
@@ -0,0 +1,47 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Permit {
+
+    @Id private int pid;
+    private String licensePlate;
+    private String carModel;
+
+    @OneToOne
+    @JoinColumn(name="StudId")
+    private Student student;
+
+	public Permit() {}
+
+	public Permit(int pid, String licensePlate, String carModel, Student s) {
+		this.pid = pid;
+		this.licensePlate = licensePlate;
+		this.carModel = carModel;
+		student = s;
+	}
+
+    public int getId() {
+        return pid;
+    }
+
+    public String getPlate() {
+        return licensePlate;
+    }
+
+    public void changePlate(String newplate) {
+        licensePlate = newplate;
+    }
+
+	public String getCarModel() {
+        return carModel;
+    }
+
+    public void changeCarModel(String newmodel) {
+        carModel = newmodel;
+    }
+
+    public Student getStudent() {
+		return student;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/Section.class b/studentClient/derby/JPAStudentInfo/Section.class
new file mode 100755
index 0000000..12e8af4
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Section.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Section.java b/studentClient/derby/JPAStudentInfo/Section.java
new file mode 100755
index 0000000..3a00404
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Section.java
@@ -0,0 +1,50 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Section {
+
+    @Id private int sectid;
+    private String prof;
+    private int yearOffered;
+
+    @OneToMany(mappedBy="section")
+    private Collection<Enroll> students;
+
+    @ManyToOne
+    @JoinColumn(name="CourseId")
+    private Course course;
+
+	public Section() {}
+
+	public Section(int sectid, String prof, int year, Course course) {
+		this.sectid = sectid;
+		this.prof = prof;
+		this.yearOffered = year;
+		this.course = course;
+	}
+
+    public int getId() {
+        return sectid;
+    }
+
+    public String getProf() {
+        return prof;
+    }
+
+    public void changeProf(String prof) {
+		this.prof = prof;
+	}
+
+	public int getYearOffered() {
+        return yearOffered;
+    }
+
+    public Course getCourse() {
+		return course;
+	}
+
+	public Collection<Enroll> getStudents() {
+		return students;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/Student.class b/studentClient/derby/JPAStudentInfo/Student.class
new file mode 100755
index 0000000..0a4752c
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/Student.class differ
diff --git a/studentClient/derby/JPAStudentInfo/Student.java b/studentClient/derby/JPAStudentInfo/Student.java
new file mode 100755
index 0000000..e6ef182
--- /dev/null
+++ b/studentClient/derby/JPAStudentInfo/Student.java
@@ -0,0 +1,54 @@
+import javax.persistence.*;
+import java.util.*;
+
+@Entity
+public class Student {
+
+    @Id private int sid;
+    private String sname;
+    private int gradyear;
+
+    @OneToMany(mappedBy="student")
+    private Collection<Enroll> enrollments;
+
+    @ManyToOne
+    @JoinColumn(name="MajorId")
+    private Dept major;
+
+	public Student() {}
+
+	public Student(int sid, String sname, int gradyear, Dept major) {
+		this.sid = sid;
+		this.sname = sname;
+		this.gradyear = gradyear;
+		this.major = major;
+	}
+
+    public int getId() {
+        return sid;
+    }
+
+    public String getName() {
+        return sname;
+    }
+
+	public int getGradYear() {
+        return gradyear;
+    }
+
+    public void changeGradYear(int year) {
+        gradyear = year;
+    }
+
+    public Dept getMajor() {
+		return major;
+	}
+
+	public void changeMajor(Dept dept) {
+		major = dept;
+	}
+
+	public Collection<Enroll> getEnrollments() {
+		return enrollments;
+	}
+}
diff --git a/studentClient/derby/JPAStudentInfo/TSFrame.class b/studentClient/derby/JPAStudentInfo/TSFrame.class
new file mode 100755
index 0000000..2dbd68b
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/TSFrame.class differ
diff --git a/studentClient/derby/JPAStudentInfo/TSPanel$1.class b/studentClient/derby/JPAStudentInfo/TSPanel$1.class
new file mode 100755
index 0000000..b7c1c8f
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/TSPanel$1.class differ
diff --git a/studentClient/derby/JPAStudentInfo/TSPanel$2.class b/studentClient/derby/JPAStudentInfo/TSPanel$2.class
new file mode 100755
index 0000000..4fe0330
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/TSPanel$2.class differ
diff --git a/studentClient/derby/JPAStudentInfo/TSPanel$3.class b/studentClient/derby/JPAStudentInfo/TSPanel$3.class
new file mode 100755
index 0000000..6f92eb7
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/TSPanel$3.class differ
diff --git a/studentClient/derby/JPAStudentInfo/TSPanel.class b/studentClient/derby/JPAStudentInfo/TSPanel.class
new file mode 100755
index 0000000..28a932e
Binary files /dev/null and b/studentClient/derby/JPAStudentInfo/TSPanel.class differ
diff --git a/studentClient/derby/SQLInterpreter.class b/studentClient/derby/SQLInterpreter.class
new file mode 100755
index 0000000..dc9571b
Binary files /dev/null and b/studentClient/derby/SQLInterpreter.class differ
diff --git a/studentClient/derby/SQLInterpreter.java b/studentClient/derby/SQLInterpreter.java
new file mode 100755
index 0000000..adcf2f6
--- /dev/null
+++ b/studentClient/derby/SQLInterpreter.java
@@ -0,0 +1,96 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+import java.io.*;
+
+public class SQLInterpreter {
+    private static Connection conn = null;
+
+    public static void main(String[] args) {
+	   try {
+ 		    Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			Reader rdr = new InputStreamReader(System.in);
+			BufferedReader br = new BufferedReader(rdr);
+
+			while (true) {
+				// process one line of input
+				System.out.print("\nSQL> ");
+				String cmd = br.readLine().trim();
+				System.out.println();
+				if (cmd.startsWith("exit"))
+					break;
+				else if (cmd.startsWith("select"))
+					doQuery(cmd);
+				else
+					doUpdate(cmd);
+		    }
+	    }
+	    catch (Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	private static void doQuery(String cmd) {
+		try {
+		    Statement stmt = conn.createStatement();
+		    ResultSet rs = stmt.executeQuery(cmd);
+		    ResultSetMetaData md = rs.getMetaData();
+		    int numcols = md.getColumnCount();
+		    int totalwidth = 0;
+
+		    // print header
+		    for(int i=1; i<=numcols; i++) {
+				int width = md.getColumnDisplaySize(i);
+				totalwidth += width;
+				String fmt = "%" + width + "s";
+				System.out.format(fmt, md.getColumnName(i));
+			}
+			System.out.println();
+			for(int i=0; i<totalwidth; i++)
+			    System.out.print("-");
+		    System.out.println();
+
+		    // print records
+		    while(rs.next()) {
+				for (int i=1; i<=numcols; i++) {
+					String fldname = md.getColumnName(i);
+					int fldtype = md.getColumnType(i);
+					String fmt = "%" + md.getColumnDisplaySize(i);
+					if (fldtype == Types.INTEGER)
+						System.out.format(fmt + "d", rs.getInt(fldname));
+					else
+						System.out.format(fmt + "s", rs.getString(fldname));
+				}
+				System.out.println();
+			}
+			rs.close();
+		}
+		catch (SQLException e) {
+			System.out.println("SQL Exception: " + e.getMessage());
+			e.printStackTrace();
+		}
+	}
+
+	private static void doUpdate(String cmd) {
+		try {
+		    Statement stmt = conn.createStatement();
+		    int howmany = stmt.executeUpdate(cmd);
+		    System.out.println(howmany + " records processed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL Exception: " + e.getMessage());
+			e.printStackTrace();
+		}
+	}
+}
\ No newline at end of file
diff --git a/studentClient/derby/Servlet/ServletFindMajors.class b/studentClient/derby/Servlet/ServletFindMajors.class
new file mode 100755
index 0000000..f335c36
Binary files /dev/null and b/studentClient/derby/Servlet/ServletFindMajors.class differ
diff --git a/studentClient/derby/Servlet/ServletFindMajors.java b/studentClient/derby/Servlet/ServletFindMajors.java
new file mode 100755
index 0000000..8722844
--- /dev/null
+++ b/studentClient/derby/Servlet/ServletFindMajors.java
@@ -0,0 +1,69 @@
+import java.sql.*;
+import java.io.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class ServletFindMajors extends HttpServlet {
+    public void doGet(HttpServletRequest request,
+                      HttpServletResponse response)
+        throws IOException, ServletException
+    {
+		String major = request.getParameter("major");
+
+        response.setContentType("text/html");
+        PrintWriter out = response.getWriter();
+        out.println("<html>");
+        out.println("<head>");
+	    out.println("<title> Student Majors </title>");
+        out.println("</head>");
+        out.println("<body>");
+        out.println("<P>Here are the " + major + " majors:");
+
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			String qry = "select SName, GradYear "
+			           + "from STUDENT, DEPT "
+			           + "where DId = MajorId and DName = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setString(1, major);
+			ResultSet rs = pstmt.executeQuery();
+
+			// Step 3: loop through the result set
+			out.println("<P><table border=1 cellpadding=2>");
+			out.println("<tr><th>Name</th><th>GradYear</th></tr>");
+			while (rs.next()) {
+				String name = rs.getString("SName");
+				int    year = rs.getInt("GradYear");
+				out.println("<tr><td>" + name + "</td><td>" + year + "</td></tr>");
+			}
+			out.println("</table>");
+			rs.close();
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+			out.println("SQL Exception. Execution aborted");
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+				out.println("Could not close database");
+			}
+       	 	out.println("</body>");
+      	 	out.println("</html>");
+		}
+    }
+}
+
+
+
diff --git a/studentClient/derby/Servlet/ServletFindMajorsInputForm.class b/studentClient/derby/Servlet/ServletFindMajorsInputForm.class
new file mode 100755
index 0000000..c09fd0a
Binary files /dev/null and b/studentClient/derby/Servlet/ServletFindMajorsInputForm.class differ
diff --git a/studentClient/derby/Servlet/ServletFindMajorsInputForm.java b/studentClient/derby/Servlet/ServletFindMajorsInputForm.java
new file mode 100755
index 0000000..80aca1f
--- /dev/null
+++ b/studentClient/derby/Servlet/ServletFindMajorsInputForm.java
@@ -0,0 +1,68 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+import java.io.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.*;
+
+
+public class ServletFindMajorsInputForm extends HttpServlet {
+    public void doGet(HttpServletRequest request,
+                      HttpServletResponse response)
+        throws IOException, ServletException
+    {
+        response.setContentType("text/html");
+        PrintWriter out = response.getWriter();
+        out.println("<html>");
+        out.println("<head>");
+	    out.println("<title> Find Majors </title>");
+        out.println("</head>");
+        out.println("<body>");
+		out.println("<form method=\"get\" "
+				        + "action=\"/studentdb/ServletFindMajors\">");
+		out.println("Enter major:");
+		out.println("<select name=\"major\">");
+
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select dname from dept";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			// Step 3: loop through the result set
+			while (rs.next()) {
+				String dname = rs.getString("DName");
+				out.println("<option value=\"" + dname + "\">"
+				            + dname + "</option>");
+			}
+			rs.close();
+			out.println("</select>");
+			out.println("<p><input type=\"submit\" value=\"Find Majors\">");
+			out.println("</form>");
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+			out.println("SQL Exception. Execution aborted");
+		}
+		finally {
+	        out.println("</body>");
+	        out.println("</html>");
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+				out.println("Could not close database");
+			}
+		}
+    }
+}
+
+
+
diff --git a/studentClient/derby/Servlet/findmajorsinputform.html b/studentClient/derby/Servlet/findmajorsinputform.html
new file mode 100755
index 0000000..aee164a
--- /dev/null
+++ b/studentClient/derby/Servlet/findmajorsinputform.html
@@ -0,0 +1,18 @@
+<html>
+<head>
+<title> Find Majors </title>
+</head>
+<body>
+<form method="get" action="/studentdb/findwhere">
+Enter major:
+<select name="major">
+	<option value="math">Mathematics</option>
+	<option value="compsci">Computer Science</option>
+	<option value="drama">Drama</option>
+</select>
+<p>
+<input type="submit" value="Find Majors">
+</form>
+</body>
+</html>
+
diff --git a/studentClient/derby/Servlet/web.xml b/studentClient/derby/Servlet/web.xml
new file mode 100755
index 0000000..d041961
--- /dev/null
+++ b/studentClient/derby/Servlet/web.xml
@@ -0,0 +1,22 @@
+<web-app>
+
+
+    <servlet>
+      <servlet-name>FindMajors</servlet-name>
+      <servlet-class>ServletFindMajors</servlet-class>
+    </servlet>
+    <servlet-mapping>
+        <servlet-name>FindMajors</servlet-name>
+        <url-pattern>/ServletFindMajors</url-pattern>
+    </servlet-mapping>
+
+    <servlet>
+      <servlet-name>FindMajorsInputForm</servlet-name>
+      <servlet-class>ServletFindMajorsInputForm</servlet-class>
+    </servlet>
+    <servlet-mapping>
+        <servlet-name>FindMajorsInputForm</servlet-name>
+        <url-pattern>/findmajors</url-pattern>
+    </servlet-mapping>
+
+</web-app>
diff --git a/studentClient/derby/StudentInfo/Course.class b/studentClient/derby/StudentInfo/Course.class
new file mode 100755
index 0000000..8d4baaa
Binary files /dev/null and b/studentClient/derby/StudentInfo/Course.class differ
diff --git a/studentClient/derby/StudentInfo/Course.java b/studentClient/derby/StudentInfo/Course.java
new file mode 100755
index 0000000..c2533aa
--- /dev/null
+++ b/studentClient/derby/StudentInfo/Course.java
@@ -0,0 +1,40 @@
+import java.sql.*;
+import java.util.Collection;
+
+public class Course {
+	private CourseDAO dao;
+	private int cid;
+	private String title;
+	private Dept dept;
+	private Collection<Section> sections = null;
+
+	public Course(CourseDAO dao, int cid, String title, Dept dept) {
+		this.dao   = dao;
+		this.cid   = cid;
+		this.title = title;
+		this.dept  = dept;
+	}
+
+	public int getId() {
+		return cid;
+	}
+
+	public String getTitle() {
+		return title;
+	}
+
+	public Dept getDept() {
+		return dept;
+	}
+
+	public Collection<Section> getSections() {
+		if (sections == null)
+			sections = dao.getSections(cid);
+		return sections;
+	}
+
+	public void changeTitle(String newtitle) {
+		title = newtitle;
+		dao.changeTitle(cid, newtitle);
+	}
+}
diff --git a/studentClient/derby/StudentInfo/CourseDAO.class b/studentClient/derby/StudentInfo/CourseDAO.class
new file mode 100755
index 0000000..ad09200
Binary files /dev/null and b/studentClient/derby/StudentInfo/CourseDAO.class differ
diff --git a/studentClient/derby/StudentInfo/CourseDAO.java b/studentClient/derby/StudentInfo/CourseDAO.java
new file mode 100755
index 0000000..beb0797
--- /dev/null
+++ b/studentClient/derby/StudentInfo/CourseDAO.java
@@ -0,0 +1,91 @@
+import java.sql.*;
+import java.util.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class CourseDAO {
+	private Connection conn;
+	private DatabaseManager dbm;
+
+	public CourseDAO(Connection conn, DatabaseManager dbm) {
+		this.conn = conn;
+		this.dbm  = dbm;
+	}
+
+	public Course find(int cid) {
+		try {
+			String qry = "select Title, DeptId from COURSE where CId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, cid);
+			ResultSet rs = pstmt.executeQuery();
+
+			// return null if course doesn't exist
+			if (!rs.next())
+				return null;
+
+			String title = rs.getString("Title");
+			int deptid   = rs.getInt("DeptId");
+			rs.close();
+			Dept dept = dbm.findDept(deptid);
+			return new Course(this, cid, title, dept);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error finding course", e);
+		}
+	}
+
+	public Course insert(int cid, String title, Dept dept) {
+		try {
+			// make sure that the cid is currently unused
+			if (find(cid) != null)
+				return null;
+
+			String cmd = "insert into COURSE(CId, Title, DeptId) "
+			           + "values(?, ?, ?, ?)";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, cid);
+			pstmt.setString(2, title);
+			pstmt.setInt(3, dept.getId());
+			pstmt.executeUpdate();
+			return new Course(this, cid, title, dept);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error inserting new course", e);
+		}
+	}
+
+	public Collection<Section> getSections(int cid) {
+		try {
+			Collection<Section> sections = new ArrayList<Section>();
+			String qry = "select SectId from SECTION where CourseId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, cid);
+			ResultSet rs = pstmt.executeQuery();
+			while (rs.next()) {
+				int sectid = rs.getInt("SectId");
+				sections.add(dbm.findSection(sectid));
+			}
+			rs.close();
+			return sections;
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error getting course sections", e);
+		}
+	}
+
+	public void changeTitle(int cid, String newtitle) {
+		try {
+			String cmd = "update COURSE set Title = ? where CId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setString(1, newtitle);
+			pstmt.setInt(1, cid);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing title", e);
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/DatabaseManager.class b/studentClient/derby/StudentInfo/DatabaseManager.class
new file mode 100755
index 0000000..596137d
Binary files /dev/null and b/studentClient/derby/StudentInfo/DatabaseManager.class differ
diff --git a/studentClient/derby/StudentInfo/DatabaseManager.java b/studentClient/derby/StudentInfo/DatabaseManager.java
new file mode 100755
index 0000000..af46c5d
--- /dev/null
+++ b/studentClient/derby/StudentInfo/DatabaseManager.java
@@ -0,0 +1,97 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class DatabaseManager {
+	private Connection conn;
+	private StudentDAO studentDAO;
+	private DeptDAO    deptDAO;
+	private EnrollDAO  enrollDAO;
+	private SectionDAO sectionDAO;
+	private CourseDAO  courseDAO;
+
+	public DatabaseManager() {
+    	try {
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+			conn.setAutoCommit(false);
+
+			studentDAO = new StudentDAO(conn, this);
+			deptDAO    = new DeptDAO(conn, this);
+			enrollDAO  = new EnrollDAO(conn, this);
+			sectionDAO = new SectionDAO(conn, this);
+			courseDAO  = new CourseDAO(conn, this);
+		}
+		catch(SQLException e) {
+			throw new RuntimeException("cannot connect to database", e);
+		}
+	}
+
+	public void commit() {
+		try {
+			conn.commit();
+		}
+		catch(SQLException e) {
+			throw new RuntimeException("cannot commit database", e);
+		}
+	}
+
+	public void close() {
+		try {
+			conn.close();
+		}
+		catch(SQLException e) {
+			throw new RuntimeException("cannot close database", e);
+		}
+	}
+
+	public Student findStudent(int sid) {
+		return studentDAO.find(sid);
+	}
+
+	public Dept findDept(int did) {
+		return deptDAO.find(did);
+	}
+
+	public Enroll findEnroll(int eid) {
+		return enrollDAO.find(eid);
+	}
+
+	public Course findCourse(int cid) {
+		return courseDAO.find(cid);
+	}
+
+	public Section findSection(int sectid) {
+		return sectionDAO.find(sectid);
+	}
+
+	public Student insertStudent(int sid, String sname, int gradyear, Dept major) {
+		return studentDAO.insert(sid, sname, gradyear, major);
+	}
+
+	public Dept insertDept(int did, String dname) {
+		return deptDAO.insert(did, dname);
+	}
+
+	public Enroll insertEnroll(int eid, Student student, Section section) {
+		return enrollDAO.insert(eid, student, section);
+	}
+
+	public Section insertSection(int sectid, String prof, int year, Course course) {
+		return sectionDAO.insert(sectid, prof, year, course);
+	}
+
+	public Course insertCourse(int cid, String title, Dept dept) {
+		return courseDAO.insert(cid, title, dept);
+	}
+
+	public void cleanup() {
+		try {
+			conn.rollback();
+			conn.close();
+		}
+		catch(SQLException e) {
+			System.out.println("fatal error: cannot cleanup connection");
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/Dept.class b/studentClient/derby/StudentInfo/Dept.class
new file mode 100755
index 0000000..1090533
Binary files /dev/null and b/studentClient/derby/StudentInfo/Dept.class differ
diff --git a/studentClient/derby/StudentInfo/Dept.java b/studentClient/derby/StudentInfo/Dept.java
new file mode 100755
index 0000000..dfc519b
--- /dev/null
+++ b/studentClient/derby/StudentInfo/Dept.java
@@ -0,0 +1,41 @@
+import java.sql.*;
+import java.util.Collection;
+
+public class Dept {
+	private DeptDAO dao;
+	private int did;
+	private String dname;
+	private Collection<Student> majors = null;
+	private Collection<Course> courses = null;
+
+	public Dept(DeptDAO dao, int did, String dname) {
+		this.dao   = dao;
+		this.did   = did;
+		this.dname = dname;
+	}
+
+	public int getId() {
+		return did;
+	}
+
+	public String getName() {
+		return dname;
+	}
+
+	public void changeName(String newname) {
+			dname = newname;
+			dao.changeName(did, newname);
+	}
+
+	public Collection<Student> getMajors() {
+		if (majors == null)
+			majors = dao.getMajors(did);
+		return majors;
+	}
+
+	public Collection<Course> getCourses() {
+		if (courses == null)
+			courses = dao.getCourses(did);
+		return courses;
+	}
+}
diff --git a/studentClient/derby/StudentInfo/DeptDAO.class b/studentClient/derby/StudentInfo/DeptDAO.class
new file mode 100755
index 0000000..f842c70
Binary files /dev/null and b/studentClient/derby/StudentInfo/DeptDAO.class differ
diff --git a/studentClient/derby/StudentInfo/DeptDAO.java b/studentClient/derby/StudentInfo/DeptDAO.java
new file mode 100755
index 0000000..2ff2488
--- /dev/null
+++ b/studentClient/derby/StudentInfo/DeptDAO.java
@@ -0,0 +1,107 @@
+import java.sql.*;
+import java.util.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class DeptDAO {
+	private Connection conn;
+	private DatabaseManager dbm;
+
+	public DeptDAO(Connection conn, DatabaseManager dbm) {
+		this.conn = conn;
+		this.dbm  = dbm;
+	}
+
+	public Dept find(int did) {
+		try {
+			String qry = "select DName from DEPT where DId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, did);
+			ResultSet rs = pstmt.executeQuery();
+
+			// return null if department doesn't exist
+			if (!rs.next())
+				return null;
+
+			String dname = rs.getString("DName");
+			rs.close();
+			return new Dept(this, did, dname);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error finding department", e);
+		}
+	}
+
+	public Dept insert(int did, String dname) {
+		try {
+			// make sure that the did is currently unused
+			if (find(did) != null)
+				return null;
+
+			String cmd = "insert into DEPT(DId, DName) values(?, ?)";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, did);
+			pstmt.setString(2, dname);
+			pstmt.executeUpdate();
+			return new Dept(this, did, dname);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error inserting new department", e);
+		}
+	}
+
+	public Collection<Student> getMajors(int did) {
+		try {
+			Collection<Student> majors = new ArrayList<Student>();
+			String qry = "select SId from STUDENT where MajorId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, did);
+			ResultSet rs = pstmt.executeQuery();
+			while (rs.next()) {
+				int sid = rs.getInt("SId");
+				majors.add(dbm.findStudent(sid));
+			}
+			rs.close();
+			return majors;
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error getting student majors", e);
+		}
+	}
+
+	public Collection<Course> getCourses(int did) {
+		try {
+			Collection<Course> courses = new ArrayList<Course>();
+			String qry = "select CId from COURSE where CourseId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, did);
+			ResultSet rs = pstmt.executeQuery();
+			while (rs.next()) {
+				int cid = rs.getInt("CId");
+				courses.add(dbm.findCourse(cid));
+			}
+			rs.close();
+			return courses;
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error getting offered courses", e);
+		}
+	}
+
+	public void changeName(int did, String newname) {
+		try {
+			String cmd = "update DEPT set SName = ? where DId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setString(1, newname);
+			pstmt.setInt(1, did);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing department name", e);
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/Enroll.class b/studentClient/derby/StudentInfo/Enroll.class
new file mode 100755
index 0000000..11109a9
Binary files /dev/null and b/studentClient/derby/StudentInfo/Enroll.class differ
diff --git a/studentClient/derby/StudentInfo/Enroll.java b/studentClient/derby/StudentInfo/Enroll.java
new file mode 100755
index 0000000..663a982
--- /dev/null
+++ b/studentClient/derby/StudentInfo/Enroll.java
@@ -0,0 +1,39 @@
+import java.sql.*;
+import java.util.*;
+
+public class Enroll {
+	private EnrollDAO dao;
+	private int eid;
+	private String grade;
+	private Student student;
+	private Section section;
+
+	public Enroll(EnrollDAO dao, int eid, String grade, Student student, Section section) {
+		this.dao     = dao;
+		this.eid     = eid;
+		this.grade   = grade;
+		this.student = student;
+		this.section = section;
+	}
+
+	public int getId() {
+		return eid;
+	}
+
+	public Student getStudent() {
+		return student;
+	}
+
+	public Section getSection() {
+		return section;
+	}
+
+	public String getGrade() {
+		return grade;
+	}
+
+	public void changeGrade(String newgrade) {
+		grade = newgrade;
+		dao.changeGrade(eid, newgrade);
+	}
+}
diff --git a/studentClient/derby/StudentInfo/EnrollDAO.class b/studentClient/derby/StudentInfo/EnrollDAO.class
new file mode 100755
index 0000000..2c5091f
Binary files /dev/null and b/studentClient/derby/StudentInfo/EnrollDAO.class differ
diff --git a/studentClient/derby/StudentInfo/EnrollDAO.java b/studentClient/derby/StudentInfo/EnrollDAO.java
new file mode 100755
index 0000000..87c26c2
--- /dev/null
+++ b/studentClient/derby/StudentInfo/EnrollDAO.java
@@ -0,0 +1,76 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class EnrollDAO {
+	private Connection conn;
+	private DatabaseManager dbm;
+
+	public EnrollDAO(Connection conn, DatabaseManager dbm) {
+		this.conn = conn;
+		this.dbm  = dbm;
+	}
+
+	public Enroll find(int eid) {
+		try {
+			String qry = "select Grade, StudentId, SectionId from ENROLL where EId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, eid);
+			ResultSet rs = pstmt.executeQuery();
+
+			// return null if enrollment doesn't exist
+			if (!rs.next())
+				return null;
+
+			String grade = rs.getString("Grade");
+			int sid      = rs.getInt("StudentId");
+			int sectid   = rs.getInt("SectionId");
+			rs.close();
+			Student student = dbm.findStudent(sid);
+			Section section = dbm.findSection(sectid);
+			return new Enroll(this, eid, grade, student, section);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error finding enrollment", e);
+		}
+	}
+
+	public Enroll insert(int eid, Student student, Section section) {
+		try {
+			// make sure that the eid is currently unused
+			if (find(eid) != null)
+				return null;
+
+			// the grade for a new enrollment is ""
+			String grade = "";
+
+			String cmd = "insert into ENROLL(EId, Grade, StudentId, SectionId) "
+			           + "values(?, ?, ?, ?)";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, eid);
+			pstmt.setString(2, grade);
+			pstmt.setInt(3, student.getId());
+			pstmt.setInt(4, section.getId());
+			pstmt.executeUpdate();
+			return new Enroll(this, eid, grade, student, section);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error inserting new enrollment", e);
+		}
+	}
+
+	public void changeGrade(int eid, String newgrade) {
+		try {
+			String cmd = "update ENROLL set Grade = ? where EId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setString(1, newgrade);
+			pstmt.setInt(1, eid);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing grade", e);
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/Section.class b/studentClient/derby/StudentInfo/Section.class
new file mode 100755
index 0000000..9b9be62
Binary files /dev/null and b/studentClient/derby/StudentInfo/Section.class differ
diff --git a/studentClient/derby/StudentInfo/Section.java b/studentClient/derby/StudentInfo/Section.java
new file mode 100755
index 0000000..87771b5
--- /dev/null
+++ b/studentClient/derby/StudentInfo/Section.java
@@ -0,0 +1,45 @@
+import java.sql.*;
+import java.util.Collection;
+
+public class Section {
+	private SectionDAO dao;
+	private int sectid, year;
+	private String prof;
+	private Course course;
+	private Collection<Enroll> enrollments = null;
+
+	public Section(SectionDAO dao, int sectid, String prof, int year, Course course) {
+		this.dao     = dao;
+		this.sectid  = sectid;
+		this.prof    = prof;
+		this.year    = year;
+		this.course  = course;
+	}
+
+	public int getId() {
+		return sectid;
+	}
+
+	public String getProf() {
+		return prof;
+	}
+
+	public int getYearOffered() {
+		return year;
+	}
+
+	public Course getCourse() {
+		return course;
+	}
+
+	public Collection<Enroll> getEnrollments() {
+		if (enrollments == null)
+			enrollments = dao.getEnrollments(sectid);
+		return enrollments;
+	}
+
+	public void changeProf(String newprof) {
+		prof = newprof;
+		dao.changeProf(sectid, newprof);
+	}
+}
diff --git a/studentClient/derby/StudentInfo/SectionDAO.class b/studentClient/derby/StudentInfo/SectionDAO.class
new file mode 100755
index 0000000..47de053
Binary files /dev/null and b/studentClient/derby/StudentInfo/SectionDAO.class differ
diff --git a/studentClient/derby/StudentInfo/SectionDAO.java b/studentClient/derby/StudentInfo/SectionDAO.java
new file mode 100755
index 0000000..b4e427b
--- /dev/null
+++ b/studentClient/derby/StudentInfo/SectionDAO.java
@@ -0,0 +1,94 @@
+import java.sql.*;
+import java.util.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class SectionDAO {
+	private Connection conn;
+	private DatabaseManager dbm;
+
+	public SectionDAO(Connection conn, DatabaseManager dbm) {
+		this.conn = conn;
+		this.dbm  = dbm;
+	}
+
+	public Section find(int sectid) {
+		try {
+			String qry = "select Prof, YearOffered, CourseId "
+					   + "from SECTION where SectId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, sectid);
+			ResultSet rs = pstmt.executeQuery();
+
+			// return null if section doesn't exist
+			if (!rs.next())
+				return null;
+
+			String prof = rs.getString("Prof");
+			int year = rs.getInt("YearOffered");
+			int courseid  = rs.getInt("CourseId");
+			rs.close();
+			Course course = dbm.findCourse(courseid);
+			return new Section(this, sectid, prof, year, course);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error finding section", e);
+		}
+	}
+
+	public Section insert(int sectid, String prof, int year, Course course) {
+		try {
+			// make sure that the sectid is currently unused
+			if (find(sectid) != null)
+				return null;
+
+			String cmd = "insert into SECTION(SectId, Prof, YearOffered, CourseId) "
+			           + "values(?, ?, ?, ?)";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, sectid);
+			pstmt.setString(2, prof);
+			pstmt.setInt(3, year);
+			pstmt.setInt(4, course.getId());
+			pstmt.executeUpdate();
+			return new Section(this, sectid, prof, year, course);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error inserting new section", e);
+		}
+	}
+
+	public Collection<Enroll> getEnrollments(int sectid) {
+		try {
+			Collection<Enroll> enrollments = new ArrayList<Enroll>();
+			String qry = "select EId from ENROLL where SectionId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, sectid);
+			ResultSet rs = pstmt.executeQuery();
+			while (rs.next()) {
+				int eid = rs.getInt("EId");
+				enrollments.add(dbm.findEnroll(eid));
+			}
+			rs.close();
+			return enrollments;
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error getting section enrollments", e);
+		}
+	}
+
+	public void changeProf(int sectid, String newprof) {
+		try {
+			String cmd = "update SECTION set Prof = ? where SectId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setString(1, newprof);
+			pstmt.setInt(1, sectid);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing prof", e);
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/Student.class b/studentClient/derby/StudentInfo/Student.class
new file mode 100755
index 0000000..6c23a38
Binary files /dev/null and b/studentClient/derby/StudentInfo/Student.class differ
diff --git a/studentClient/derby/StudentInfo/Student.java b/studentClient/derby/StudentInfo/Student.java
new file mode 100755
index 0000000..455d9f3
--- /dev/null
+++ b/studentClient/derby/StudentInfo/Student.java
@@ -0,0 +1,50 @@
+import java.sql.*;
+import java.util.Collection;
+
+public class Student {
+	private StudentDAO dao;
+	private int sid, gradyear;
+	private String sname;
+	private Dept major;
+	private Collection<Enroll> enrollments = null;
+
+	public Student(StudentDAO dao, int sid, String sname, int gradyear, Dept major) {
+		this.dao      = dao;
+		this.sid      = sid;
+		this.sname    = sname;
+		this.gradyear = gradyear;
+		this.major    = major;
+	}
+
+	public int getId() {
+		return sid;
+	}
+
+	public String getName() {
+		return sname;
+	}
+
+	public int getGradYear() {
+		return gradyear;
+	}
+
+	public Dept getMajor() {
+		return major;
+	}
+
+	public Collection<Enroll> getEnrollments() {
+		if (enrollments == null)
+			enrollments = dao.getEnrollments(sid);
+		return enrollments;
+	}
+
+	public void changeGradYear(int newyear) {
+		gradyear = newyear;
+		dao.changeGradYear(sid, newyear);
+	}
+
+	public void changeMajor(Dept newmajor) {
+		major = newmajor;
+		dao.changeMajor(sid, newmajor);
+	}
+}
diff --git a/studentClient/derby/StudentInfo/StudentDAO.class b/studentClient/derby/StudentInfo/StudentDAO.class
new file mode 100755
index 0000000..a4f317b
Binary files /dev/null and b/studentClient/derby/StudentInfo/StudentDAO.class differ
diff --git a/studentClient/derby/StudentInfo/StudentDAO.java b/studentClient/derby/StudentInfo/StudentDAO.java
new file mode 100755
index 0000000..e0522f5
--- /dev/null
+++ b/studentClient/derby/StudentInfo/StudentDAO.java
@@ -0,0 +1,108 @@
+import java.sql.*;
+import java.util.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class StudentDAO {
+	private Connection conn;
+	private DatabaseManager dbm;
+
+	public StudentDAO(Connection conn, DatabaseManager dbm) {
+		this.conn = conn;
+		this.dbm  = dbm;
+	}
+
+	public Student find(int sid) {
+		try {
+			String qry = "select SName, GradYear, MajorId from STUDENT where SId = ? ";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, sid);
+			ResultSet rs = pstmt.executeQuery();
+
+			// return null if student doesn't exist
+			if (!rs.next())
+				return null;
+
+			String sname = rs.getString("SName");
+			int gradyear = rs.getInt("GradYear");
+			int majorid  = rs.getInt("MajorId");
+			rs.close();
+
+			Dept major = dbm.findDept(majorid);
+			return new Student(this, sid, sname, gradyear, major);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error finding student", e);
+		}
+	}
+
+	public Student insert(int sid, String sname, int gradyear, Dept major) {
+		try {
+			// make sure that the sid is currently unused
+			if (find(sid) != null)
+				return null;
+
+			String cmd = "insert into STUDENT(SId, SName, GradYear, MajorId) "
+			           + "values(?, ?, ?, ?)";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, sid);
+			pstmt.setString(2, sname);
+			pstmt.setInt(3, gradyear);
+			pstmt.setInt(4, major.getId());
+			pstmt.executeUpdate();
+			return new Student(this, sid, sname, gradyear, major);
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error inserting new student", e);
+		}
+	}
+
+	public Collection<Enroll> getEnrollments(int sid) {
+		try {
+			Collection<Enroll> enrollments = new ArrayList<Enroll>();
+			String qry = "select EId from ENROLL where StudentId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(qry);
+			pstmt.setInt(1, sid);
+			ResultSet rs = pstmt.executeQuery();
+			while (rs.next()) {
+				int eid = rs.getInt("EId");
+				enrollments.add(dbm.findEnroll(eid));
+			}
+			rs.close();
+			return enrollments;
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error getting student enrollments", e);
+		}
+	}
+
+	public void changeGradYear(int sid, int newyear) {
+		try {
+			String cmd = "update STUDENT set GradYear = ? where SId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, newyear);
+			pstmt.setInt(2, sid);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing grad year", e);
+		}
+	}
+
+	public void changeMajor(int sid, Dept newmajor) {
+		try {
+			String cmd = "update STUDENT set MajorId = ? where SId = ?";
+			PreparedStatement pstmt = conn.prepareStatement(cmd);
+			pstmt.setInt(1, newmajor.getId());
+			pstmt.setInt(2, sid);
+			pstmt.executeUpdate();
+		}
+		catch(SQLException e) {
+			dbm.cleanup();
+			throw new RuntimeException("error changing major", e);
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/StudentInfo.class b/studentClient/derby/StudentInfo/StudentInfo.class
new file mode 100755
index 0000000..7003161
Binary files /dev/null and b/studentClient/derby/StudentInfo/StudentInfo.class differ
diff --git a/studentClient/derby/StudentInfo/StudentInfo.java b/studentClient/derby/StudentInfo/StudentInfo.java
new file mode 100755
index 0000000..c67bf41
--- /dev/null
+++ b/studentClient/derby/StudentInfo/StudentInfo.java
@@ -0,0 +1,90 @@
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+import javax.swing.table.*;
+
+public class StudentInfo {
+	public static void main(String[] args) {
+   		DatabaseManager dbmgr = new DatabaseManager();
+   		JFrame frame = new TSFrame(dbmgr);
+    	frame.setVisible(true);
+    }
+}
+
+class TSFrame extends JFrame {
+	public TSFrame(DatabaseManager dbmgr) {
+		setTitle("Student Info");
+		setDefaultCloseOperation(EXIT_ON_CLOSE);
+        setSize(550,150);
+        setLocation(200,200);
+        getContentPane().add(new TSPanel(dbmgr));
+    }
+}
+
+class TSPanel extends JPanel {
+	private JLabel inputLbl  = new JLabel("Enter Student ID: ");
+	private JTextField txt   = new JTextField(4);
+	private JButton btn1     = new JButton("SHOW INFO");
+	private JButton btn2     = new JButton("CHANGE GRADYEAR");
+	private JButton btn3     = new JButton("CLOSE");
+	private JLabel outputLbl = new JLabel("");
+	private DefaultTableModel courses;
+
+
+	public TSPanel(final DatabaseManager dbmgr) {
+		Object[] columnNames = {"Title", "Year", "Grade"};
+		courses = new DefaultTableModel(columnNames, 0);
+		JTable tbl = new JTable(courses);
+		JScrollPane sp = new JScrollPane(tbl);
+		add(inputLbl); add(txt); add(btn1); add(btn2); add(btn3);
+		add(outputLbl); add(sp);
+
+		btn1.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent evt) {
+					int sid = Integer.parseInt(txt.getText());
+					Student s = dbmgr.findStudent(sid);
+					display(s);
+					dbmgr.commit();
+				}
+			});
+
+		btn2.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent evt) {
+					String yearstring = JOptionPane.showInputDialog("Enter new grad year");
+					int sid  = Integer.parseInt(txt.getText());
+					int newyear = Integer.parseInt(yearstring);
+					Student s = dbmgr.findStudent(sid);
+					s.changeGradYear(newyear);
+					display(s);
+					dbmgr.commit();
+				}
+			});
+
+		btn3.addActionListener(
+			new ActionListener() {
+				public void actionPerformed(ActionEvent evt) {
+					dbmgr.close();
+					setVisible(false);
+					System.exit(0);
+				}
+			});
+	}
+
+	private void display(Student s) {
+		courses.setRowCount(0);
+		if (s == null)
+			outputLbl.setText("            No such student!");
+		else {
+			outputLbl.setText("Name: " + s.getName()
+			            + "    Graduation Year: " + s.getGradYear());
+			for (Enroll e : s.getEnrollments()) {
+				Section k = e.getSection();
+				Course  c = k.getCourse();
+				Object[] row = {c.getTitle(), k.getYearOffered(), e.getGrade()};
+				courses.addRow(row);
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/StudentInfo/TSFrame.class b/studentClient/derby/StudentInfo/TSFrame.class
new file mode 100755
index 0000000..28321f9
Binary files /dev/null and b/studentClient/derby/StudentInfo/TSFrame.class differ
diff --git a/studentClient/derby/StudentInfo/TSPanel$1.class b/studentClient/derby/StudentInfo/TSPanel$1.class
new file mode 100755
index 0000000..a485584
Binary files /dev/null and b/studentClient/derby/StudentInfo/TSPanel$1.class differ
diff --git a/studentClient/derby/StudentInfo/TSPanel$2.class b/studentClient/derby/StudentInfo/TSPanel$2.class
new file mode 100755
index 0000000..dbefb52
Binary files /dev/null and b/studentClient/derby/StudentInfo/TSPanel$2.class differ
diff --git a/studentClient/derby/StudentInfo/TSPanel$3.class b/studentClient/derby/StudentInfo/TSPanel$3.class
new file mode 100755
index 0000000..03ca3c6
Binary files /dev/null and b/studentClient/derby/StudentInfo/TSPanel$3.class differ
diff --git a/studentClient/derby/StudentInfo/TSPanel.class b/studentClient/derby/StudentInfo/TSPanel.class
new file mode 100755
index 0000000..52eaa26
Binary files /dev/null and b/studentClient/derby/StudentInfo/TSPanel.class differ
diff --git a/studentClient/derby/StudentMajor.class b/studentClient/derby/StudentMajor.class
new file mode 100755
index 0000000..e6c168d
Binary files /dev/null and b/studentClient/derby/StudentMajor.class differ
diff --git a/studentClient/derby/StudentMajor.java b/studentClient/derby/StudentMajor.java
new file mode 100755
index 0000000..0e94e00
--- /dev/null
+++ b/studentClient/derby/StudentMajor.java
@@ -0,0 +1,43 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+
+public class StudentMajor {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb;create=false";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select SName, DName "
+			           + "from DEPT, STUDENT "
+			           + "where MajorId = DId";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			// Step 3: loop through the result set
+			System.out.println("Name\tMajor");
+			while (rs.next()) {
+				String sname = rs.getString("SName");
+				String dname = rs.getString("DName");
+				System.out.println(sname + "\t" + dname);
+			}
+			rs.close();
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/XML/GraduatingStudents.xml b/studentClient/derby/XML/GraduatingStudents.xml
new file mode 100755
index 0000000..a28689d
--- /dev/null
+++ b/studentClient/derby/XML/GraduatingStudents.xml
@@ -0,0 +1,50 @@
+	<GraduatingStudents>
+		<Student> 
+			<SName>ian</SName>
+			<GradYear>2009</GradYear>
+			<Courses>
+				<Course>
+					<Title>calculus</Title>
+					<YearTaken>2006</YearTaken>
+					<Grade>A</Grade>
+				</Course>
+				<Course>
+					<Title>shakespeare</Title>
+					<YearTaken>2006</YearTaken>
+					<Grade>C</Grade>
+				</Course>
+				<Course>
+					<Title>pop culture</Title>
+					<YearTaken>2007</YearTaken>
+					<Grade>B+</Grade>
+				</Course>
+			</Courses>
+		</Student>
+		<Student> 
+			<SName>ben</SName>
+			<GradYear>2009</GradYear>
+			<Courses>
+				<Course>
+					<Title>shakespeare</Title>
+					<YearTaken>2006</YearTaken>
+					<Grade>A-</Grade>
+				</Course>
+				<Course>
+					<Title>databases</Title>
+					<YearTaken>2007</YearTaken>
+					<Grade>A</Grade>
+				</Course>
+			</Courses>
+		</Student>
+		<Student>
+			<SName>tom</SName>
+			<GradYear>2009</GradYear>
+			<Courses>
+				<Course>
+					<Title>calculus</Title>
+					<YearTaken>2006</YearTaken>
+					<Grade>C-</Grade>
+				</Course>
+			</Courses>
+		</Student>
+	</GraduatingStudents>
diff --git a/studentClient/derby/XML/StudentsToXML.class b/studentClient/derby/XML/StudentsToXML.class
new file mode 100755
index 0000000..cfd49ad
Binary files /dev/null and b/studentClient/derby/XML/StudentsToXML.class differ
diff --git a/studentClient/derby/XML/StudentsToXML.java b/studentClient/derby/XML/StudentsToXML.java
new file mode 100755
index 0000000..08fe15d
--- /dev/null
+++ b/studentClient/derby/XML/StudentsToXML.java
@@ -0,0 +1,60 @@
+import java.sql.*;
+import org.apache.derby.jdbc.ClientDriver;
+import java.io.*;
+
+public class StudentsToXML {
+   public static final String OUTFILE = "students2005.xml";
+
+   public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select s.SName, s.GradYear, c.Title, "
+						+       "k.YearOffered, e.Grade "
+						+ "from STUDENT s, ENROLL e, SECTION k, COURSE c "
+						+ "where s.SId=e.StudentId and e.SectionId=k.SectId "
+						+ "and k.CourseId=c.CId and s.GradYear=2005";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			Writer w = new FileWriter(OUTFILE);
+			writeXML(w, rs, "Student");
+			rs.close();
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+		public static void writeXML(Writer w, ResultSet rs, String elementname) throws Exception {
+		w.write("<" + elementname + "s>\n");
+
+		ResultSetMetaData md = rs.getMetaData();
+		int colcount = md.getColumnCount();
+		while(rs.next()) {
+			w.write("\t<" + elementname + ">\n");
+			for (int i=1; i<=colcount; i++) {
+				String col = md.getColumnName(i);
+				String val = rs.getString(i);
+				w.write("\t\t<" + col + ">" + val + "</" + col + ">\n");
+			}
+			w.write("\t</" + elementname + ">\n");
+		}
+		w.write("</" + elementname + "s>\n");
+	}
+}
diff --git a/studentClient/derby/XML/TransformXmlFile.class b/studentClient/derby/XML/TransformXmlFile.class
new file mode 100755
index 0000000..3bb5609
Binary files /dev/null and b/studentClient/derby/XML/TransformXmlFile.class differ
diff --git a/studentClient/derby/XML/TransformXmlFile.java b/studentClient/derby/XML/TransformXmlFile.java
new file mode 100755
index 0000000..b25854d
--- /dev/null
+++ b/studentClient/derby/XML/TransformXmlFile.java
@@ -0,0 +1,29 @@
+import javax.xml.transform.*;
+import javax.xml.transform.stream.*;
+import java.io.*;
+
+public class TransformXmlFile {
+	// Change these file names as appropriate
+	public static String XSLFILE = "XmlToUnnested.xsl";
+	public static String INFILE  = "students.xml";
+	public static String OUTFILE = "xx.txt";
+
+    public static void main(String[] args) {
+		try {
+			System.setProperty("javax.xml.transform.TransformerFactory", "net.sf.saxon.TransformerFactoryImpl");
+
+			// Create Source and Result objects for the files
+			Source xsl    = new StreamSource(new FileReader(XSLFILE));
+			Source input  = new StreamSource(new FileReader(INFILE));
+			Result output = new StreamResult(new FileWriter(OUTFILE));
+
+			// Transform the INFILE to the OUTFILE
+			TransformerFactory tf = TransformerFactory.newInstance();
+			Transformer trans = tf.newTransformer(xsl);
+			trans.transform(input, output);
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/studentClient/derby/XML/WrsStudentsToXML.class b/studentClient/derby/XML/WrsStudentsToXML.class
new file mode 100755
index 0000000..f376cd7
Binary files /dev/null and b/studentClient/derby/XML/WrsStudentsToXML.class differ
diff --git a/studentClient/derby/XML/WrsStudentsToXML.java b/studentClient/derby/XML/WrsStudentsToXML.java
new file mode 100755
index 0000000..02ebe3a
--- /dev/null
+++ b/studentClient/derby/XML/WrsStudentsToXML.java
@@ -0,0 +1,48 @@
+import java.sql.*;
+import javax.sql.rowset.*;
+import org.apache.derby.jdbc.ClientDriver;
+import com.sun.rowset.*;
+import java.io.*;
+
+public class WrsStudentsToXML {
+   public static final String OUTFILE = "students2005.xml";
+
+   public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new ClientDriver();
+			String url = "jdbc:derby://localhost/studentdb";
+			conn = d.connect(url, null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry  = "select s.SName, s.GradYear, c.Title, "
+						+        "k.YearOffered, e.Grade "
+						+ "from STUDENT s, ENROLL e, SECTION k, COURSE c "
+						+ "where s.SId=e.StudentId and e.SectionId=k.SectId "
+						+ "and k.CourseId=c.CId and s.GradYear=2005";
+
+			ResultSet rs = stmt.executeQuery(qry);
+
+			Writer w = new FileWriter(OUTFILE);
+			WebRowSet wrs = new WebRowSetImpl();
+			wrs.populate(rs);
+			wrs.writeXml(w);
+			rs.close();
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/derby/XML/XmlToHtml.xsl b/studentClient/derby/XML/XmlToHtml.xsl
new file mode 100755
index 0000000..5ec8b4b
--- /dev/null
+++ b/studentClient/derby/XML/XmlToHtml.xsl
@@ -0,0 +1,35 @@
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
+
+  <xsl:output method="html"/>
+  
+  <xsl:template match="GraduatingStudents">
+	<html><body>
+	<table border="1" cellpadding="2">
+	<tr> <th>Name</th> <th>Grad Year</th> <th>Courses</th> </tr>
+    <xsl:apply-templates select="Student"/>
+    </table>
+    </body></html>
+  </xsl:template>
+
+  <xsl:template match="Student">
+	<tr> <td> <xsl:value-of select="SName"/> </td>
+	     <td> <xsl:value-of select="GradYear"/> </td>
+	     <td> <xsl:apply-templates select="Courses"/> </td>
+	</tr>
+  </xsl:template>
+    
+  <xsl:template match="Courses">
+	<table border="0" cellpadding="2" width="100%">
+	<tr> <th width="50%">Title</th> <th>Year</th> <th>Grade</th> </tr>
+    <xsl:apply-templates select="Course"/>
+    </table>
+  </xsl:template>
+  
+  <xsl:template match="Course">
+	<tr> <td> <xsl:value-of select="Title"/> </td>
+	     <td> <xsl:value-of select="YearTaken"/>  </td>
+	     <td> <xsl:value-of select="Grade"/> </td>
+	</tr>
+  </xsl:template>
+ 
+</xsl:stylesheet>
diff --git a/studentClient/derby/XML/XmlToNames.xsl b/studentClient/derby/XML/XmlToNames.xsl
new file mode 100755
index 0000000..c8e8e9b
--- /dev/null
+++ b/studentClient/derby/XML/XmlToNames.xsl
@@ -0,0 +1,15 @@
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
+
+  <xsl:output method="xml" indent="yes"/>
+  
+  <xsl:template match="GraduatingStudents">
+	<StudentNames>
+    	<xsl:apply-templates select="Student"/>
+    </StudentNames>
+  </xsl:template>
+
+  <xsl:template match="Student">
+	<Name><xsl:value-of select="SName"/></Name>
+  </xsl:template>
+    
+</xsl:stylesheet>
diff --git a/studentClient/derby/XML/XmlToNested.xsl b/studentClient/derby/XML/XmlToNested.xsl
new file mode 100755
index 0000000..a415b6e
--- /dev/null
+++ b/studentClient/derby/XML/XmlToNested.xsl
@@ -0,0 +1,25 @@
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
+
+  <xsl:output method="xml" indent="yes"/>
+
+  <xsl:template match="Enrollments">
+	<GraduatingStudents>
+    <xsl:for-each-group select="CourseTaken" group-by="@sname">
+      <Student>
+      	<SName><xsl:value-of select="@sname"/></SName>
+      	<GradYear><xsl:value-of select="@gradyear"/></GradYear>
+      	<Courses>
+      		<xsl:for-each select="current-group()">
+			  	<Course>
+			  		<Title><xsl:value-of select="@title"/></Title>
+					<YearTaken><xsl:value-of select="@yeartaken"/></YearTaken>
+					<Grade><xsl:value-of select="@grade"/></Grade>
+				</Course>
+			</xsl:for-each>
+      	</Courses>
+      </Student>
+    </xsl:for-each-group>
+	</GraduatingStudents>
+  </xsl:template>
+
+</xsl:stylesheet>
diff --git a/studentClient/derby/XML/XmlToSql.xsl b/studentClient/derby/XML/XmlToSql.xsl
new file mode 100755
index 0000000..c7c2a0f
--- /dev/null
+++ b/studentClient/derby/XML/XmlToSql.xsl
@@ -0,0 +1,22 @@
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="2.0">
+
+  <xsl:output method="text"/>
+  
+  <xsl:template match="GraduatingStudents">
+    <xsl:apply-templates select="Student"/>
+	<xsl:apply-templates select="Student/Courses/Course"/>
+  </xsl:template>
+
+  <xsl:template match="Student">
+  	insert into APPLICANT (AppName, GradYear) values(
+	'<xsl:value-of select="SName"/>', <xsl:value-of select="GradYear"/> );
+  </xsl:template>
+  
+  <xsl:template match="Course">
+	insert into COURSE_TAKEN(AppName, Title, Grade) values(
+	'<xsl:value-of select="../../SName"/>',
+	'<xsl:value-of select="Title"/>',
+	'<xsl:value-of select="Grade"/>');
+  </xsl:template>
+ 
+</xsl:stylesheet>
diff --git a/studentClient/derby/XML/XmlToUnnested.xsl b/studentClient/derby/XML/XmlToUnnested.xsl
new file mode 100755
index 0000000..5adf56d
--- /dev/null
+++ b/studentClient/derby/XML/XmlToUnnested.xsl
@@ -0,0 +1,21 @@
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
+
+  <xsl:output method="xml" indent="yes"/>
+  
+  <xsl:template match="GraduatingStudents">
+	<Enrollments>
+	    <xsl:apply-templates select="Student/Courses/Course"/>
+	</Enrollments>
+  </xsl:template>
+
+  <xsl:template match="Course">
+	<CourseTaken
+		sname="{../../SName}"
+		gradyear="{../../GradYear}"
+		title="{Title}"
+		yeartaken="{YearTaken}"
+		grade="{Grade}"
+	/>
+  </xsl:template>
+ 
+</xsl:stylesheet>
diff --git a/studentClient/simpledb/ChangeMajor.class b/studentClient/simpledb/ChangeMajor.class
new file mode 100755
index 0000000..519d341
Binary files /dev/null and b/studentClient/simpledb/ChangeMajor.class differ
diff --git a/studentClient/simpledb/ChangeMajor.java b/studentClient/simpledb/ChangeMajor.java
new file mode 100755
index 0000000..00df4e6
--- /dev/null
+++ b/studentClient/simpledb/ChangeMajor.java
@@ -0,0 +1,30 @@
+import java.sql.*;
+import simpledb.remote.SimpleDriver;
+
+public class ChangeMajor {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			Driver d = new SimpleDriver();
+			conn = d.connect("jdbc:simpledb://localhost", null);
+			Statement stmt = conn.createStatement();
+
+			String cmd = "update STUDENT set MajorId=30 "
+			           + "where SName = 'amy'";
+			stmt.executeUpdate(cmd);
+			System.out.println("Amy is now a drama major.");
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/simpledb/CreateStudentDB.class b/studentClient/simpledb/CreateStudentDB.class
new file mode 100755
index 0000000..d41cc0b
Binary files /dev/null and b/studentClient/simpledb/CreateStudentDB.class differ
diff --git a/studentClient/simpledb/CreateStudentDB.java b/studentClient/simpledb/CreateStudentDB.java
new file mode 100755
index 0000000..c24b6f9
--- /dev/null
+++ b/studentClient/simpledb/CreateStudentDB.java
@@ -0,0 +1,100 @@
+import java.sql.*;
+import simpledb.remote.SimpleDriver;
+
+public class CreateStudentDB {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			Driver d = new SimpleDriver();
+			conn = d.connect("jdbc:simpledb://localhost", null);
+			Statement stmt = conn.createStatement();
+
+			String s = "create table STUDENT(SId int, SName varchar(10), MajorId int, GradYear int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table STUDENT created.");
+
+			s = "insert into STUDENT(SId, SName, MajorId, GradYear) values ";
+			String[] studvals = {"(1, 'joe', 10, 2004)",
+								 "(2, 'amy', 20, 2004)",
+								 "(3, 'max', 10, 2005)",
+								 "(4, 'sue', 20, 2005)",
+								 "(5, 'bob', 30, 2003)",
+								 "(6, 'kim', 20, 2001)",
+								 "(7, 'art', 30, 2004)",
+								 "(8, 'pat', 20, 2001)",
+								 "(9, 'lee', 10, 2004)"};
+			for (int i=0; i<studvals.length; i++)
+				stmt.executeUpdate(s + studvals[i]);
+			System.out.println("STUDENT records inserted.");
+
+			s = "create table DEPT(DId int, DName varchar(8))";
+			stmt.executeUpdate(s);
+			System.out.println("Table DEPT created.");
+
+			s = "insert into DEPT(DId, DName) values ";
+			String[] deptvals = {"(10, 'compsci')",
+								 "(20, 'math')",
+								 "(30, 'drama')"};
+			for (int i=0; i<deptvals.length; i++)
+				stmt.executeUpdate(s + deptvals[i]);
+			System.out.println("DEPT records inserted.");
+
+			s = "create table COURSE(CId int, Title varchar(20), DeptId int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table COURSE created.");
+
+			s = "insert into COURSE(CId, Title, DeptId) values ";
+			String[] coursevals = {"(12, 'db systems', 10)",
+								   "(22, 'compilers', 10)",
+								   "(32, 'calculus', 20)",
+								   "(42, 'algebra', 20)",
+								   "(52, 'acting', 30)",
+								   "(62, 'elocution', 30)"};
+			for (int i=0; i<coursevals.length; i++)
+				stmt.executeUpdate(s + coursevals[i]);
+			System.out.println("COURSE records inserted.");
+
+			s = "create table SECTION(SectId int, CourseId int, Prof varchar(8), YearOffered int)";
+			stmt.executeUpdate(s);
+			System.out.println("Table SECTION created.");
+
+			s = "insert into SECTION(SectId, CourseId, Prof, YearOffered) values ";
+			String[] sectvals = {"(13, 12, 'turing', 2004)",
+								 "(23, 12, 'turing', 2005)",
+								 "(33, 32, 'newton', 2000)",
+								 "(43, 32, 'einstein', 2001)",
+								 "(53, 62, 'brando', 2001)"};
+			for (int i=0; i<sectvals.length; i++)
+				stmt.executeUpdate(s + sectvals[i]);
+			System.out.println("SECTION records inserted.");
+
+			s = "create table ENROLL(EId int, StudentId int, SectionId int, Grade varchar(2))";
+			stmt.executeUpdate(s);
+			System.out.println("Table ENROLL created.");
+
+			s = "insert into ENROLL(EId, StudentId, SectionId, Grade) values ";
+			String[] enrollvals = {"(14, 1, 13, 'A')",
+								   "(24, 1, 43, 'C' )",
+								   "(34, 2, 43, 'B+')",
+								   "(44, 4, 33, 'B' )",
+								   "(54, 4, 53, 'A' )",
+								   "(64, 6, 53, 'A' )"};
+			for (int i=0; i<enrollvals.length; i++)
+				stmt.executeUpdate(s + enrollvals[i]);
+			System.out.println("ENROLL records inserted.");
+
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/simpledb/FindMajors.class b/studentClient/simpledb/FindMajors.class
new file mode 100755
index 0000000..e8d3bc9
Binary files /dev/null and b/studentClient/simpledb/FindMajors.class differ
diff --git a/studentClient/simpledb/FindMajors.java b/studentClient/simpledb/FindMajors.java
new file mode 100755
index 0000000..2c267a9
--- /dev/null
+++ b/studentClient/simpledb/FindMajors.java
@@ -0,0 +1,46 @@
+import java.sql.*;
+import simpledb.remote.SimpleDriver;
+
+public class FindMajors {
+    public static void main(String[] args) {
+		String major = args[0];
+		System.out.println("Here are the " + major + " majors");
+		System.out.println("Name\tGradYear");
+
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new SimpleDriver();
+			conn = d.connect("jdbc:simpledb://localhost", null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select sname, gradyear "
+			           + "from student, dept "
+			           + "where did = majorid "
+			           + "and dname = '" + major + "'";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			// Step 3: loop through the result set
+			while (rs.next()) {
+				String sname = rs.getString("sname");
+				int gradyear = rs.getInt("gradyear");
+				System.out.println(sname + "\t" + gradyear);
+			}
+			rs.close();
+		}
+		catch(Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/studentClient/simpledb/SQLInterpreter.class b/studentClient/simpledb/SQLInterpreter.class
new file mode 100755
index 0000000..d854a39
Binary files /dev/null and b/studentClient/simpledb/SQLInterpreter.class differ
diff --git a/studentClient/simpledb/SQLInterpreter.java b/studentClient/simpledb/SQLInterpreter.java
new file mode 100755
index 0000000..be3f705
--- /dev/null
+++ b/studentClient/simpledb/SQLInterpreter.java
@@ -0,0 +1,95 @@
+import java.sql.*;
+import simpledb.remote.SimpleDriver;
+import java.io.*;
+
+public class SQLInterpreter {
+    private static Connection conn = null;
+
+    public static void main(String[] args) {
+	   try {
+			Driver d = new SimpleDriver();
+			conn = d.connect("jdbc:simpledb://localhost", null);
+
+			Reader rdr = new InputStreamReader(System.in);
+			BufferedReader br = new BufferedReader(rdr);
+
+			while (true) {
+				// process one line of input
+				System.out.print("\nSQL> ");
+				String cmd = br.readLine().trim();
+				System.out.println();
+				if (cmd.startsWith("exit"))
+					break;
+				else if (cmd.startsWith("select"))
+					doQuery(cmd);
+				else
+					doUpdate(cmd);
+		    }
+	    }
+	    catch (Exception e) {
+			e.printStackTrace();
+		}
+		finally {
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	private static void doQuery(String cmd) {
+		try {
+		    Statement stmt = conn.createStatement();
+		    ResultSet rs = stmt.executeQuery(cmd);
+		    ResultSetMetaData md = rs.getMetaData();
+		    int numcols = md.getColumnCount();
+		    int totalwidth = 0;
+
+		    // print header
+		    for(int i=1; i<=numcols; i++) {
+				int width = md.getColumnDisplaySize(i);
+				totalwidth += width;
+				String fmt = "%" + width + "s";
+				System.out.format(fmt, md.getColumnName(i));
+			}
+			System.out.println();
+			for(int i=0; i<totalwidth; i++)
+			    System.out.print("-");
+		    System.out.println();
+
+		    // print records
+		    while(rs.next()) {
+				for (int i=1; i<=numcols; i++) {
+					String fldname = md.getColumnName(i);
+					int fldtype = md.getColumnType(i);
+					String fmt = "%" + md.getColumnDisplaySize(i);
+					if (fldtype == Types.INTEGER)
+						System.out.format(fmt + "d", rs.getInt(fldname));
+					else
+						System.out.format(fmt + "s", rs.getString(fldname));
+				}
+				System.out.println();
+			}
+			rs.close();
+		}
+		catch (SQLException e) {
+			System.out.println("SQL Exception: " + e.getMessage());
+			e.printStackTrace();
+		}
+	}
+
+	private static void doUpdate(String cmd) {
+		try {
+		    Statement stmt = conn.createStatement();
+		    int howmany = stmt.executeUpdate(cmd);
+		    System.out.println(howmany + " records processed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL Exception: " + e.getMessage());
+			e.printStackTrace();
+		}
+	}
+}
\ No newline at end of file
diff --git a/studentClient/simpledb/StudentMajor.class b/studentClient/simpledb/StudentMajor.class
new file mode 100755
index 0000000..188f5f5
Binary files /dev/null and b/studentClient/simpledb/StudentMajor.class differ
diff --git a/studentClient/simpledb/StudentMajor.java b/studentClient/simpledb/StudentMajor.java
new file mode 100755
index 0000000..75a5ad9
--- /dev/null
+++ b/studentClient/simpledb/StudentMajor.java
@@ -0,0 +1,42 @@
+import java.sql.*;
+import simpledb.remote.SimpleDriver;
+
+public class StudentMajor {
+    public static void main(String[] args) {
+		Connection conn = null;
+		try {
+			// Step 1: connect to database server
+			Driver d = new SimpleDriver();
+			conn = d.connect("jdbc:simpledb://localhost", null);
+
+			// Step 2: execute the query
+			Statement stmt = conn.createStatement();
+			String qry = "select SName, DName "
+			           + "from DEPT, STUDENT "
+			           + "where MajorId = DId";
+			ResultSet rs = stmt.executeQuery(qry);
+
+			// Step 3: loop through the result set
+			System.out.println("Name\tMajor");
+			while (rs.next()) {
+				String sname = rs.getString("SName");
+				String dname = rs.getString("DName");
+				System.out.println(sname + "\t" + dname);
+			}
+			rs.close();
+		}
+		catch(SQLException e) {
+			e.printStackTrace();
+		}
+		finally {
+			// Step 4: close the connection
+			try {
+				if (conn != null)
+					conn.close();
+			}
+			catch (SQLException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+}
diff --git a/test_res.textile b/test_res.textile
deleted file mode 100644
index ab8a6c0..0000000
--- a/test_res.textile
+++ /dev/null
@@ -1,52 +0,0 @@
-h1. Performance Testing
-
-h2. Output
-
-h3. Num Buffers = 200
-
-* Basic: 3339 ms (20160 I/Os)
-* LRU: 2664 ms (21 I/Os)
-* MRU: 2939 ms (20160 I/Os)
-
-h3. Num Buffers = 16
-
-* Basic: 1500 ms (20160 I/Os)
-* LRU: 824 ms (86 I/Os)
-* MRU: 920 ms (20160 I/Os)
-
-h3. Num Buffers = 8 (default)
-
-* Basic: 1531 ms (20160 I/Os)
-* LRU: 904 ms (20152 I/Os)
-* MRU: 959 ms (20160 I/Os)
-
-h2. Analysis
-
-One thing to note is that the inclusion of the I/O counting mechanism _really_ slowed down the speeds at which the db ran.  The tests
-took around 1s longer.  The numbers reported above are with I/O tracking, using 200 buffer pages.  Clearly LRU performs faster, which it
-should, considering it is optimized.  As for the MRU, while it preforms slightly faster that Basic (this difference in speed between Basic and
-MRU decreases without the I/O count mechanisms), it is not much faster.  This makes sense, considering that it uses the most recently used
-buffer pages first, which is a deoptimization.  The increase in speed compared to basic, however, comes from the fact that it still keeps track
-of unused pages in a separate place, so there is no searching required to find pages.
-
-As for the differences in speed and I/Os among different numbers of buffers, clearly fewer buffers would cause increaded I/Os in LRU (as is evidenced for the # = 8),
-and most likely 200 buffer slots has too much of an overhead because of the sheer size of it.
-
-h1. Functionality Testing
-
-h2. Output
-
-For the primary functionality tests (i.e. those which make sure the functionality of SimpleDB was not changed), the output can clearly
-be seen in the test file, as the tests use equality assertions to confirm that the data is the same.
-
-For the Buffer Status Test, the output is as follows (we reccomend that the output, being JSON, be pasted into the following web app with input set on "eval":
-"JSON formatter":http://chris.photobooks.com/json/default.htm).  Here is the output:
-
-{basicClass: "class simpledb.buffer.LRUBasicBufferMgr", basicmgr: {alg: "LRU", allocated: {"{file:fldcat.tbl, block:3}": {blk: {file: "fldcat.tbl", block: "3"}, pins: 0},"{file:fldcat.tbl, block:8}": {blk: {file: "fldcat.tbl", block: "8"}, pins: 0},"{file:fldcat.tbl, block:9}": {blk: {file: "fldcat.tbl", block: "9"}, pins: 0},"{file:tblcat.tbl, block:0}": {blk: {file: "tblcat.tbl", block: "0"}, pins: 0},"{file:section.tbl, block:0}": {blk: {file: "section.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:1}": {blk: {file: "fldcat.tbl", block: "1"}, pins: 0},"{file:tblcat.tbl, block:1}": {blk: {file: "tblcat.tbl", block: "1"}, pins: 0},"{file:course.tbl, block:1}": {blk: {file: "course.tbl", block: "1"}, pins: 0},"{file:fldcat.tbl, block:6}": {blk: {file: "fldcat.tbl", block: "6"}, pins: 0},"{file:course.tbl, block:0}": {blk: {file: "course.tbl", block: "0"}, pins: 0},"{file:dept.tbl, block:0}": {blk: {file: "dept.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:4}": {blk: {file: "fldcat.tbl", block: "4"}, pins: 0},"{file:fldcat.tbl, block:2}": {blk: {file: "fldcat.tbl", block: "2"}, pins: 0},"{file:fldcat.tbl, block:0}": {blk: {file: "fldcat.tbl", block: "0"}, pins: 0},"{file:enroll.tbl, block:0}": {blk: {file: "enroll.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:1}": {blk: {file: "student.tbl", block: "1"}, pins: 0},"{file:viewcat.tbl, block:0}": {blk: {file: "viewcat.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:0}": {blk: {file: "student.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:5}": {blk: {file: "fldcat.tbl", block: "5"}, pins: 0},"{file:idxcat.tbl, block:0}": {blk: {file: "idxcat.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:7}": {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}}, available: [{blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: {file: "idxcat.tbl", block: "0"}, pins: 0}, {blk: {file: "dept.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "1"}, pins: 0}, {blk: {file: "section.tbl", block: "0"}, pins: 0}, {blk: {file: "enroll.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "1"}, pins: 0}, {blk: {file: "viewcat.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "1"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "2"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "3"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "4"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "5"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "6"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "8"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "9"}, pins: 0}, {blk: {file: "student.tbl", block: "1"}, pins: 0}, {blk: {file: "student.tbl", block: "0"}, pins: 0}]}}
-
-{basicClass: "class simpledb.buffer.LRUBasicBufferMgr", basicmgr: {alg: "LRU", allocated: {"{file:fldcat.tbl, block:3}": {blk: {file: "fldcat.tbl", block: "3"}, pins: 0},"{file:fldcat.tbl, block:8}": {blk: {file: "fldcat.tbl", block: "8"}, pins: 0},"{file:fldcat.tbl, block:9}": {blk: {file: "fldcat.tbl", block: "9"}, pins: 0},"{file:tblcat.tbl, block:0}": {blk: {file: "tblcat.tbl", block: "0"}, pins: 0},"{file:section.tbl, block:0}": {blk: {file: "section.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:1}": {blk: {file: "fldcat.tbl", block: "1"}, pins: 0},"{file:tblcat.tbl, block:1}": {blk: {file: "tblcat.tbl", block: "1"}, pins: 0},"{file:course.tbl, block:1}": {blk: {file: "course.tbl", block: "1"}, pins: 0},"{file:fldcat.tbl, block:6}": {blk: {file: "fldcat.tbl", block: "6"}, pins: 0},"{file:course.tbl, block:0}": {blk: {file: "course.tbl", block: "0"}, pins: 0},"{file:dept.tbl, block:0}": {blk: {file: "dept.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:4}": {blk: {file: "fldcat.tbl", block: "4"}, pins: 0},"{file:fldcat.tbl, block:2}": {blk: {file: "fldcat.tbl", block: "2"}, pins: 0},"{file:fldcat.tbl, block:0}": {blk: {file: "fldcat.tbl", block: "0"}, pins: 0},"{file:enroll.tbl, block:0}": {blk: {file: "enroll.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:1}": {blk: {file: "student.tbl", block: "1"}, pins: 0},"{file:viewcat.tbl, block:0}": {blk: {file: "viewcat.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:0}": {blk: {file: "student.tbl", block: "0"}, pins: 1},"{file:fldcat.tbl, block:5}": {blk: {file: "fldcat.tbl", block: "5"}, pins: 0},"{file:idxcat.tbl, block:0}": {blk: {file: "idxcat.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:7}": {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}}, available: [{blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: {file: "idxcat.tbl", block: "0"}, pins: 0}, {blk: {file: "dept.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "1"}, pins: 0}, {blk: {file: "section.tbl", block: "0"}, pins: 0}, {blk: {file: "enroll.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "1"}, pins: 0}, {blk: {file: "student.tbl", block: "1"}, pins: 0}, {blk: {file: "viewcat.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "1"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "2"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "3"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "4"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "5"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "6"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "8"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "9"}, pins: 0}]}}
-
-{basicClass: "class simpledb.buffer.LRUBasicBufferMgr", basicmgr: {alg: "LRU", allocated: {"{file:fldcat.tbl, block:3}": {blk: {file: "fldcat.tbl", block: "3"}, pins: 0},"{file:fldcat.tbl, block:8}": {blk: {file: "fldcat.tbl", block: "8"}, pins: 0},"{file:fldcat.tbl, block:9}": {blk: {file: "fldcat.tbl", block: "9"}, pins: 0},"{file:tblcat.tbl, block:0}": {blk: {file: "tblcat.tbl", block: "0"}, pins: 0},"{file:section.tbl, block:0}": {blk: {file: "section.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:1}": {blk: {file: "fldcat.tbl", block: "1"}, pins: 0},"{file:tblcat.tbl, block:1}": {blk: {file: "tblcat.tbl", block: "1"}, pins: 0},"{file:course.tbl, block:1}": {blk: {file: "course.tbl", block: "1"}, pins: 0},"{file:fldcat.tbl, block:6}": {blk: {file: "fldcat.tbl", block: "6"}, pins: 0},"{file:course.tbl, block:0}": {blk: {file: "course.tbl", block: "0"}, pins: 0},"{file:dept.tbl, block:0}": {blk: {file: "dept.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:4}": {blk: {file: "fldcat.tbl", block: "4"}, pins: 0},"{file:fldcat.tbl, block:2}": {blk: {file: "fldcat.tbl", block: "2"}, pins: 0},"{file:fldcat.tbl, block:0}": {blk: {file: "fldcat.tbl", block: "0"}, pins: 0},"{file:enroll.tbl, block:0}": {blk: {file: "enroll.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:1}": {blk: {file: "student.tbl", block: "1"}, pins: 0},"{file:viewcat.tbl, block:0}": {blk: {file: "viewcat.tbl", block: "0"}, pins: 0},"{file:student.tbl, block:0}": {blk: {file: "student.tbl", block: "0"}, pins: 2},"{file:fldcat.tbl, block:5}": {blk: {file: "fldcat.tbl", block: "5"}, pins: 0},"{file:idxcat.tbl, block:0}": {blk: {file: "idxcat.tbl", block: "0"}, pins: 0},"{file:fldcat.tbl, block:7}": {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}}, available: [{blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: null, pins: 0}, {blk: {file: "idxcat.tbl", block: "0"}, pins: 0}, {blk: {file: "dept.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "0"}, pins: 0}, {blk: {file: "course.tbl", block: "1"}, pins: 0}, {blk: {file: "section.tbl", block: "0"}, pins: 0}, {blk: {file: "enroll.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "1"}, pins: 0}, {blk: {file: "student.tbl", block: "1"}, pins: 0}, {blk: {file: "viewcat.tbl", block: "0"}, pins: 0}, {blk: {file: "tblcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "0"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "1"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "2"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "3"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "4"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "5"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "6"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "7"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "8"}, pins: 0}, {blk: {file: "fldcat.tbl", block: "9"}, pins: 0}]}}
-
-
-The first line is before any actions, the second is after a simple select query, and the third is after a similar select query with a where condition.
diff --git a/tests/com/wpi/cs4432/simpledb/tests/functionality/BasicSQLFunctionalityTest.java b/tests/com/wpi/cs4432/simpledb/tests/functionality/BasicSQLFunctionalityTest.java
deleted file mode 100644
index c3c47e7..0000000
--- a/tests/com/wpi/cs4432/simpledb/tests/functionality/BasicSQLFunctionalityTest.java
+++ /dev/null
@@ -1,246 +0,0 @@
-package com.wpi.cs4432.simpledb.tests.functionality;
-
-import static org.junit.Assert.*;
-
-import java.rmi.Naming;
-import java.rmi.registry.LocateRegistry;
-import java.sql.Connection;
-import java.sql.Driver;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.Date;
-import java.util.LinkedList;
-import java.util.Random;
-
-import org.apache.derby.iapi.services.io.ArrayUtil;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.internal.ArrayComparisonFailure;
-
-import simpledb.buffer.BasicBufferMgr;
-import simpledb.buffer.BufferMgr;
-import simpledb.buffer.LRUBasicBufferMgr;
-import simpledb.buffer.MRUBasicBufferMgr;
-import simpledb.remote.RemoteDriver;
-import simpledb.remote.RemoteDriverImpl;
-import simpledb.remote.SimpleDriver;
-import simpledb.server.SimpleDB;
-import simpledb.studentClient.CreateStudentDB;
-
-public class BasicSQLFunctionalityTest {
-	static Thread serverThread;
-	static Driver mainDriver;
-	static Connection mainConnection;
-	Statement stmt;
-	
-	
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@BeforeClass
-	public static void setUpBeforeClass() throws Exception
-	{
-		try
-		{
-			LocateRegistry.createRegistry(1099); // default
-		}
-		catch(Exception ex)
-		{
-			
-		}
-		
-		serverThread = new Thread(new Runnable() {
-			
-			@Override
-			public void run() {
-				try
-				{
-					BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-					// configure and initialize the database
-					SimpleDB.init("studentdb");
-					System.out.println("finished init of SimpleDB");
-					// post the server entry in the rmi registry
-					RemoteDriver d = new RemoteDriverImpl();
-					Naming.rebind("simpledb", d);
-
-				} catch (Exception e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				
-			}
-		});
-		
-		serverThread.start();	
-		
-		mainDriver = new SimpleDriver();
-		String connURL = "jdbc:simpledb://localhost";
-		boolean b = true;
-		while(b)
-		{
-			try
-			{
-				mainConnection = mainDriver.connect(connURL, null);
-				
-				b = false;
-			}
-			catch(Exception ex)
-			{
-				continue;
-			}
-		}
-		
-		Statement stmt = mainConnection.createStatement();
-		try
-		{
-			stmt.executeQuery("Select SId from STUDENT");
-		}
-		catch(SQLException ex)
-		{
-			CreateStudentDB.main(new String[] {});
-		}
-	}
-	
-	
-	@Before
-	public void setupBefore() throws SQLException
-	{
-		if (stmt == null) stmt = mainConnection.createStatement();
-		stmt.executeUpdate("delete from STUDENT where SId = 10;");
-	}
-	
-	public String[][] getResultSetAsArray(ResultSet rs, String cols[], Class cls[]) throws SQLException
-	{
-		LinkedList<String[]> res = new LinkedList<String[]>();
-		
-		while(rs.next())
-		{
-			String[] row = new String[cols.length];
-			for (int i = 0; i < cols.length; i++)
-			{
-				if(cls[i] == String.class) row[i] = rs.getString(cols[i]);
-				else if(cls[i] == Integer.class) row[i] = Integer.toString(rs.getInt(cols[i]));
-				else throw new RuntimeException("Ohes noze!");
-			}
-			res.add(row);
-		}
-		
-		return res.toArray(new String[][] {});
-	}
-	
-	public String stringArrayToString(String[][] strs)
-	{
-		StringBuilder sb = new StringBuilder("[");
-		for (int i = 0; i < strs.length; i++)
-		{
-			sb.append('[');
-			for (int j = 0; j < strs[i].length; j++)
-			{
-				sb.append(strs[i][j]);
-				if (j < strs[i].length - 1) sb.append(",");
-			}
-			sb.append(']');
-			if (i < strs.length - 1) sb.append(',');
-		}
-		sb.append(']');
-		
-		return sb.toString();
-	}
-	
-	@Test
-	public void testBasicBuffMgrQueries() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(BasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		ResultSet res1 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res1Str = getResultSetAsArray(res1, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res1Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res2 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where gradyear = 2004;");
-		String[][] res2Str = getResultSetAsArray(res2, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[7,art,2004,30],[9,lee,2004,10]]", stringArrayToString(res2Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res3 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		String[][] res3Str = getResultSetAsArray(res3, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res3Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		stmt.executeUpdate("insert into STUDENT(SId, SName, GradYear, MajorId) values (10, 'cheese', 2021, 10);");
-		ResultSet res4 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res4Str = getResultSetAsArray(res4, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10],[10,cheese,2021,10]]", stringArrayToString(res4Str));
-	}
-	
-	@Test
-	public void testLRUBasicBuffMgrQueries() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		ResultSet res1 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res1Str = getResultSetAsArray(res1, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res1Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res2 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where gradyear = 2004;");
-		String[][] res2Str = getResultSetAsArray(res2, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[7,art,2004,30],[9,lee,2004,10]]", stringArrayToString(res2Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res3 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		String[][] res3Str = getResultSetAsArray(res3, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res3Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		stmt.executeUpdate("insert into STUDENT(SId, SName, GradYear, MajorId) values (10, 'cheese', 2021, 10);");
-		ResultSet res4 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res4Str = getResultSetAsArray(res4, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10],[10,cheese,2021,10]]", stringArrayToString(res4Str));
-	}
-	
-	@Test
-	public void testMRUBasicBuffMgrQueries() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(MRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		ResultSet res1 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res1Str = getResultSetAsArray(res1, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res1Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res2 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where gradyear = 2004;");
-		String[][] res2Str = getResultSetAsArray(res2, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[7,art,2004,30],[9,lee,2004,10]]", stringArrayToString(res2Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		ResultSet res3 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		String[][] res3Str = getResultSetAsArray(res3, new String[] { "SId", "SName", "GradYear", "MajorId" }, new Class[] {Integer.class, String.class, Integer.class, Integer.class });
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10]]", stringArrayToString(res3Str));
-		//assertArrayEquals(new String[][] {{"1", "joe", "2004", "10"}, {"2", "amy", "2004", "20"}, {"3", "max", "2005", "10"}, {"4", "sue", "2005", "20"}, {"5", "bob", "2003", "30"}, {"6", "kim", "2001", "20"}, {"7", "art", "2004", "30"}, {"8", "pat", "2001", "20"}, {"9", "lee", "2004", "10"}}, res1Str);
-		
-		stmt.executeUpdate("insert into STUDENT(SId, SName, GradYear, MajorId) values (10, 'cheese', 2021, 10);");
-		ResultSet res4 = stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-		String[][] res4Str = getResultSetAsArray(res4, new String[] { "SId", "SName", "GradYear", "MajorId"}, new Class[] {Integer.class, String.class, Integer.class, Integer.class});
-		assertEquals("[[1,joe,2004,10],[2,amy,2004,20],[3,max,2005,10],[4,sue,2005,20],[5,bob,2003,30],[6,kim,2001,20],[7,art,2004,30],[8,pat,2001,20],[9,lee,2004,10],[10,cheese,2021,10]]", stringArrayToString(res4Str));
-	}
-	
-	@After
-	public void tearDownAfter() throws SQLException
-	{
-		//stmt.executeUpdate("delete from STUDENT where SId = 10;");
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@AfterClass
-	public static void tearDownAfterClass() throws Exception
-	{
-		serverThread.stop();
-	}
-}
diff --git a/tests/com/wpi/cs4432/simpledb/tests/functionality/BufferStatusTest.java b/tests/com/wpi/cs4432/simpledb/tests/functionality/BufferStatusTest.java
deleted file mode 100644
index 81e7842..0000000
--- a/tests/com/wpi/cs4432/simpledb/tests/functionality/BufferStatusTest.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package com.wpi.cs4432.simpledb.tests.functionality;
-
-import static org.junit.Assert.*;
-
-import java.rmi.Naming;
-import java.rmi.registry.LocateRegistry;
-import java.sql.Connection;
-import java.sql.Driver;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.Date;
-import java.util.LinkedList;
-import java.util.Random;
-
-import org.apache.derby.iapi.services.io.ArrayUtil;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.internal.ArrayComparisonFailure;
-
-import simpledb.buffer.BasicBufferMgr;
-import simpledb.buffer.BufferMgr;
-import simpledb.buffer.LRUBasicBufferMgr;
-import simpledb.buffer.MRUBasicBufferMgr;
-import simpledb.remote.RemoteDriver;
-import simpledb.remote.RemoteDriverImpl;
-import simpledb.remote.SimpleDriver;
-import simpledb.server.SimpleDB;
-import simpledb.studentClient.CreateStudentDB;
-
-public class BufferStatusTest {
-	static Thread serverThread;
-	static Driver mainDriver;
-	static Connection mainConnection;
-	Statement stmt;
-	
-	
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@BeforeClass
-	public static void setUpBeforeClass() throws Exception
-	{
-		try
-		{
-			LocateRegistry.createRegistry(1099); // default
-		}
-		catch(Exception ex)
-		{
-			
-		}
-		
-		serverThread = new Thread(new Runnable() {
-			
-			@Override
-			public void run() {
-				try
-				{
-					BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-					// configure and initialize the database
-					SimpleDB.init("studentdb");
-					System.out.println("finished init of SimpleDB");
-					// post the server entry in the rmi registry
-					RemoteDriver d = new RemoteDriverImpl();
-					Naming.rebind("simpledb", d);
-
-				} catch (Exception e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				
-			}
-		});
-		
-		serverThread.start();	
-		
-		mainDriver = new SimpleDriver();
-		String connURL = "jdbc:simpledb://localhost";
-		boolean b = true;
-		while(b)
-		{
-			try
-			{
-				mainConnection = mainDriver.connect(connURL, null);
-				
-				b = false;
-			}
-			catch(Exception ex)
-			{
-				continue;
-			}
-		}
-		
-		Statement stmt = mainConnection.createStatement();
-		try
-		{
-			stmt.executeQuery("Select SId from STUDENT");
-		}
-		catch(SQLException ex)
-		{
-			CreateStudentDB.main(new String[] {});
-		}
-	}
-	
-	@Before
-	public void setupBefore() throws SQLException
-	{
-		if (stmt == null) stmt = mainConnection.createStatement();
-		stmt.executeUpdate("delete from STUDENT where SId = 10;");
-	}
-	
-	public String[][] getResultSetAsArray(ResultSet rs, String cols[], Class cls[]) throws SQLException
-	{
-		LinkedList<String[]> res = new LinkedList<String[]>();
-		
-		while(rs.next())
-		{
-			String[] row = new String[cols.length];
-			for (int i = 0; i < cols.length; i++)
-			{
-				if(cls[i] == String.class) row[i] = rs.getString(cols[i]);
-				else if(cls[i] == Integer.class) row[i] = Integer.toString(rs.getInt(cols[i]));
-				else throw new RuntimeException("Ohes noze!");
-			}
-			res.add(row);
-		}
-		
-		return res.toArray(new String[][] {});
-	}
-	
-	public String stringArrayToString(String[][] strs)
-	{
-		StringBuilder sb = new StringBuilder("[");
-		for (int i = 0; i < strs.length; i++)
-		{
-			sb.append('[');
-			for (int j = 0; j < strs[i].length; j++)
-			{
-				sb.append(strs[i][j]);
-				if (j < strs[i].length - 1) sb.append(",");
-			}
-			sb.append(']');
-			if (i < strs.length - 1) sb.append(',');
-		}
-		sb.append(']');
-		
-		return sb.toString();
-	}
-	
-	@Test
-	public void testBufferStatus() throws SQLException
-	{
-		BufferMgr buffMgr = SimpleDB.bufferMgr();
-		System.out.println(buffMgr.toString());
-		stmt.executeQuery("select sid, sname from student;");
-		System.out.println(buffMgr.toString());
-		stmt.executeQuery("select sid, sname from student where sid = 3;");
-		System.out.println(buffMgr.toString());
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@AfterClass
-	public static void tearDownAfterClass() throws Exception
-	{
-		serverThread.stop();
-	}
-}
\ No newline at end of file
diff --git a/tests/com/wpi/cs4432/simpledb/tests/performance/BufferMgrPerfomanceTests.java b/tests/com/wpi/cs4432/simpledb/tests/performance/BufferMgrPerfomanceTests.java
deleted file mode 100644
index ad39946..0000000
--- a/tests/com/wpi/cs4432/simpledb/tests/performance/BufferMgrPerfomanceTests.java
+++ /dev/null
@@ -1,263 +0,0 @@
-/**
- * 
- */
-package com.wpi.cs4432.simpledb.tests.performance;
-
-import java.rmi.Naming;
-import java.rmi.registry.LocateRegistry;
-import java.sql.Connection;
-import java.sql.Driver;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.Date;
-import java.util.Random;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import simpledb.buffer.BasicBufferMgr;
-import simpledb.buffer.BufferMgr;
-import simpledb.buffer.LRUBasicBufferMgr;
-import simpledb.buffer.MRUBasicBufferMgr;
-import simpledb.remote.RemoteDriver;
-import simpledb.remote.RemoteDriverImpl;
-import simpledb.remote.SimpleDriver;
-import simpledb.server.SimpleDB;
-import simpledb.studentClient.CreateStudentDB;
-
-/**
- * @author directxman12
- *
- */
-public class BufferMgrPerfomanceTests
-{
-	static Thread serverThread;
-	static Driver mainDriver;
-	static Connection mainConnection;
-	Statement stmt;
-	
-	
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@BeforeClass
-	public static void setUpBeforeClass() throws Exception
-	{
-		try
-		{
-			LocateRegistry.createRegistry(1099); // default
-		}
-		catch(Exception ex)
-		{
-			
-		}
-		
-		serverThread = new Thread(new Runnable() {
-			
-			@Override
-			public void run() {
-				try
-				{
-					BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-					// configure and initialize the database
-					SimpleDB.init("studentdb");
-					System.out.println("finished init of SimpleDB");
-					// post the server entry in the rmi registry
-					RemoteDriver d = new RemoteDriverImpl();
-					Naming.rebind("simpledb", d);
-
-				} catch (Exception e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				
-			}
-		});
-		
-		serverThread.start();	
-		
-		mainDriver = new SimpleDriver();
-		String connURL = "jdbc:simpledb://localhost";
-		boolean b = true;
-		while(b)
-		{
-			try
-			{
-				mainConnection = mainDriver.connect(connURL, null);
-				
-				b = false;
-			}
-			catch(Exception ex)
-			{
-				continue;
-			}
-		}
-		
-		Statement stmt = mainConnection.createStatement();
-		try
-		{
-			stmt.executeQuery("Select SId from STUDENT");
-		}
-		catch(SQLException ex)
-		{
-			CreateStudentDB.main(new String[] {});
-		}
-	}
-	
-	/*@Test
-	public void testInitConn() throws SQLException
-	{
-		stmt.executeQuery("select SId, SName, MajorId, GradYear from STUDENT");
-	}*/
-	
-	/*@Test
-	public void testStudentDBSelectPerf() throws SQLException
-	{
-		for(int i = 1; i < 1000; i++)
-		{
-			stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT;");
-		}
-	}*/
-	
-	/*@Test
-	public void testStudentDBSortPerf() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(BasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		
-		Random r = new Random();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-	}
-	
-	@Test
-	public void testStudentDBLRUSortPerf() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		Random r = new Random();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-	}
-	
-	@Test
-	public void testStudentDBMRUSortPerf() throws SQLException
-	{
-		BufferMgr.setBasicBuffMgrType(MRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		Random r = new Random();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-	}*/
-	
-	@Test
-	public void testPerf() throws SQLException
-	{
-		long init = 0;
-		long end1 = 0;
-		long end2 = 0;
-		long end3 = 0;
-		int io1 = 0;
-		int io2 = 0;
-		int io3 = 0;
-		
-		Random r = new Random();
-		init = new Date().getTime();
-		BufferMgr.setBasicBuffMgrType(BasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-		io1 = SimpleDB.bufferMgr().getIOCount();
-		end1 = new Date().getTime();
-		BufferMgr.setBasicBuffMgrType(LRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-		
-		io2 = SimpleDB.bufferMgr().getIOCount();
-		end2 = new Date().getTime();
-		
-		
-		BufferMgr.setBasicBuffMgrType(MRUBasicBufferMgr.class);
-		SimpleDB.bufferMgr().resetBasicBufferMgr();
-		for (int i = 1; i < 1000; i++)
-		{
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by GradYear DESC;");
-			//stmt.executeQuery("SELECT SId, SName, MajorId, GradYear from STUDENT order by MajorId DESC;");
-			int res = i % 3 + i % 2;//r.nextInt(3);
-			if (res == 0) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT;");
-			if (res == 1) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT where GradYear = 2004;");
-			if (res == 2) stmt.executeQuery("SELECT SId, SName, GradYear, MajorId from STUDENT order by MajorId DESC;");
-		}
-		io3 = SimpleDB.bufferMgr().getIOCount();
-		end3 = new Date().getTime();
-		
-		System.out.println("Basic: " + Long.toString(end1 - init) + " ms (" + io1 + " I/Os), LRU: " + Long.toString(end2 - end1) + " ms (" + io2 + " I/Os), MRU: " + Long.toString(end3 - end2) + " ms (" + io3 + " I/Os)");
-		
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@AfterClass
-	public static void tearDownAfterClass() throws Exception
-	{
-		serverThread.stop();
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp() throws Exception
-	{
-		stmt = mainConnection.createStatement();
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@After
-	public void tearDown() throws Exception
-	{
-	
-	}
-}
